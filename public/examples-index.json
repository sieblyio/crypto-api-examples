{
  "type": "folder",
  "name": "examples",
  "path": "examples",
  "children": [
    {
      "type": "folder",
      "name": "Binance",
      "path": "examples/Binance",
      "children": [
        {
          "type": "folder",
          "name": "Auth",
          "path": "examples/Binance/Auth",
          "children": [
            {
              "type": "file",
              "name": "rest-private-ed25519.ts",
              "path": "examples/Binance/Auth/rest-private-ed25519.ts",
              "code": "import { MainClient } from 'binance';\n\n// Received after creating a new API key with a self-generated RSA public key on binance\n\n// The self-generated RSA private key, this is never directly given to binance, but used to generate a signature\n// Note: this MUST include the \"BEGIN PRIVATE KEY\" header so the SDK understands this is RSA auth\nconst ed25519PrivateKey = `\n-----BEGIN PRIVATE KEY-----\nlkmlkm123lkms1s12s+lkmlkm123lkms1s12s\n-----END PRIVATE KEY-----\n`;\n\nconst ed25519APIKey = 'lkmlkm123lkms1s12slkmlkm123lkms1s12slkmlkm123lkms1s12s';\n\nconst client = new MainClient({\n  api_key: ed25519APIKey,\n  api_secret: ed25519PrivateKey,\n  beautifyResponses: true,\n});\n\n(async () => {\n  try {\n    console.log('private api call result: ', await client.getAccountInfo());\n  } catch (e) {\n    console.error('request failed: ', e);\n  }\n})();\n",
              "metadata": {}
            },
            {
              "type": "file",
              "name": "rest-private-rsa.ts",
              "path": "examples/Binance/Auth/rest-private-rsa.ts",
              "code": "import { MainClient } from 'binance';\n\n// Received after creating a new API key with a self-generated RSA public key on binance\nconst api_key =\n  'SIHqWcDeRoj6gkOjLjQh1dnV1CD7IEXAMPLELVa8wu04zNTYVSmJBIHsjQjgwWqt';\n\n// The self-generated RSA private key, this is never directly given to binance, but used to generate a signature\n// Note: this MUST include the \"BEGIN PRIVATE KEY\" header so the SDK understands this is RSA auth\nconst rsaPrivateKey = `\n-----BEGIN RSA PRIVATE KEY-----\nMIIJKQIBAAKCAgEA1uWxxOXZUaX6AeZszfEEEEXAMPLE5ipwxG7VPihVgssphDrr\nSOD0hZqnBmtF2bvT9ee1U0XOfMn+H+J5SH+1jgUpfioqH0L+KXl6wmLoPsadgfJz\n0SiQlFnKTkDXvMmecr6cdEXAMPLEEEEEc68CobvQ4Voz5qqpDwbohGtJh0p10PB/\n/0Ejcoz0UwrTDq8BGeFmWa9pL/7h2vHtw+QUUxlnGmt98M8KkKqqvVicMK+IVtng\n/QlDw9ofG2kQcbBkPRaTjNI+8ULtCDH0sOkZnT8PtGm4sEwmWH/dRWtUTWkMnUwC\nzuo/rWPb7WMprW2pKDTrLjUAr9M161t3Xa6WJO03K3NOxupy7ilululLY8d/WKWY\nDOZMvS5bPiPRUoZqlJneC0CT/2q1W6GfWzsTDCDTpgq/Ao7jTtnME9iadpwvFn0n\nMtNgJSrFDWPq8vKY9pRcEp/Na5qvIEOQIFnp/kIDPuMf+LZwO8lGFO3jnndY+628\n35rm7t6ZNM3NLoNCarvUCEasobgDJHw7x7c1fW/OxYtLrWGdMpsP0MewgGJZXcT7\nmvlBjQ+JWLoyIc5rYMIDw9RLWUPnrlRCxvPpsD9kDX7eaipdoik5yLyMaRvd16Vt\n9Bck/9pbSHazm41m/nd4KCZeGdsvrAA2bewwzFWQQV9EX6/VLBgbnGTsMe0CAwEA\nAQKCAgBjbFfn4fO+m8zkbihu0alHmCv/xIsuMfqEV0bfgCe34KjvnZbX3AQlgBzA\nkob5qrXxMmepBEX5ZDbnp483ZKap82d0EKv2VLdkluid4MbUrG2Y/oRpA5yIllZM\nCCIIHTvqmJeoST/cqecbajURHKpaC5wjdulGUjTvV+HhygV1y5Rgu7Rsc0WkLOSp\nOvvU8lDPGYKSAd7nrsPt2TqJBBAHNlyGU68r545ayis+eS2iNMQecqVuTIgGp/b2\nZpCOGO73eGeBopAubSlfPkWYR/Bq2Q86CCPDpSekkFveTz7spaqJZ+5wrt4RKX9K\nADP7Ih4+FOWuNiWAM3bh0iqStECQMfSGXfZhxH67leVG0YE9s7bwy8404/wCdc2b\nv89v38SYQWrBxHyQJAeFHwf656+T1BWQPMtqa3MezxI+gw8c4+nlfOhfcjHqI7Lp\nzppkox2ovmBAw+zRfOIM+hEYlEVi7E3HOdAa3pIZlpFnSgyFCM+/W+2A/dG5sf91\nvPolm2/Hrm613u9pLvEZtgCU0hi24X4Mc8hd3mDbRPPDsLjlhf5oBu0WIuObgVVv\nF+sqDmIEY1rFprcuc9GxNWvPc5DV/Sov+H87xBT0wcajVgBFlyoqexabsaUkMAHF\nH/M4pUVqMnxbrINqmfQbLOrdS863IJC2K185VicMx5wkYD7cIQKCAQEA8VRlVD+0\nr4LoMHGsdCfWruANcWTsTYchX520v4HMLzQqVNS+DS9yrrzB7R5JpO5A15pOYYuE\nzWVdHOsdfQBmA1pzMt8brm3hwlbE6gtyh1vFKWRq4D+uveHPvQnWzqyrWvDca8ia\n/qAwapVQdfvYfznxg6quayyi6wFTaNeG1/WCqhrowj2kCx8eB6NDZYl+OS9ZI9WC\nq/44iFERNuP0TXvQx8tgvSZXyu4/G618QzKh0Ii1uAATt2upa8dp1uGl2U7EqBE8\np5y4pPzJuwvB3j6LQON20u2Wpbg8PQZACMfKym7lYDO+9MloK/gAQpyeYJzbw92C\nYE/ymq4JVjCMCQKCAQEA4/X0I9TO8vT0D0l83o693QA3C09uSZ6j9Obx5UrtDnA9\nsMkkRoe+R/vvIpVDzukMEEOmCuxbcdPoniVUKlTooK0Llo6JJ1l8CdFzQsOR97Pe\ncsB6pxkLLH2qHx05xPBy4PyoBePVuJTMcEkn/78NU5yCdFQOfc+YEUTjV0y/eTRy\nOFrfFVjCb7OzUQGOwd3EwJlHBR5/a4+3AxvAOn+LhnMZ7vx/KeFJKyrqFzM7KFHf\nyIw2E1ZhmKzG+CkN1sZbns9kbMxH1VY6VcxoaUdYf2dXW6h/YAVHIwrE0RuXtmJm\nYH7poCeCQhNyUOVYM/4/2F05PzFL0Vp+wlckO0a3xQKCAQEA7qYgAl1xZ/MTe/yd\npsxSv+KvSIieKdjMxwpk2NEZw0BZ8EPloZJfXa8qMzu1ZhV6J/vfMRVQgfGQT+2t\n3pSLTRugOhlp/WeKTq2R00T4wCSfZ9x22EYBnqL01SMqun0Eg00XHLtnkw+EcZIw\n3Evt/3qkfClIjJG6lp1cB5zDK0MNMPylWpisZZcjEjiAiKOcIB7Tjt0weLdQ3nUU\nieyJBiq//yP/CW4meXZ7D/rSnH0widD3qvrghI1CIGQ2JRpF8Qy06uMI0VPpQLb/\nIypwUEAXY1bNha8QP9deMpbAsi4pO2DJEgZ5+wZFLt30G+tXr4DOzvV5XZcR+abL\ncuFVSQKCAQAE14SH/k0m++zzJixwzbdaqlaA9v7wsV3qJb2dkSnX1Kp6xsrudJOm\nE8PQiDsYefq3nbg5IywODuIx+bj/7S3Du+kzGXPwUgZAbyJzmJPRHxDqfwwb4HxM\nRZ8Haid/91t5S+SFu4Eemop9GBCxbe1qiTh8IAzuvyoLs9rgT9EBUgvbBpMWcPww\nQzDb15ygoYU8UgUgJrWuIy9P8ZbzpyHfiTJT0SkiSpazRAYU2BG5mYOXTuMXJg6M\nn57aRoT0uuHXTbBkXzJnZZ13lQ/irJFEo31HhRyvfW01YVUs29ktFon2IrvzmuM5\nZBBZh4WIFS5l+hTtMq7Zk4J9vjwWxjnBAoIBAQCw9201wNS2dFYy54WCERT461eA\n+WIIqPjFD7AdOIH6k0BfBNMB2JaOjer8j8C6IwfIPq3SRB/LmpoVpE8bsb8T3wdx\nwPZu6fD4iFLB1wFy7IX8P0kQGWFzn/RSncr874SwZrS/SKxA44KhfJj6yU7qTSsO\nd4H/emTf84drILclX7IPlGgufKjig/C0sn0xcxghrFU64W9vCoNksWSeoQjXMdy9\n/duDQ5JtkhOaIABC9dStV1GlcwPGhXP417sYKmrPOF2DuCPyUbtrxtCeiui7vBAJ\nko/Y2e8MTPM3iWn+SPWqYb0MUnGdFGv1m86ig9JgWZVHuWS3rnjzqp4vpfZv\n-----END RSA PRIVATE KEY-----\n`;\n\nconst client = new MainClient({\n  api_key: api_key,\n  api_secret: rsaPrivateKey,\n  beautifyResponses: true,\n});\n\n(async () => {\n  try {\n    console.log('private api call result: ', await client.getBalances());\n  } catch (e) {\n    console.error('request failed: ', e);\n  }\n})();\n",
              "metadata": {}
            }
          ]
        },
        {
          "type": "folder",
          "name": "Rest",
          "path": "examples/Binance/Rest",
          "children": [
            {
              "type": "folder",
              "name": "Futures",
              "path": "examples/Binance/Rest/Futures",
              "children": [
                {
                  "type": "file",
                  "name": "rest-future-bracket-order.ts",
                  "path": "examples/Binance/Rest/Futures/rest-future-bracket-order.ts",
                  "code": "import { NewFuturesOrderParams, USDMClient } from 'binance';\n\nconst key = process.env.API_KEY_COM || 'APIKEY';\nconst secret = process.env.API_SECRET_COM || 'APISECRET';\n\nconst client = new USDMClient({\n  api_key: key,\n  api_secret: secret,\n  beautifyResponses: true,\n});\n\n(async () => {\n  try {\n    // TODO: check balance and do other validations\n\n    const assetPrices = await client.getMarkPrice({\n      symbol: 'ETHUSDT',\n    });\n    const markPrice: number = Number(assetPrices.markPrice);\n    const stopLossPrice = Number((markPrice * 99.9) / 100).toFixed(2);\n    const takeProfitPrice = Number((markPrice * 100.1) / 100).toFixed(2);\n\n    // create three orders\n    // 1. entry order (GTC),\n    // 2. take profit order (GTE_GTC),\n    // 3. stop loss order (GTE_GTC)\n\n    const entryOrder: NewFuturesOrderParams<string> = {\n      positionSide: 'BOTH',\n      quantity: '0.01',\n      reduceOnly: 'false',\n      side: 'BUY',\n      symbol: 'ETHUSDT',\n      type: 'MARKET',\n    };\n\n    const takeProfitOrder: NewFuturesOrderParams<string> = {\n      positionSide: 'BOTH',\n      priceProtect: 'TRUE',\n      quantity: '0.01',\n      side: 'SELL',\n      stopPrice: takeProfitPrice,\n      symbol: 'ETHUSDT',\n      timeInForce: 'GTE_GTC',\n      type: 'TAKE_PROFIT_MARKET',\n      workingType: 'MARK_PRICE',\n      closePosition: 'true',\n    };\n\n    const stopLossOrder: NewFuturesOrderParams<string> = {\n      positionSide: 'BOTH',\n      priceProtect: 'TRUE',\n      quantity: '0.01',\n      side: 'SELL',\n      stopPrice: stopLossPrice,\n      symbol: 'ETHUSDT',\n      timeInForce: 'GTE_GTC',\n      type: 'STOP_MARKET',\n      workingType: 'MARK_PRICE',\n      closePosition: 'true',\n    };\n\n    const openedOrder = await client\n      .submitMultipleOrders([entryOrder, takeProfitOrder, stopLossOrder])\n      .catch((e) => console.log(e?.body || e));\n    console.log(openedOrder);\n  } catch (e) {\n    console.log(e);\n  }\n})();\n",
                  "metadata": {}
                },
                {
                  "type": "file",
                  "name": "rest-usdm-demo.ts",
                  "path": "examples/Binance/Rest/Futures/rest-usdm-demo.ts",
                  "code": "import { USDMClient } from 'binance';\n\nconst key = process.env.API_KEY_COM || 'APIKEY';\nconst secret = process.env.API_SECRET_COM || 'APISECRET';\n\nconst client = new USDMClient({\n  api_secret: secret,\n  api_key: key,\n  beautifyResponses: true,\n  /**\n   * Demo trading uses real market data with simulated trading.\n   * Perfect for testing strategies without risk.\n   */\n  demoTrading: true,\n});\n\nasync function start() {\n  try {\n    // Get account information on demo trading\n    const accountInfo = await client.getAccountInformation();\n    console.log('Demo account info: ', accountInfo);\n\n    // Place a test order on demo trading\n    const result = await client.submitNewOrder({\n      side: 'SELL',\n      symbol: 'BTCUSDT',\n      type: 'MARKET',\n      quantity: 0.001,\n    });\n\n    console.log('Demo market sell result: ', result);\n  } catch (e) {\n    console.error('Demo trading request failed: ', e);\n  }\n}\n\nstart();\n",
                  "metadata": {}
                },
                {
                  "type": "file",
                  "name": "rest-usdm-order-sl.ts",
                  "path": "examples/Binance/Rest/Futures/rest-usdm-order-sl.ts",
                  "code": "/* eslint-disable @typescript-eslint/no-unused-vars */\nimport { USDMClient } from 'binance';\n\nconst key = process.env.API_KEY_COM || 'APIKEY';\nconst secret = process.env.API_SECRET_COM || 'APISECRET';\n\nconst client = new USDMClient({\n  api_secret: secret,\n  api_key: key,\n  beautifyResponses: true,\n});\n\nconst symbol = 'BTCUSDT';\n\nasync function start() {\n  try {\n    // ### This is for Hedge Mode Only ###\n    // assuming you currently have a open position, and you want to modify the SL order.\n\n    /**\n     * first we get all long and short positions status\n     * the result of this method in hedge mode is array of two objects\n     * first index for LONG and second index for SHORT\n     */\n    const [\n      { positionAmt: longAmount, ...long },\n      { positionAmt: shortAmount, ...short },\n    ]: any = await client.getPositionsV3({ symbol });\n\n    // if longAmount is bigger than 0 means we have open long position and if shortAmount is below 0 means we have open short position\n    const hasLong = parseFloat(longAmount) > 0;\n    const hasShort = parseFloat(shortAmount) < 0;\n    const hasOpen = hasLong || hasShort;\n\n    // if we have any open position then we continue\n    if (hasOpen) {\n      // we get ourstop loss here\n      const orders = await client.getAllOpenOrders({ symbol });\n      const stopOrders =\n        orders.filter(({ type }) => type === 'STOP_MARKET') ?? [];\n\n      // we want to modify our long position SL here\n      if (hasLong) {\n        // we get the StopLoss order which is realted to long\n        const { orderId }: any = stopOrders.find(\n          ({ positionSide: ps }) => ps == 'LONG',\n        );\n\n        // if it exists, cancel it.\n        if (orderId) {\n          await client.cancelOrder({ symbol, orderId });\n        }\n\n        const { markPrice }: any = long;\n\n        // creating SL order\n        const result = await client.submitNewOrder({\n          symbol,\n          side: 'SELL', // the action of order, means this order will sell which is sl for long position\n          positionSide: 'LONG', // based on the headge mode we either LONG or SHORT, here we are doing it for our long pos\n          timeInForce: 'GTC',\n          type: 'STOP_MARKET',\n          closePosition: 'true', // this is here because we don't have the position quantity value, and it means closee all quantity\n          stopPrice: parseFloat((markPrice * 0.99).toFixed(3)), // set sl price 1% below current price\n          workingType: 'MARK_PRICE',\n        });\n        console.log('SL Modifiled sell result: ', result);\n      }\n    } else {\n      console.log('No Open position found');\n    }\n  } catch (e) {\n    console.error('market sell failed: ', e);\n  }\n}\n\nstart();\n",
                  "metadata": {}
                },
                {
                  "type": "file",
                  "name": "rest-usdm-order.ts",
                  "path": "examples/Binance/Rest/Futures/rest-usdm-order.ts",
                  "code": "import { USDMClient } from 'binance';\n\nconst key = process.env.API_KEY_COM || 'APIKEY';\nconst secret = process.env.API_SECRET_COM || 'APISECRET';\n\nconst client = new USDMClient({\n  api_secret: secret,\n  api_key: key,\n  beautifyResponses: true,\n});\n\nasync function start() {\n  try {\n    // To open a short position - if you don't have a position yet, and your account is set to one-way mode, just place a sell order to open a short position\n    const result = await client.submitNewOrder({\n      side: 'SELL',\n      symbol: 'BTCUSDT',\n      type: 'MARKET',\n      quantity: 0.001,\n      // newOrderRespType: 'FULL',\n    });\n\n    console.log('market sell result: ', result);\n  } catch (e) {\n    console.error('market sell failed: ', e);\n  }\n}\n\nstart();\n",
                  "metadata": {}
                },
                {
                  "type": "file",
                  "name": "rest-usdm-private-get.ts",
                  "path": "examples/Binance/Rest/Futures/rest-usdm-private-get.ts",
                  "code": "import { USDMClient } from 'binance';\n// import axios from 'axios';\n\nconst key = process.env.API_KEY_COM || 'APIKEY';\nconst secret = process.env.API_SECRET_COM || 'APISECRET';\n\nconst client = new USDMClient({\n  api_key: key,\n  api_secret: secret,\n  beautifyResponses: true,\n  disableTimeSync: true,\n});\n\n(async () => {\n  try {\n    const allNotionalBrackets = await client.getNotionalAndLeverageBrackets();\n    console.log('allNotionalBrackets: ', allNotionalBrackets);\n\n    const btcNotionalBrackets = await client.getNotionalAndLeverageBrackets({\n      symbol: 'BTCUSDT',\n    });\n    console.log(\n      'btcNotionalBrackets: ',\n      JSON.stringify(btcNotionalBrackets, null, 2),\n    );\n  } catch (e) {\n    console.error('request failed: ', e);\n  }\n})();\n",
                  "metadata": {}
                },
                {
                  "type": "file",
                  "name": "rest-usdm-public.ts",
                  "path": "examples/Binance/Rest/Futures/rest-usdm-public.ts",
                  "code": "import { USDMClient } from 'binance';\n\nconst client = new USDMClient({\n  testnet: true,\n  // keepAlive: true,\n  // ... any other params,\n});\n\nclient\n  .getRecentTrades({\n    symbol: 'BTCUSDT',\n    limit: 2,\n  })\n  .then((r) => console.log('results: ', r))\n  .catch((e) => console.error('exception: ', e));\n",
                  "metadata": {}
                },
                {
                  "type": "file",
                  "name": "rest-usdm-testnet.ts",
                  "path": "examples/Binance/Rest/Futures/rest-usdm-testnet.ts",
                  "code": "import { USDMClient } from 'binance';\n\nconst key = process.env.API_KEY_COM || 'APIKEY';\nconst secret = process.env.API_SECRET_COM || 'APISECRET';\n\nconst client = new USDMClient({\n  api_secret: secret,\n  api_key: key,\n  beautifyResponses: true,\n  /**\n   * Note: testnet is NOT a good place to test strategy performance.\n   *\n   * For more information and guidance, refer to:\n   * https://github.com/tiagosiebler/awesome-crypto-examples/wiki/CEX-Testnets\n   */\n  testnet: true,\n});\n\nasync function start() {\n  try {\n    // To open a short position - if you don't have a position yet, and your account is set to one-way mode, just place a sell order to open a short position\n    const result = await client.submitNewOrder({\n      side: 'SELL',\n      symbol: 'BTCUSDT',\n      type: 'MARKET',\n      quantity: 0.001,\n      // newOrderRespType: 'FULL',\n    });\n\n    console.log('market sell result: ', result);\n  } catch (e) {\n    console.error('market sell failed: ', e);\n  }\n}\n\nstart();\n",
                  "metadata": {}
                }
              ]
            },
            {
              "type": "folder",
              "name": "misc",
              "path": "examples/Binance/Rest/misc",
              "children": [
                {
                  "type": "file",
                  "name": "tracking-candles.ts",
                  "path": "examples/Binance/Rest/misc/tracking-candles.ts",
                  "code": "import {\n  DefaultLogger,\n  isWsFormattedKline,\n  KlineInterval,\n  USDMClient,\n  WebsocketClient,\n} from 'binance';\nimport { EventEmitter } from 'events';\n\n/**\n * This elaborate example serves the following key functions:\n * - Connect to various candle websockets to receive realtime candle events (update open candle & append closed candle)\n * - Backfill some candles using the REST API\n * - Once backfilled, start processing candle events (update & append in-memory, depending if candle closed or not)\n * - Keep the candle stores trimmed, so we never store more than `maxStoredCandles` candles per symbol\n * - When a connection opens or reconnects, the backfill is executed again to ensure there are no gaps\n *\n * The \"onCandleClosed()\" function is where you would run custom logic with a dataset of candles (e.g. run some indicator calculations)\n */\n\nconst restClient = new USDMClient();\n\nconst ignoredTraceLogMsgs = [\n  'Sending ping',\n  'Received pong frame, clearing pong timer',\n  'Received ping frame, sending pong frame',\n];\nconst customLogger = {\n  ...DefaultLogger,\n  trace: (msg: string, context?: any) => {\n    if (ignoredTraceLogMsgs.includes(msg)) {\n      return;\n    }\n    console.log(JSON.stringify({ msg, context }));\n  },\n};\nconst wsClient = new WebsocketClient(\n  {\n    beautify: true,\n  },\n  customLogger,\n);\n\n/**\n * Configuration logic\n */\n\nconst symbolsToMonitor: string[] = ['BTCUSDT', 'ETHUSDT'];\nconst timeframes: KlineInterval[] = ['1m'];\nconst maxStoredCandles = 3;\n\n/**\n * Data stores\n */\n\ninterface EngineCandle {\n  open: number;\n  close: number;\n  high: number;\n  low: number;\n  volume: number;\n  openTime: number;\n  openDt: Date;\n  closeTime: number;\n  closeDt: Date;\n}\n\n/**\n * The shape of the events produced by the candle store.\n * All the info needed to query the candle store for all candles, after receiving a candle closed event\n */\ninterface CandleStoreEvent {\n  symbol: string;\n  interval: string;\n}\n\n/** These are the events produced by the candle store, which can be used to implement this abstraction layer */\nexport declare interface CandleEmitter extends EventEmitter {\n  on(event: 'candleClose', listener: (event: CandleStoreEvent) => void): this;\n  on(event: 'candleUpdate', listener: (event: CandleStoreEvent) => void): this;\n}\n\n/** Some options to configure the behaviour of the candle store */\ninterface CandleStoreOptions {\n  /** Keep a ceiling on how many candles are stored, before old ones are discarded (prevent the store from growing forever into infinity) */\n  maxStoredCandles?: number;\n  eventEmitter: EventEmitter;\n}\n\n/**\n\n/**\n * A general store for symbol/interval candles, including handling the currently open candle, with some utility methods\n */\nexport class CandleStore {\n  private symbol: string;\n\n  // Closed candles are stored as an array of candles per interval in this store.\n  // This is essentially an object acting as a key/value store (key: interval, value: candle array)\n  private closedCandles: Record<string, EngineCandle[]> = {};\n\n  // Open candles are kept separate from the closed candles, also in a key/value store (key: interval, value: current open candle)\n  private openCandles: Record<string, EngineCandle | null> = {};\n\n  private maxStoredCandles: number;\n\n  private emitter: EventEmitter;\n\n  constructor(symbol: string, options: CandleStoreOptions) {\n    // super();\n    this.symbol = symbol;\n\n    this.maxStoredCandles = options?.maxStoredCandles || 3;\n    this.emitter = options.eventEmitter;\n  }\n\n  /**\n   * Overwrite the current candle store, e.g. after backfilling. Candles are sorted automatically before overwriting the store\n   */\n  public setCandles(candles: EngineCandle[], interval: string): void {\n    const ascendingCandles = [...candles].sort(\n      (a, b) => a.closeTime - b.closeTime,\n    );\n\n    this.initCandleStores(interval);\n    this.closedCandles[interval] = ascendingCandles;\n  }\n\n  public setOpenCandle(candle: EngineCandle | null, interval: string): void {\n    this.openCandles[interval] = candle;\n  }\n\n  /**\n   * Provide a candle event to the store for processing (e.g candle closed vs open candle updated).\n   * - Closed candles are appended to the array.\n   * - Open candles are tracked separately and only (optionally) used during the getCandles(true) query.\n   */\n  public processCandleEvent(\n    candle: EngineCandle,\n    interval: string,\n    isCandleClosed: boolean,\n  ): void {\n    const evt = { symbol: this.symbol, interval };\n\n    this.initCandleStores(interval);\n\n    if (!isCandleClosed) {\n      this.setOpenCandle(candle, interval);\n      this.emitter.emit('candleUpdate', evt);\n      // console.log(this.symbol, `Open candle update`);\n      return;\n    }\n\n    this.setOpenCandle(null, interval);\n    this.closedCandles[interval].push(candle);\n\n    this.trimExcessCandles(interval);\n\n    this.emitter.emit('candleClose', evt);\n    // console.log(`Emit candle closed evt`, evt);\n  }\n\n  private initCandleStores(interval: string) {\n    if (\n      !this.closedCandles[interval] ||\n      !Array.isArray(this.closedCandles[interval])\n    ) {\n      this.closedCandles[interval] = [];\n    }\n  }\n\n  /**\n   * Execute a store-trim. This is called automatically during candle-closed events, but\n   * can be called manually (e.g. after backfilling) to ensure the store only keeps the most recent `maxStoredCandles`.\n   */\n  public trimExcessCandles(interval: string): void {\n    const maxStored = this.maxStoredCandles;\n\n    this.initCandleStores(interval);\n\n    const totalCandles = this.closedCandles[interval]?.length;\n    if (totalCandles <= maxStored) {\n      return;\n    }\n\n    const elementsToRemove = totalCandles - maxStored;\n\n    // This mutates the closed candle store to remove the first x elements\n    this.closedCandles[interval].splice(0, elementsToRemove);\n  }\n\n  /**\n   * Query all candles in the store for an interval.\n   * Optionally append the currently open candle to the end of the array.\n   */\n  public getCandles(\n    interval: string,\n    includeOpenCandle?: boolean,\n  ): EngineCandle[] {\n    const candles = this.closedCandles[interval];\n    const openCandle = this.openCandles[interval];\n\n    this.initCandleStores(interval);\n\n    if (!candles) {\n      return [];\n    }\n\n    // check last candle has same open time as open candle, just in case\n    if (\n      !includeOpenCandle ||\n      !openCandle ||\n      openCandle.openTime === candles[candles.length - 1].openTime\n    ) {\n      return candles;\n    }\n\n    // Include open candle at end of array\n    return [...candles, openCandle];\n  }\n}\n\n/**\n * A key value store for all symbols & intervals\n *\n * // All CandleStores for that symbol (one per symbol, supports many intervals in one store)\n * const symbolCandles = allCandleStores[symbol];\n *\n */\nconst allCandleStores: Record<string, CandleStore> = {};\n\n/**\n * Get a candle store for a symbol.\n * Since a missing candle store is automatically initialised, you can assume this will always return a candle store.\n */\nfunction getCandleStore(symbol: string): CandleStore {\n  initCandleStoreIfMissing(symbol);\n  return allCandleStores[symbol];\n}\n\nconst eventEmitter = new EventEmitter();\n\n// Hook up event consumers on the shared event emitter\neventEmitter.on('candleClose', (e) => onCandleClosed(e.symbol, e.interval));\n// eventEmitter.on('candleUpdate', (e) => {\n//   console.log('candle updated', {\n//     dt: new Date(),\n//     symbol: e.symbol,\n//     interval: e.interval,\n//   });\n// });\n\n/** Ensure a candle store exists for this symbol & attach consumers to the store */\nfunction initCandleStoreIfMissing(symbol: string): void {\n  if (allCandleStores[symbol]) {\n    return;\n  }\n\n  // Inject your own event emitter and initialise one candle store per symbol (it supports multiple intervals)\n  allCandleStores[symbol] = new CandleStore(symbol, {\n    maxStoredCandles: maxStoredCandles,\n    eventEmitter: eventEmitter,\n  });\n}\n\n/**\n * Websocket Listeners\n */\n\nwsClient.on('formattedMessage', (data) => {\n  if (isWsFormattedKline(data)) {\n    const candle = data.kline;\n    const isCandleClosed = data.kline.final;\n    // console.log('kline received ', { candle, isCandleClosed });\n\n    const { open, close, high, low, volume, interval, symbol } = candle;\n\n    const engineCandle: EngineCandle = {\n      open,\n      close,\n      high,\n      low,\n      volume,\n      openTime: candle.startTime,\n      openDt: new Date(candle.startTime),\n      closeTime: candle.endTime,\n      closeDt: new Date(candle.endTime),\n    };\n\n    initCandleStoreIfMissing(symbol);\n\n    // const candleStore: CandleStore = allIntervalCandleStores[symbol][interval];\n    const candleStore: CandleStore = allCandleStores[symbol];\n    candleStore.processCandleEvent(engineCandle, interval, isCandleClosed);\n\n    return;\n  }\n  console.log('log formattedMessage: ', data);\n});\n\nwsClient.on(\n  'open',\n  async (data: { wsKey: string; wsUrl: string; ws: any; event: any }) => {\n    console.log('connection opened open:', data.wsKey, data.wsUrl);\n  },\n);\n\n// response to command sent via WS stream (e.g. subscription confirmation)\n// this will automatically trigger a backfill for that symbol.\nwsClient.on('response', (data) => {\n  console.log('log response: ', JSON.stringify(data, null, 2));\n\n  // empty response result === success\n  if (!data.result && data.request.method === 'SUBSCRIBE') {\n    data.request.params.forEach(async (topic: string) => {\n      console.log('Successfully subscribed to topic: ', topic);\n\n      // btcusdt@kline_1m -> btcusdt, kline_1m\n      const [symbol, topicWithInterval] = topic.split('@');\n\n      // kline_1m -> kline, 1m\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      const [topicName, interval] = topicWithInterval.split('_');\n\n      await backfillCandles(symbol.toUpperCase(), interval as KlineInterval);\n    });\n  }\n});\nwsClient.on('reconnecting', (data) => {\n  console.log('ws automatically reconnecting.... ', data?.wsKey);\n});\nwsClient.on('reconnected', async (data) => {\n  console.log('ws has reconnected ', data?.wsKey, data?.wsUrl);\n});\n\n/**\n * Execute a 1-page backfill (1000 candles). Called automatically when a connection opens OR reconnects.\n */\nasync function backfillCandles(\n  symbol: string,\n  interval: KlineInterval,\n): Promise<void> {\n  initCandleStoreIfMissing(symbol);\n\n  console.log(`Executing backfill for ${symbol} : ${interval}`);\n\n  const initialCandleResult = await restClient.getKlines({\n    symbol,\n    interval,\n    limit: 1000,\n  });\n\n  // Map to a standard candle structure\n  const mappedEngineCandles: EngineCandle[] = initialCandleResult.map(\n    (candle) => {\n      return {\n        open: Number(candle[1]),\n        high: Number(candle[2]),\n        low: Number(candle[3]),\n        close: Number(candle[4]),\n        volume: Number(candle[5]),\n        openTime: candle[0],\n        openDt: new Date(candle[0]),\n        closeTime: candle[6],\n        closeDt: new Date(candle[6]),\n      };\n    },\n  );\n\n  // Last candle might not be closed, so filter that out (ignore any candles with close time in the future)\n  const closedCandles = mappedEngineCandles.filter(\n    (c) => c.closeTime <= Date.now(),\n  );\n\n  // const candleStore: CandleStore = allIntervalCandleStores[symbol][interval];\n  const candleStore: CandleStore = allCandleStores[symbol];\n\n  // Overwrite the current candles in the store and remove excess candles\n  candleStore.setCandles(closedCandles, interval);\n  candleStore.trimExcessCandles(interval);\n\n  console.log(`Finished backfill for ${symbol} : ${interval}`);\n}\n\n/**\n * Bootstrap a connection per symbol & timeframe. Backfill will automatically trigger when the connection opens successfully.\n * Note: this will spawn one websocket connection per symbol per timeframe. For complex cases, this may create too many connections.\n */\nsymbolsToMonitor.forEach((symbol) => {\n  initCandleStoreIfMissing(symbol);\n\n  timeframes.forEach(async (interval) => {\n    // Open a websocket to start consuming candle events\n    await wsClient.subscribeKlines(symbol, interval, 'usdm');\n\n    console.log(`Requested subscription to ${symbol} & ${interval}`);\n  });\n});\n\nfunction onCandleClosed(symbol: string, interval: string): void {\n  // When a candle closes, fetch all closed candles from the store for that symbol, e.g. to calculate some indicators\n  const closedSymbolCandles = getCandleStore(symbol).getCandles(interval);\n  console.log('candle closed', {\n    dt: new Date(),\n    symbol,\n    interval,\n    mostRecentCandlesInStore: JSON.stringify(closedSymbolCandles),\n  });\n}\n",
                  "metadata": {}
                }
              ]
            },
            {
              "type": "folder",
              "name": "Portfolio Margin",
              "path": "examples/Binance/Rest/Portfolio Margin",
              "children": [
                {
                  "type": "file",
                  "name": "rest-portfoliomargin-private.ts",
                  "path": "examples/Binance/Rest/Portfolio Margin/rest-portfoliomargin-private.ts",
                  "code": "import { PortfolioClient } from 'binance';\n\nconst key = process.env.API_KEY_COM || 'APIKEY';\nconst secret = process.env.API_SECRET_COM || 'APISECRET';\n\nconst client = new PortfolioClient({\n  api_key: key,\n  api_secret: secret,\n  beautifyResponses: true,\n});\n\n(async () => {\n  try {\n    const res = await client.getBalance();\n    console.log('res', res);\n\n    const listenKey = await client.getPMUserDataListenKey();\n    console.log('listen key res: ', listenKey);\n\n    // const newOrderRes = await client.submitNewUMOrder({\n    //   symbol: 'BTCUSDT',\n    //   side: 'BUY',\n    //   type: 'MARKET',\n    //   quantity: '10',\n    // });\n\n    // console.log('new order res: ', newOrderRes);\n  } catch (e) {\n    console.error('request failed: ', e);\n  }\n})();\n",
                  "metadata": {}
                },
                {
                  "type": "file",
                  "name": "rest-portfoliomargin-public.ts",
                  "path": "examples/Binance/Rest/Portfolio Margin/rest-portfoliomargin-public.ts",
                  "code": "import { PortfolioClient } from 'binance';\n\nconst client = new PortfolioClient({\n  beautifyResponses: true,\n});\n\n(async () => {\n  try {\n    // const serverTime = await client.getServerTime();\n    // console.log('serverTime: ', serverTime);\n\n    const res = await client.testConnectivity();\n    console.log('res', res);\n  } catch (e) {\n    console.error('request failed: ', e);\n  }\n})();\n",
                  "metadata": {}
                }
              ]
            },
            {
              "type": "folder",
              "name": "Spot",
              "path": "examples/Binance/Rest/Spot",
              "children": [
                {
                  "type": "file",
                  "name": "rest-spot-demo.ts",
                  "path": "examples/Binance/Rest/Spot/rest-spot-demo.ts",
                  "code": "import { MainClient } from 'binance';\n\nconst key = process.env.API_KEY_COM || 'APIKEY';\nconst secret = process.env.API_SECRET_COM || 'APISECRET';\n\nconst client = new MainClient({\n  api_secret: secret,\n  api_key: key,\n  beautifyResponses: true,\n  /**\n   * Demo trading uses real market data with simulated trading.\n   * Perfect for testing strategies without risk.\n   */\n  demoTrading: true,\n});\n\nasync function start() {\n  try {\n    // Get account information on demo trading\n    const accountInfo = await client.getAccountInformation();\n    console.log('Demo account info: ', accountInfo);\n\n    // Place a test order on demo trading\n    const result = await client.submitNewOrder({\n      side: 'BUY',\n      symbol: 'BTCUSDT',\n      type: 'MARKET',\n      quantity: 0.001,\n    });\n\n    console.log('Demo market buy result: ', result);\n  } catch (e) {\n    console.error('Demo trading request failed: ', e);\n  }\n}\n\nstart();\n",
                  "metadata": {}
                },
                {
                  "type": "file",
                  "name": "rest-spot-exchange-info.ts",
                  "path": "examples/Binance/Rest/Spot/rest-spot-exchange-info.ts",
                  "code": "import {\n  ExchangeInfo,\n  MainClient,\n  numberInString,\n  roundToStepSize,\n  roundToTickSize,\n} from 'binance';\n\nconst client = new MainClient({\n  // Optional (default: false) - when true, response strings are parsed to floats (only for known keys).\n  // beautifyResponses: true,\n});\n\ninterface SymbolInfo {\n  tickSize?: numberInString;\n  qtyStepSize?: numberInString;\n  minOrderQty?: numberInString;\n  maxOrderQty?: numberInString;\n  maxMarketQty?: numberInString;\n  maxNumOfOrders?: number;\n  minNotional?: numberInString;\n  maxNotional?: numberInString;\n  maxBasePrecisionDecimals: number;\n  maxQuotePrecisionDecimals: number;\n}\n\n// Get full exchange info so we can cache it and use it for other functions without making request every time\nasync function fetchExchangeInfo() {\n  try {\n    const exchangeInfo = await client.getExchangeInfo();\n    return exchangeInfo;\n  } catch (error) {\n    throw new Error(\n      `Failed to get exchange info: ${error instanceof Error ? error.message : String(error)}`,\n    );\n  }\n}\n\nconst symbol = 'SOLUSDT';\n\nasync function getSymbolInfo(\n  exchangeInfo: ExchangeInfo,\n  symbol: string,\n): Promise<SymbolInfo> {\n  try {\n    // Find the symbol information once\n    const symbolInfo = exchangeInfo.symbols.find((s) => s.symbol === symbol);\n    // console.log(symbolInfo);\n\n    if (!symbolInfo) {\n      throw new Error(`Symbol ${symbol} not found in exchange info`);\n    }\n\n    // Extract filters from the symbol info\n    const priceFilter = symbolInfo.filters.find(\n      (f) => f.filterType === 'PRICE_FILTER',\n    );\n    const lotSizeFilter = symbolInfo.filters.find(\n      (f) => f.filterType === 'LOT_SIZE',\n    );\n    const marketLotSizeFilter = symbolInfo.filters.find(\n      (f) => f.filterType === 'MARKET_LOT_SIZE',\n    );\n    const maxNumOrdersFilter = symbolInfo.filters.find(\n      (f) => f.filterType === 'MAX_NUM_ORDERS',\n    );\n    const notionalFilter = symbolInfo.filters.find(\n      (f) => f.filterType === 'NOTIONAL',\n    );\n\n    const symbolFilters = {\n      tickSize: priceFilter?.tickSize,\n      qtyStepSize: lotSizeFilter?.stepSize,\n      minOrderQty: lotSizeFilter?.minQty,\n      maxOrderQty: lotSizeFilter?.maxQty,\n      maxMarketQty: marketLotSizeFilter?.maxQty,\n      maxNumOfOrders: maxNumOrdersFilter?.maxNumOrders,\n      minNotional: notionalFilter?.minNotional,\n      maxNotional: notionalFilter?.maxNotional,\n      maxBasePrecisionDecimals: symbolInfo.baseAssetPrecision,\n      maxQuotePrecisionDecimals: symbolInfo.quoteAssetPrecision,\n    };\n    console.log(symbolFilters);\n\n    return symbolFilters;\n  } catch (error) {\n    throw new Error(\n      `Failed to get symbol info: ${error instanceof Error ? error.message : String(error)}`,\n    );\n  }\n}\n\n/**\n * Validates and formats an order based on symbol constraints\n */\nfunction formatOrderParams(\n  symbol: string,\n  price: number,\n  quantity: number,\n  symbolInfo: any,\n): { symbol: string; price: number; quantity: number } {\n  try {\n    // Check if price is within allowed range\n    const minPrice = parseFloat(symbolInfo.tickSize || '0');\n    if (price < minPrice) {\n      throw new Error(`Price ${price} is below minimum ${minPrice}`);\n    }\n\n    // Check if quantity is within allowed range\n    const minQty = parseFloat(symbolInfo.minOrderQty || '0');\n    const maxQty = parseFloat(symbolInfo.maxOrderQty || Infinity);\n\n    if (quantity < minQty) {\n      throw new Error(`Quantity ${quantity} is below minimum ${minQty}`);\n    }\n\n    if (quantity > maxQty) {\n      throw new Error(`Quantity ${quantity} exceeds maximum ${maxQty}`);\n    }\n\n    // Check notional value (price * quantity)\n    const notional = price * quantity;\n    const minNotional = parseFloat(symbolInfo.minNotional || '0');\n\n    if (notional < minNotional) {\n      throw new Error(\n        `Order value ${notional} is below minimum ${minNotional}`,\n      );\n    }\n\n    // Format price and quantity according to exchange requirements\n    if (!symbolInfo.tickSize || !symbolInfo.qtyStepSize) {\n      throw new Error('Missing required symbol info: tickSize or qtyStepSize');\n    }\n    const formattedPrice = roundToTickSize(price, symbolInfo.tickSize);\n    const formattedQty = roundToStepSize(quantity, symbolInfo.qtyStepSize);\n\n    return {\n      symbol,\n      price: formattedPrice,\n      quantity: formattedQty,\n    };\n  } catch (error) {\n    throw new Error(\n      `Failed to format order: ${error instanceof Error ? error.message : String(error)}`,\n    );\n  }\n}\n\n// Example usage\nasync function testSymbolUtils() {\n  const exchangeInfo = await fetchExchangeInfo();\n  if (!exchangeInfo) return;\n\n  const symbolFilters = await getSymbolInfo(exchangeInfo, symbol);\n  if (!symbolFilters) return;\n\n  // Test price formatting\n  if (!symbolFilters.tickSize) {\n    console.log('tickSize not available for this symbol');\n    return;\n  }\n  const testPrice = 23.45678;\n  console.log(\n    `Original price: ${testPrice}`,\n    `Formatted price: ${roundToTickSize(testPrice, symbolFilters.tickSize.toString())}`,\n  );\n\n  // Test quantity formatting\n  if (!symbolFilters.qtyStepSize) {\n    console.log('qtyStepSize not available for this symbol');\n    return;\n  }\n  const testQty = 1.23456;\n  console.log(\n    `Original quantity: ${testQty}`,\n    `Formatted quantity: ${roundToStepSize(\n      testQty,\n      symbolFilters.qtyStepSize.toString(),\n    )}`,\n  );\n\n  // Test full order formatting\n  const orderParams = formatOrderParams(\n    symbol,\n    testPrice,\n    testQty,\n    symbolFilters,\n  );\n  console.log('Formatted order parameters:', orderParams);\n\n  // example how to use the order params\n  const order = await client.submitNewOrder({\n    symbol: orderParams.symbol,\n    side: 'BUY',\n    type: 'LIMIT',\n    quantity: Number(orderParams.quantity),\n    price: Number(orderParams.price),\n    timeInForce: 'GTC',\n  });\n\n  console.log(order);\n}\n\ntestSymbolUtils();\n",
                  "metadata": {}
                },
                {
                  "type": "file",
                  "name": "rest-spot-private-autoinvest.ts",
                  "path": "examples/Binance/Rest/Spot/rest-spot-private-autoinvest.ts",
                  "code": "import { MainClient } from 'binance';\n\nconst key = process.env.API_KEY_COM || 'APIKEY';\nconst secret = process.env.API_SECRET_COM || 'APISECRET';\n\nconst client = new MainClient({\n  api_key: key,\n  api_secret: secret,\n  beautifyResponses: true,\n});\n\n(async () => {\n  try {\n    const oneTimeTransactionResult =\n      await client.submitAutoInvestOneTimeTransaction({\n        sourceType: 'MAIN_SITE',\n        subscriptionAmount: 100,\n        sourceAsset: 'USDT',\n        details: [\n          {\n            targetAsset: 'BTC',\n            percentage: 60,\n          },\n          {\n            targetAsset: 'ETH',\n            percentage: 40,\n          },\n        ],\n      });\n\n    console.log('oneTimeTransactionResult', oneTimeTransactionResult);\n\n    const autoInvestPlanResult = await client.submitAutoInvestmentPlan({\n      UID: '54545454',\n      sourceType: 'MAIN_SITE',\n      subscriptionAmount: 100,\n      sourceAsset: 'USDT',\n      planType: 'SINGLE',\n      flexibleAllowedToUse: true,\n      subscriptionCycle: 'DAILY',\n      subscriptionStartTime: 5,\n      details: [\n        {\n          targetAsset: 'BTC',\n          percentage: 100,\n        },\n      ],\n    });\n\n    console.log('autoInvestPlanResult', autoInvestPlanResult);\n  } catch (e) {\n    console.error('request failed: ', e);\n  }\n})();\n",
                  "metadata": {}
                },
                {
                  "type": "file",
                  "name": "rest-spot-private-misc.ts",
                  "path": "examples/Binance/Rest/Spot/rest-spot-private-misc.ts",
                  "code": "import { MainClient } from 'binance';\n\nconst key = 'APIKEY';\nconst secret = 'APISECRET';\n\nconst client = new MainClient({\n  api_key: key,\n  api_secret: secret,\n});\n\n(async () => {\n  try {\n    console.log('getAccountStatus: ', await client.getAccountStatus());\n    console.log('getApiTradingStatus: ', await client.getApiTradingStatus());\n    console.log('getApiKeyPermissions: ', await client.getApiKeyPermissions());\n  } catch (e) {\n    console.error('request failed: ', e);\n  }\n})();\n",
                  "metadata": {}
                },
                {
                  "type": "file",
                  "name": "rest-spot-private-trade.ts",
                  "path": "examples/Binance/Rest/Spot/rest-spot-private-trade.ts",
                  "code": "import {\n  MainClient,\n  NewSpotOrderParams,\n  OrderResponseFull,\n  SymbolPrice,\n} from 'binance';\n\nconst key = process.env.API_KEY_COM || 'APIKEY';\nconst secret = process.env.API_SECRET_COM || 'APISECRET';\n\nconst client = new MainClient({\n  api_key: key,\n  api_secret: secret,\n  beautifyResponses: true,\n});\n\nconst entryAmountPercent = 50; // trigger trade with 50%\nconst symbol = 'BTCUSDT';\nconst assetDecimalPlaces = 4; // get this from exchange info, it varies per asset\n\n// method to trim down to decimal.\nfunction trimToDecimalPlaces(number: number, precision: number): number {\n  const array: any[] = number.toString().split('.');\n  array.push(array.pop().substring(0, precision));\n  const trimmedstr = array.join('.');\n  return parseFloat(trimmedstr);\n}\n\n/**\n * This is a very silly demonstration on placing market orders using various parts of the module.\n * By default it will use 50% of your available USDT balance to buy BTC and sell it again.\n */\n\n(async () => {\n  try {\n    /**\n     * Get available balance\n     */\n    const balance = await client.getBalances();\n\n    const usdtBal = balance.find((assetBal) => assetBal.coin === 'USDT');\n    // console.log('USDT balance object: ', usdtBal);\n\n    const usdtAvailable = usdtBal?.free;\n\n    if (!usdtBal || !usdtAvailable) {\n      return console.error('Error: funds to trade from USDT');\n    }\n\n    const buyAmountValue = Number(usdtAvailable) * (50 / 100);\n    console.log(\n      `Executing trade with ${entryAmountPercent}% of ${usdtAvailable} USDT = ${buyAmountValue} USDT value`,\n    );\n\n    /**\n     * Get last asset price\n     */\n    const btcTicker = (await client.getSymbolPriceTicker({\n      symbol: symbol,\n    })) as SymbolPrice;\n    const lastPrice = btcTicker?.price;\n    if (!lastPrice) {\n      return console.error('Error: no price returned');\n    }\n\n    /**\n     * Calculate and submit buy amount\n     */\n    const buyAmountBtc = +(buyAmountValue / Number(lastPrice)).toFixed(\n      assetDecimalPlaces,\n    );\n    console.log(\n      `Last ${symbol} price: ${lastPrice} => will buy ${buyAmountBtc} ${symbol}`,\n    );\n\n    const buyOrderRequest: NewSpotOrderParams = {\n      symbol: symbol,\n      quantity: buyAmountBtc,\n      side: 'BUY',\n      type: 'MARKET',\n      /**\n       * ACK = confirmation of order acceptance (no placement/fill information) -> OrderResponseACK\n       * RESULT = fill state -> OrderResponseResult\n       * FULL = fill state + detail on fills and other detail -> OrderResponseFull\n       */\n      newOrderRespType: 'FULL',\n    };\n\n    console.log('Submitting buy order: ', buyOrderRequest);\n    await client.testNewOrder(buyOrderRequest);\n    const buyOrderResult = (await client.submitNewOrder(\n      buyOrderRequest,\n    )) as OrderResponseFull;\n    console.log(\n      'Order result: ',\n      JSON.stringify(\n        { request: buyOrderRequest, response: buyOrderResult },\n        null,\n        2,\n      ),\n    );\n\n    /**\n     * Process bought fills and submit sell amount\n     */\n    const assetAmountBought = buyOrderResult.executedQty;\n    const assetFillsMinusFees = buyOrderResult.fills.reduce(\n      (sum, fill) =>\n        sum +\n        Number(fill.qty) -\n        (fill.commissionAsset !== 'BNB' ? Number(fill.commission) : 0),\n      0,\n    );\n    console.log(\n      `Filled buy ${symbol} ${assetAmountBought} : bought minus fees ${assetFillsMinusFees}`,\n    );\n\n    const sellOrderRequest: NewSpotOrderParams = {\n      symbol: symbol,\n      quantity: trimToDecimalPlaces(assetFillsMinusFees, assetDecimalPlaces),\n      side: 'SELL',\n      type: 'MARKET',\n      newOrderRespType: 'FULL',\n    };\n\n    console.log('Submitting sell order: ', sellOrderRequest);\n    await client.testNewOrder(sellOrderRequest);\n    const sellOrderResult = (await client.submitNewOrder(\n      sellOrderRequest,\n    )) as OrderResponseFull;\n\n    console.log(\n      'Order result: ',\n      JSON.stringify(\n        { request: sellOrderRequest, response: sellOrderResult },\n        null,\n        2,\n      ),\n    );\n\n    console.log(`All ${symbol} should have been sold!`);\n  } catch (e) {\n    console.error('Error: request failed: ', e);\n  }\n\n  process.exit(1);\n})();\n",
                  "metadata": {}
                },
                {
                  "type": "file",
                  "name": "rest-spot-public.ts",
                  "path": "examples/Binance/Rest/Spot/rest-spot-public.ts",
                  "code": "import { MainClient } from 'binance';\n\nconst client = new MainClient({\n  // Optional (default: false) - when true, response strings are parsed to floats (only for known keys).\n  // beautifyResponses: true,\n});\n\n(async () => {\n  try {\n    // console.log(\n    //   'getAvgPrice: ',\n    //   await client.getAvgPrice({ symbol: 'BTCUSDT' }),\n    // );\n    // console.log(\n    //   'getExchangeInfo: ',\n    //   JSON.stringify(await client.getExchangeInfo(), null, 2),\n    // );\n\n    const oneTicker = await client.get24hrChangeStatistics({\n      symbol: 'BTCUSDT',\n    });\n    console.log('getTickers', oneTicker);\n\n    const manyTickers = await client.get24hrChangeStatistics({\n      symbols: ['BTCUSDT', 'ETHUSDT'],\n    });\n    console.log('getTickers many', manyTickers);\n    const allTickers = await client.get24hrChangeStatistics();\n    console.log('getTickers all', allTickers);\n  } catch (e) {\n    console.error('request failed: ', e);\n  }\n})();\n",
                  "metadata": {}
                }
              ]
            }
          ]
        },
        {
          "type": "folder",
          "name": "WebSockets",
          "path": "examples/Binance/WebSockets",
          "children": [
            {
              "type": "folder",
              "name": "Demo",
              "path": "examples/Binance/WebSockets/Demo",
              "children": [
                {
                  "type": "file",
                  "name": "ws-demo-spot.ts",
                  "path": "examples/Binance/WebSockets/Demo/ws-demo-spot.ts",
                  "code": "import { WebsocketClient } from 'binance';\n\nconst key = process.env.API_KEY_COM || 'APIKEY';\nconst secret = process.env.API_SECRET_COM || 'APISECRET';\n\nasync function start() {\n  const wsClient = new WebsocketClient({\n    api_key: key,\n    api_secret: secret,\n    beautify: true,\n    /**\n     * Demo trading uses real market data with simulated trading.\n     * Perfect for testing strategies without risk.\n     *\n     * For more information:\n     * https://www.binance.com/en/support/faq/how-to-test-my-functions-on-binance-spot-test-network-ab78f9a1b8824cf0a106b4229c76496d\n     */\n    demoTrading: true,\n  });\n\n  wsClient.on('formattedMessage', (data) => {\n    console.log('Demo WS data: ', JSON.stringify(data, null, 2));\n  });\n\n  wsClient.on('open', (data) => {\n    console.log('Demo WS connection opened:', data.wsKey);\n  });\n\n  wsClient.on('response', (data) => {\n    console.log('Demo WS response: ', JSON.stringify(data, null, 2));\n  });\n\n  wsClient.on('reconnected', (data) => {\n    console.log('Demo WS reconnected ', data?.wsKey);\n  });\n\n  wsClient.on('exception', (data) => {\n    console.error('Demo WS error', data);\n  });\n\n  // Subscribe to spot market streams on demo trading\n  wsClient.subscribeSpotTrades('BTCUSDT');\n  wsClient.subscribeSpotKline('BTCUSDT', '1m');\n}\n\nstart();\n",
                  "metadata": {}
                },
                {
                  "type": "file",
                  "name": "ws-demo-usdm.ts",
                  "path": "examples/Binance/WebSockets/Demo/ws-demo-usdm.ts",
                  "code": "import { WebsocketClient } from 'binance';\n\nconst key = process.env.API_KEY_COM || 'APIKEY';\nconst secret = process.env.API_SECRET_COM || 'APISECRET';\n\nasync function start() {\n  const wsClient = new WebsocketClient({\n    api_key: key,\n    api_secret: secret,\n    beautify: true,\n    /**\n     * Demo trading uses real market data with simulated trading.\n     * Perfect for testing strategies without risk.\n     */\n    demoTrading: true,\n  });\n\n  wsClient.on('formattedMessage', (data) => {\n    console.log('Demo WS data: ', JSON.stringify(data, null, 2));\n  });\n\n  wsClient.on('open', (data) => {\n    console.log('Demo WS connection opened:', data.wsKey);\n  });\n\n  wsClient.on('response', (data) => {\n    console.log('Demo WS response: ', JSON.stringify(data, null, 2));\n  });\n\n  wsClient.on('reconnected', (data) => {\n    console.log('Demo WS reconnected ', data?.wsKey);\n  });\n\n  wsClient.on('exception', (data) => {\n    console.error('Demo WS error', data);\n  });\n\n  // Subscribe to USDM futures market streams on demo trading\n  wsClient.subscribeKlines('BTCUSDT', '1m', 'usdm');\n  wsClient.subscribeUsdFuturesUserDataStream();\n}\n\nstart();\n",
                  "metadata": {}
                }
              ]
            },
            {
              "type": "folder",
              "name": "Misc",
              "path": "examples/Binance/WebSockets/Misc",
              "children": [
                {
                  "type": "file",
                  "name": "ws-close.ts",
                  "path": "examples/Binance/WebSockets/Misc/ws-close.ts",
                  "code": "import { DefaultLogger, WebsocketClient } from 'binance';\n\n(async () => {\n  const key = process.env.API_KEY_COM || 'APIKEY';\n  const secret = process.env.API_SECRET_COM || 'APISECRET';\n\n  const logger = {\n    ...DefaultLogger,\n    trace: () => {},\n  };\n\n  const wsClient = new WebsocketClient(\n    {\n      api_key: key,\n      api_secret: secret,\n      beautify: true,\n    },\n    logger,\n  );\n\n  wsClient.on('open', (data) => {\n    console.log('connection opened open:', data.wsKey, data.wsUrl);\n  });\n\n  wsClient.on('reconnecting', (data) => {\n    console.log('ws automatically reconnecting.... ', data?.wsKey);\n  });\n  wsClient.on('reconnected', (data) => {\n    console.log('ws has reconnected ', data?.wsKey);\n  });\n\n  wsClient.on('message', (data) => {\n    console.log('data received: ', data);\n  });\n  wsClient.on('response', (data) => {\n    console.log('response received: ', data);\n  });\n\n  wsClient.subscribeUsdFuturesUserDataStream();\n\n  wsClient.subscribe(\n    ['!miniTicker@arr', 'btcusdt@avgPrice', 'btcusdt@kline_5m'],\n    'main',\n  );\n\n  setTimeout(() => {\n    // unsubscribe from user data stream (for usd futures)\n    wsClient.unsubscribeUsdFuturesUserDataStream();\n\n    // unsubscribe from individual topics on a connection, one at a time:\n    // wsClient.unsubscribe('!miniTicker@arr', 'main');\n\n    // arrays also supported:\n    wsClient.unsubscribe(['!miniTicker@arr', 'btcusdt@avgPrice'], 'main');\n  }, 5000);\n})();\n",
                  "metadata": {}
                },
                {
                  "type": "file",
                  "name": "ws-custom-parser.ts",
                  "path": "examples/Binance/WebSockets/Misc/ws-custom-parser.ts",
                  "code": "// Optional, for 3rd scenario below:\n// Import 3rd party library for parsing big number types in JSON\n// import JSONbig from 'json-bigint';\n\nimport { WebsocketClient } from 'binance';\n\n// Demonstrates using a custom JSON parser for incoming WS messages to preserve big integers\n\n/**\n * ETHUSDT in futures can have unusually large orderId values, sent as numbers. See this thread for more details:\n * https://github.com/tiagosiebler/binance/issues/208\n *\n * If this is a problem for you, you can set a custom JSON parsing alternative using the customParseJSONFn hook injected into the WebsocketClient's constructor, as below:\n */\nconst ws = new WebsocketClient({\n  // Default behaviour, if you don't include this:\n  // customParseJSONFn: (rawEvent) => {\n  //   return JSON.parse(rawEvent);\n  // },\n  // Or, pre-process the raw event using RegEx, before using the same workflow:\n  customParseJSONFn: (rawEvent) => {\n    return JSON.parse(\n      rawEvent.replace(/\"orderId\":\\s*(\\d+)/g, '\"orderId\":\"$1\"'),\n    );\n  },\n  // Or, use a 3rd party library such as json-bigint:\n  // customParseJSONFn: (rawEvent) => {\n  //   return JSONbig({ storeAsString: true }).parse(rawEvent);\n  // },\n});\n\nws.on('open', ({ wsKey }) => {\n  console.log('ws connected', wsKey);\n});\n\nws.on('message', (msg) => {\n  console.log('msg:', msg);\n});\n\n// Subscribe to a couple of topics\n// Note: '!ticker@arr' has been deprecated (2025-11-14). Using '!miniTicker@arr' instead.\nws.subscribe(['btcusdt@trade', '!miniTicker@arr'], 'main');\n",
                  "metadata": {}
                },
                {
                  "type": "file",
                  "name": "ws-proxy-socks.ts",
                  "path": "examples/Binance/WebSockets/Misc/ws-proxy-socks.ts",
                  "code": "/**\n * Minimal example for using a socks proxy with the ws client, extracted from https://github.com/tiagosiebler/binance/pull/319\n */\nimport { WebsocketClient } from 'binance';\nimport { SocksProxyAgent } from 'socks-proxy-agent';\n// const { SocksProxyAgent } = require('socks-proxy-agent');\n\nconst agent = new SocksProxyAgent(process.env.http_proxy || '');\nconst wsClient = new WebsocketClient({\n  beautify: true,\n  wsOptions: {\n    agent: agent,\n  },\n});\n\nwsClient.on('formattedMessage', (data) => {\n  console.log('log formattedMessage: ', data);\n});\nwsClient.on('open', (data) => {\n  console.log('connection opened open:', data.wsKey, data.wsUrl);\n});\n\nwsClient.on('response', (data) => {\n  console.log('log response: ', JSON.stringify(data, null, 2));\n});\nwsClient.on('reconnecting', (data) => {\n  console.log('ws automatically reconnecting.... ', data?.wsKey);\n});\nwsClient.on('reconnected', (data) => {\n  console.log('ws has reconnected ', data?.wsKey);\n});\n\nwsClient.subscribeAll24hrTickers('usdm');\n",
                  "metadata": {}
                },
                {
                  "type": "file",
                  "name": "ws-unsubscribe.ts",
                  "path": "examples/Binance/WebSockets/Misc/ws-unsubscribe.ts",
                  "code": "/* eslint-disable @typescript-eslint/no-unused-vars */\nimport { WebsocketClient } from 'binance';\n\n/**\n *\n * A simple demonstration on how to unsubscribe from one or more topics.\n *\n */\n(async () => {\n  const wsClient = new WebsocketClient();\n\n  // Raw unprocessed incoming data, e.g. if you have the beautifier disabled\n  wsClient.on('message', (data) => {\n    console.log('raw message received ', JSON.stringify(data));\n  });\n\n  wsClient.on('open', (data) => {\n    console.log('connection opened open:', data.wsKey);\n  });\n\n  wsClient.on('response', (data) => {\n    console.log('log response: ', data?.message || JSON.stringify(data));\n  });\n\n  wsClient.on('reconnecting', (data) => {\n    console.log('ws automatically reconnecting.... ', data?.wsKey);\n  });\n\n  wsClient.on('reconnected', (data) => {\n    console.log('ws has reconnected ', data?.wsKey);\n  });\n\n  try {\n    /**\n     * The Websocket Client will automatically manage connectivity and active topics/subscriptions for you.\n     *\n     * Simply call wsClient.subscribe(topic, wsKey) as many times as you want, with or without an array.\n     */\n\n    const wsTopicList = [\n      // Aggregate Trade Streams\n      // https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#aggregate-trade-streams\n      'btcusdt@aggTrade',\n      // Kline/Candlestick Streams for UTC\n      // https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#klinecandlestick-streams-for-utc\n      'btcusdt@kline_5m',\n      // Individual Symbol Mini Ticker Stream\n      // https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#individual-symbol-mini-ticker-stream\n      'btcusdt@miniTicker',\n      // Individual Symbol Ticker Streams\n      // https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#individual-symbol-ticker-streams\n      'btcusdt@ticker',\n      // Individual Symbol Rolling Window Statistics Streams\n      // https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#individual-symbol-rolling-window-statistics-streams\n      'btcusdt@ticker_1h',\n      // Average Price\n      // https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#average-price\n      'btcusdt@avgPrice',\n    ];\n\n    console.log(\n      new Date(),\n      'Subscribing to the following topics: ',\n      wsTopicList,\n    );\n\n    /**\n     * Subscribe to each available type of spot market topic, the new way\n     */\n    await wsClient.subscribe(wsTopicList, 'main');\n\n    const unsubscribeFromList = [\n      'btcusdt@aggTrade',\n      'btcusdt@kline_5m',\n      'btcusdt@miniTicker',\n      'btcusdt@ticker',\n      'btcusdt@ticker_1h',\n    ];\n\n    // 5 seconds later, unsubscribe from almost all topics except avg price\n    setTimeout(() => {\n      console.log(\n        new Date(),\n        'Unsubscribing from the following topics: ',\n        unsubscribeFromList,\n      );\n      wsClient.unsubscribe(unsubscribeFromList, 'main');\n    }, 1000 * 5);\n  } catch (e) {\n    console.error('exception on subscribe attempt: ', e);\n  }\n})();\n",
                  "metadata": {}
                }
              ]
            },
            {
              "type": "folder",
              "name": "Private(userdata)",
              "path": "examples/Binance/WebSockets/Private(userdata)",
              "children": [
                {
                  "type": "file",
                  "name": "ws-userdata-connection-safety.ts",
                  "path": "examples/Binance/WebSockets/Private(userdata)/ws-userdata-connection-safety.ts",
                  "code": "import {\n  DefaultLogger,\n  isWsFormattedFuturesUserDataEvent,\n  isWsFormattedSpotUserDataEvent,\n  isWsFormattedSpotUserDataExecutionReport,\n  isWsFormattedUserDataEvent,\n  WebsocketClient,\n  WsUserDataEvents,\n} from 'binance';\n\n/**\n * This extended example for using the user data stream demonstrates one way to handle failures in the first connection attempt of the user data stream.\n * In most cases this is overkill!\n */\n(async () => {\n  const key = process.env.API_KEY_COM || 'APIKEY';\n  const secret = process.env.API_SECRET_COM || 'APISECRET';\n\n  // optionally block some silly logs from showing in the logger\n  const ignoredTraceLogMsgs = [\n    'Sending ping',\n    'Received pong, clearing pong timer',\n    'Received ping, sending pong frame',\n  ];\n\n  // Optional, hook and customise logging behavior\n  const logger = {\n    ...DefaultLogger,\n    trace: (msg: string, context?: any) => {\n      if (ignoredTraceLogMsgs.includes(msg)) {\n        return;\n      }\n      console.log(JSON.stringify({ msg, context }));\n    },\n  };\n\n  const wsClient = new WebsocketClient(\n    {\n      api_key: key,\n      api_secret: secret,\n      beautify: true,\n    },\n    logger,\n  );\n\n  // wsClient.on('message', (data) => {\n  //   console.log('raw message received ', JSON.stringify(data, null, 2));\n  // });\n\n  function onUserDataEvent(data: WsUserDataEvents) {\n    // the market denotes which API category it came from\n    // if (data.wsMarket.includes('spot')) {\n\n    // or use a type guard, if one exists (PRs welcome)\n    if (isWsFormattedSpotUserDataExecutionReport(data)) {\n      console.log('spot user execution report event: ', data);\n      return;\n    }\n    if (isWsFormattedSpotUserDataEvent(data)) {\n      console.log('spot user data event: ', data);\n      return;\n    }\n    if (data.wsMarket.includes('margin')) {\n      console.log('margin user data event: ', data);\n      return;\n    }\n    if (data.wsMarket.includes('isolatedMargin')) {\n      console.log('isolatedMargin user data event: ', data);\n      return;\n    }\n    if (data.wsMarket.includes('usdmTestnet')) {\n      console.log('usdmTestnet user data event: ', data);\n      return;\n    }\n    if (data.wsMarket.includes('coinmTestnet')) {\n      console.log('coinmTestnet user data event: ', data);\n      return;\n    }\n    if (isWsFormattedFuturesUserDataEvent(data)) {\n      console.log('usdm user data event: ', data);\n      return;\n    }\n  }\n\n  wsClient.on('formattedMessage', (data) => {\n    // The wsKey can be parsed to determine the type of message (what websocket it came from)\n    // if (!Array.isArray(data) && data.wsKey.includes('userData')) {\n    //   return onUserDataEvent(data);\n    // }\n\n    // or use a type guard if available\n    if (isWsFormattedUserDataEvent(data)) {\n      return onUserDataEvent(data);\n    }\n    console.log('formattedMsg: ', JSON.stringify(data, null, 2));\n  });\n\n  let didConnectUserDataSuccessfully = false;\n  wsClient.on('open', (data) => {\n    if (data.wsKey.includes('userData')) {\n      didConnectUserDataSuccessfully = true;\n    }\n    console.log('connection opened open:', data.wsKey, data.wsUrl);\n  });\n\n  // response to command sent via WS stream (e.g LIST_SUBSCRIPTIONS)\n  wsClient.on('response', (data) => {\n    console.log('log reply: ', JSON.stringify(data, null, 2));\n  });\n  wsClient.on('reconnecting', (data) => {\n    console.log('ws automatically reconnecting.... ', data?.wsKey);\n  });\n  wsClient.on('reconnected', (data) => {\n    console.log('ws has reconnected ', data?.wsKey);\n  });\n  wsClient.on('exception', (data) => {\n    console.error('ws saw error: ', data);\n\n    // Note: manually re-subscribing like this may only be needed if the FIRST user data connection attempt failed\n    // Capture exceptions using the error event, and handle this.\n    if (!didConnectUserDataSuccessfully && data.wsKey.includes('userData')) {\n      setTimeout(() => {\n        console.warn(\n          `Retrying connection to userdata ws ${data.wsKey} in 1 second...`,\n        );\n        if (data.wsKey.includes('spot')) {\n          wsClient.subscribeSpotUserDataStream();\n        } else if (data.wsKey.includes('usdm')) {\n          wsClient.subscribeUsdFuturesUserDataStream();\n        }\n      }, 1000);\n    }\n  });\n\n  wsClient.subscribeSpotUserDataStream();\n  // wsClient.subscribeMarginUserDataStream();\n  // wsClient.subscribeIsolatedMarginUserDataStream('BTCUSDT');\n  wsClient.subscribeUsdFuturesUserDataStream();\n})();\n",
                  "metadata": {}
                },
                {
                  "type": "file",
                  "name": "ws-userdata-listenKey-testnet.ts",
                  "path": "examples/Binance/WebSockets/Private(userdata)/ws-userdata-listenKey-testnet.ts",
                  "code": "import {\n  DefaultLogger,\n  isWsFormattedFuturesUserDataEvent,\n  isWsFormattedSpotUserDataEvent,\n  isWsFormattedSpotUserDataExecutionReport,\n  isWsFormattedUserDataEvent,\n  WebsocketClient,\n  WsUserDataEvents,\n} from 'binance';\n\n(async () => {\n  const key = process.env.API_KEY_COM || 'APIKEY';\n  const secret = process.env.API_SECRET_COM || 'APISECRET';\n\n  // console.log('using api credentials: ', { key, secret });\n\n  const ignoredTraceLogMsgs = [\n    'Sending ping',\n    'Received pong, clearing pong timer',\n    'Received ping, sending pong frame',\n  ];\n\n  // Optional, hook and customise logging behavior\n  const logger = {\n    ...DefaultLogger,\n    trace: (msg: string, context?: any) => {\n      if (ignoredTraceLogMsgs.includes(msg)) {\n        return;\n      }\n      console.log(JSON.stringify({ msg, context }));\n    },\n  };\n\n  const wsClient = new WebsocketClient(\n    {\n      api_key: key,\n      api_secret: secret,\n      beautify: true,\n      testnet: true,\n    },\n    logger,\n  );\n\n  // If you prefer, you can receive raw unprocessed data without the \"beautifier\":\n  // wsClient.on('message', (data) => {\n  //   console.log('raw message received ', JSON.stringify(data, null, 2));\n  // });\n\n  function onUserDataEvent(data: WsUserDataEvents) {\n    // the market denotes which API category it came from\n    // if (data.wsMarket.includes('spot')) {\n\n    // or use a type guard, if one exists (PRs welcome)\n    if (isWsFormattedSpotUserDataExecutionReport(data)) {\n      console.log('spot user execution report event: ', data);\n      return;\n    }\n    if (isWsFormattedSpotUserDataEvent(data)) {\n      console.log('spot user data event: ', data);\n      return;\n    }\n    if (data.wsMarket.includes('margin')) {\n      console.log('margin user data event: ', data);\n      return;\n    }\n    if (data.wsMarket.includes('isolatedMargin')) {\n      console.log('isolatedMargin user data event: ', data);\n      return;\n    }\n    if (data.wsMarket.includes('usdmTestnet')) {\n      console.log('usdmTestnet user data event: ', data);\n      return;\n    }\n    if (data.wsMarket.includes('coinmTestnet')) {\n      console.log('coinmTestnet user data event: ', data);\n      return;\n    }\n    if (isWsFormattedFuturesUserDataEvent(data)) {\n      console.log('usdm user data event: ', data);\n      return;\n    }\n  }\n\n  // Beautified/formatted events from binance:\n  wsClient.on('formattedMessage', (data) => {\n    // The wsKey can be parsed to determine the type of message (what websocket it came from)\n    // if (!Array.isArray(data) && data.wsKey.includes('userData')) {\n    //   return onUserDataEvent(data);\n    // }\n\n    // or use a type guard if available\n    if (isWsFormattedUserDataEvent(data)) {\n      return onUserDataEvent(data);\n    }\n    console.log('formattedMsg: ', JSON.stringify(data, null, 2));\n  });\n\n  wsClient.on('open', (data) => {\n    console.log('connection opened open:', data.wsKey, data.wsUrl);\n  });\n\n  // response to command sent via WS stream (e.g LIST_SUBSCRIPTIONS)\n  wsClient.on('response', (data) => {\n    console.log('log reply: ', JSON.stringify(data, null, 2));\n  });\n\n  wsClient.on('reconnecting', (data) => {\n    console.log('ws automatically reconnecting.... ', data?.wsKey);\n  });\n\n  wsClient.on('reconnected', (data) => {\n    if (\n      typeof data?.wsKey === 'string' &&\n      data.wsKey.toLowerCase().includes('userdata')\n    ) {\n      console.log('ws for user data stream has reconnected ', data?.wsKey);\n      // This is a good place to check your own state is still in sync with the account state on the exchange, in case any events were missed while the library was reconnecting:\n      // - fetch balances\n      // - fetch positions\n      // - fetch orders\n    } else {\n      console.log('ws has reconnected ', data?.wsKey);\n    }\n  });\n\n  wsClient.on('exception', (data) => {\n    console.error('ws saw error: ', data);\n  });\n\n  wsClient.subscribeSpotUserDataStream();\n  // wsClient.subscribeMarginUserDataStream();\n  // wsClient.subscribeIsolatedMarginUserDataStream('BTCUSDT');\n  // wsClient.subscribeUsdFuturesUserDataStream();\n\n  // setTimeout(() => {\n  //   console.log('killing all connections');\n  //   wsClient.closeAll();\n  // }, 1000 * 15);\n})();\n",
                  "metadata": {}
                },
                {
                  "type": "file",
                  "name": "ws-userdata-listenkey.ts",
                  "path": "examples/Binance/WebSockets/Private(userdata)/ws-userdata-listenkey.ts",
                  "code": "// or\n// import {\n//   DefaultLogger,\n//   isWsFormattedFuturesUserDataEvent,\n//   isWsFormattedSpotUserDataEvent,\n//   isWsFormattedSpotUserDataExecutionReport,\n//   isWsFormattedUserDataEvent,\n//   WebsocketClient,\n//   WsUserDataEvents,\n// } from 'binance';\n\nimport {\n  DefaultLogger,\n  isWsFormattedFuturesUserDataEvent,\n  isWsFormattedSpotUserDataEvent,\n  isWsFormattedSpotUserDataExecutionReport,\n  isWsFormattedUserDataEvent,\n  WebsocketClient,\n  WsConnectionStateEnum,\n  WsUserDataEvents,\n} from 'binance';\n\n(async () => {\n  const key = process.env.API_KEY_COM || 'APIKEY';\n  const secret = process.env.API_SECRET_COM || 'APISECRET';\n\n  console.log({ key, secret });\n\n  const ignoredTraceLogMsgs = [\n    'Sending ping',\n    'Received ping frame, sending pong frame',\n    'Received pong frame, clearing pong timer',\n  ];\n\n  // Optional, hook and customise logging behavior\n  const logger = {\n    ...DefaultLogger,\n    trace: (msg: string, context?: any) => {\n      if (ignoredTraceLogMsgs.includes(msg)) {\n        return;\n      }\n      console.log(JSON.stringify({ msg, context }));\n    },\n  };\n\n  const wsClient = new WebsocketClient(\n    {\n      api_key: key,\n      api_secret: secret,\n      beautify: true,\n      // testnet: true,\n    },\n    logger,\n  );\n\n  // wsClient.on('message', (data) => {\n  //   console.log('raw message received ', JSON.stringify(data, null, 2));\n  // });\n\n  function onUserDataEvent(data: WsUserDataEvents) {\n    // the market denotes which API category it came from\n    // if (data.wsMarket.includes('spot')) {\n\n    // or use a type guard, if one exists (PRs welcome)\n    if (isWsFormattedSpotUserDataExecutionReport(data)) {\n      console.log('spot user execution report event: ', data);\n      return;\n    }\n    if (isWsFormattedSpotUserDataEvent(data)) {\n      console.log('spot user data event: ', data);\n      return;\n    }\n    if (data.wsMarket.includes('margin')) {\n      console.log('margin user data event: ', data);\n      return;\n    }\n    if (data.wsMarket.includes('isolatedMargin')) {\n      console.log('isolatedMargin user data event: ', data);\n      return;\n    }\n    if (data.wsMarket.includes('usdmTestnet')) {\n      console.log('usdmTestnet user data event: ', data);\n      return;\n    }\n    if (data.wsMarket.includes('coinmTestnet')) {\n      console.log('coinmTestnet user data event: ', data);\n      return;\n    }\n    if (isWsFormattedFuturesUserDataEvent(data)) {\n      console.log('usdm user data event: ', data);\n      return;\n    }\n\n    console.log(\n      'onUserDataEvent()->unhandled: ',\n      JSON.stringify(data, null, 2),\n    );\n  }\n\n  wsClient.on('formattedMessage', (data) => {\n    // The wsKey can be parsed to determine the type of message (what websocket it came from)\n    // if (!Array.isArray(data) && data.wsKey.includes('userData')) {\n    //   return onUserDataEvent(data);\n    // }\n\n    // or use a type guard if available\n    if (isWsFormattedUserDataEvent(data)) {\n      return onUserDataEvent(data);\n    }\n    console.log('formattedMsg: ', JSON.stringify(data, null, 2));\n  });\n\n  wsClient.on('open', (data) => {\n    console.log('connection opened open:', data.wsKey, data.wsUrl);\n  });\n\n  // response to command sent via WS stream (e.g LIST_SUBSCRIPTIONS)\n  wsClient.on('response', (data) => {\n    console.log('log response: ', JSON.stringify(data, null, 2));\n  });\n\n  wsClient.on('reconnecting', (data) => {\n    console.log('ws automatically reconnecting.... ', data?.wsKey);\n  });\n\n  wsClient.on('reconnected', (data) => {\n    if (\n      typeof data?.wsKey === 'string' &&\n      data.wsKey.toLowerCase().includes('userdata')\n    ) {\n      console.log('ws for user data stream has reconnected ', data?.wsKey);\n      // This is a good place to check your own state is still in sync with the account state on the exchange, in case any events were missed while the library was reconnecting:\n      // - fetch balances\n      // - fetch positions\n      // - fetch orders\n    } else {\n      console.log('ws has reconnected ', data?.wsKey);\n    }\n  });\n\n  wsClient.on('exception', (data) => {\n    console.error('ws saw error: ', data);\n  });\n\n  /**\n   * This example demonstrates subscribing to the user data stream via the\n   * listen key workflow.\n   *\n   * Note: the listen key workflow is deprecated for \"spot\" markets. Use the\n   * WebSocket API `userDataStream.subscribe` workflow instead (only available\n   * in spot right now). See `subscribeUserDataStream()` in the WebsocketAPIClient.\n   *\n   * Each method below opens a dedicated WS connection attached to an automatically\n   * fetched listen key (a session for your user data stream).\n   *\n   * Once subscribed, you don't need to do anything else. Listen-key keep-alive, refresh, reconnects, etc are all automatically handled by the SDK.\n   */\n\n  // Example 1: Spot, by default, routes to the \"main\" wss domain \"wss://stream.binance.com:9443\".\n  // No parameters needed, just call the subscribe function.\n  wsClient.subscribeSpotUserDataStream();\n\n  // // Example 2: Optional: subscribe to spot via other wss domains\n  wsClient.subscribeSpotUserDataStream('main2'); // routed to \"wss://stream.binance.com:443\"\n\n  // // Example 3: cross margin\n  wsClient.subscribeCrossMarginUserDataStream();\n\n  // Example 4: isolated margin\n  wsClient.subscribeIsolatedMarginUserDataStream('BTCUSDC');\n\n  /**\n   * Futures\n   */\n\n  // Example 5: usdm futures\n  wsClient.subscribeUsdFuturesUserDataStream();\n\n  // Example 6: coinm futures\n  wsClient.subscribeCoinFuturesUserDataStream();\n\n  // Example 7: portfolio margin\n  // wsClient.subscribePortfolioMarginUserDataStream();\n\n  // Example 8: portfolio margin pro\n  // wsClient.subscribePortfolioMarginUserDataStream('portfolioMarginProUserData');\n\n  // after 15 seconds, kill user data connections one by one (or all at once)\n  setTimeout(() => {\n    // console.log('killing all connections at once');\n    // wsClient.closeAll();\n\n    // or:\n    console.log('killing individual connections');\n\n    try {\n      // console.log('killing all connections');\n      // wsClient.closeAll();\n      // Example 1:\n      wsClient.unsubscribeSpotUserDataStream();\n      // Example 2: use the wsKey to route to another domain\n      wsClient.unsubscribeSpotUserDataStream('main2');\n      // Example 3: cross margin\n      wsClient.unsubscribeCrossMarginUserDataStream();\n      // Example 4: isolated margin\n      wsClient.unsubscribeIsolatedMarginUserDataStream('BTCUSDC');\n      // Example 5: usdm futures\n      wsClient.unsubscribeUsdFuturesUserDataStream();\n      // Example 6: coinm futures\n      wsClient.unsubscribeCoinFuturesUserDataStream();\n      // // Example 7: portfolio margin\n      // wsClient.unsubscribePortfolioMarginUserDataStream();\n      // // Example 8: portfolio margin pro\n      // wsClient.unsubscribePortfolioMarginUserDataStream(\n      //   'portfolioMarginProUserData',\n      // );\n    } catch (e) {\n      console.error('Exception trying to close a user data stream: ', e);\n    }\n  }, 1000 * 15);\n\n  // after 20 seconds, list the remaining open connections\n  setTimeout(() => {\n    try {\n      console.log(\n        'remaining connections:',\n        wsClient\n          .getWsStore()\n          .getKeys()\n          .filter(\n            (key) =>\n              wsClient.getWsStore().get(key)?.connectionState ===\n              WsConnectionStateEnum.CONNECTED,\n          ),\n      );\n    } catch (e) {\n      console.error('Exception trying to close a user data stream: ', e);\n    }\n  }, 1000 * 20);\n})();\n",
                  "metadata": {}
                },
                {
                  "type": "file",
                  "name": "ws-userdata-wsapi.ts",
                  "path": "examples/Binance/WebSockets/Private(userdata)/ws-userdata-wsapi.ts",
                  "code": "/* eslint-disable @typescript-eslint/no-unused-vars */\n\n// or\n\nimport {\n  isWsFormattedFuturesUserDataEvent,\n  isWsFormattedSpotBalanceUpdate,\n  isWsFormattedSpotOutboundAccountPosition,\n  isWsFormattedSpotUserDataEvent,\n  isWsFormattedUserDataEvent,\n  WebsocketAPIClient,\n  WebsocketClient,\n  WS_KEY_MAP,\n} from 'binance';\n\n/**\n * The WS API only works with an Ed25519 API key.\n *\n * Check the rest-private-ed25519.md in this folder for more guidance\n * on preparing this Ed25519 API key.\n */\n\nconst publicKey = `-----BEGIN PUBLIC KEY-----\nMCexampleQTxwLU9o=\n-----END PUBLIC KEY-----\n`;\n\nconst privateKey = `-----BEGIN PRIVATE KEY-----\nMC4CAQAexamplewqj5CzUuTy1\n-----END PRIVATE KEY-----\n`;\n\nconst key = process.env.API_KEY_COM;\nconst secret = process.env.API_SECRET_COM;\n\n// returned by binance, generated using the publicKey (above)\n// const key = 'BVv39ATnIme5TTZRcC3I04C3FqLVM7vCw3Hf7mMT7uu61nEZK8xV1V5dmhf9kifm';\n// Your Ed25519 private key is passed as the \"secret\"\n// const secret = privateKey;\n\nfunction attachEventHandlers<TWSClient extends WebsocketClient>(\n  wsClient: TWSClient,\n): void {\n  /**\n   * General event handlers for monitoring the WebsocketClient\n   */\n\n  // Raw events received from binance, as is:\n  wsClient.on('message', (data) => {\n    // console.log('raw message received ', JSON.stringify(data));\n  });\n\n  // Formatted events from the built-in beautifier, with fully readable property names and parsed floats:\n  wsClient.on('formattedMessage', (data) => {\n    // We've included type guards for many events, especially on the user data stream, to help easily\n    // identify events using simple `if` checks.\n    //\n    // Use `if` checks to narrow down specific events from the user data stream\n    if (isWsFormattedSpotOutboundAccountPosition(data)) {\n      console.log(\n        'formattedMessage->isWsFormattedSpotOutboundAccountPosition: ',\n        data,\n      );\n      return;\n    }\n    if (isWsFormattedSpotBalanceUpdate(data)) {\n      console.log('formattedMessage->isWsFormattedSpotBalanceUpdate: ', data);\n      return;\n    }\n\n    //// More general handlers, if you prefer:\n\n    // Any user data event in spot:\n    if (isWsFormattedSpotUserDataEvent(data)) {\n      console.log('formattedMessage->isWsFormattedSpotUserDataEvent: ', data);\n    }\n    // Any user data event in futures:\n    if (isWsFormattedFuturesUserDataEvent(data)) {\n      console.log(\n        'formattedMessage->isWsFormattedFuturesUserDataEvent: ',\n        data,\n      );\n    }\n\n    // Any user data event on any market (spot + futures)\n    if (isWsFormattedUserDataEvent(data)) {\n      console.log('formattedMessage->isWsFormattedUserDataEvent: ', data);\n      return;\n    }\n    console.log('formattedMessage: ', data);\n  });\n\n  // Formatted user data events also have a dedicated event handler, but that's optional and no different to the above\n  // wsClient.on('formattedUserDataMessage', (data) => {\n  //   if (isWsFormattedSpotOutboundAccountPosition(data)) {\n  //     return;\n  //     // console.log(\n  //     //   'formattedUserDataMessage->isWsFormattedSpotOutboundAccountPosition: ',\n  //     //   data,\n  //     // );\n  //   }\n  //   if (isWsFormattedSpotBalanceUpdate(data)) {\n  //     return console.log(\n  //       'formattedUserDataMessage->isWsFormattedSpotBalanceUpdate: ',\n  //       data,\n  //     );\n  //   }\n  //   console.log('formattedUserDataMessage: ', data);\n  // });\n  wsClient.on('response', (data) => {\n    // console.log('ws response: ', JSON.stringify(data));\n  });\n  wsClient.on('open', (data) => {\n    console.log('ws connected', data.wsKey);\n  });\n  wsClient.on('reconnecting', ({ wsKey }) => {\n    console.log('ws automatically reconnecting.... ', wsKey);\n  });\n  wsClient.on('reconnected', (data) => {\n    console.log('ws has reconnected ', data?.wsKey);\n  });\n  wsClient.on('authenticated', (data) => {\n    console.log('ws has authenticated ', data?.wsKey);\n  });\n  wsClient.on('exception', (data) => {\n    console.error('ws exception: ', JSON.stringify(data));\n  });\n}\n\nasync function main() {\n  const wsClient = new WebsocketAPIClient({\n    api_key: key,\n    api_secret: secret,\n    beautify: true,\n\n    // Enforce testnet ws connections, regardless of supplied wsKey:\n    testnet: true,\n\n    // Note: unless you set this to false, the SDK will automatically call\n    // the `subscribeUserDataStream()` method again if reconnected (if you called it before):\n    // resubscribeUserDataStreamAfterReconnect: true,\n\n    // If you want your own event handlers instead of the default ones with logs, disable this setting and see the `attachEventHandlers` example below:\n    attachEventListeners: false,\n  });\n\n  // Attach your own event handlers to process incoming events\n  // You may want to disable the default ones to avoid unnecessary logs (via attachEventListeners:false, above)\n  attachEventHandlers(wsClient.getWSClient());\n\n  // Optional, if you see RECV Window errors, you can use this to manage time issues.\n  // ! However, make sure you sync your system clock first!\n  // https://github.com/tiagosiebler/awesome-crypto-examples/wiki/Timestamp-for-this-request-is-outside-of-the-recvWindow\n  // wsClient.setTimeOffsetMs(-5000);\n\n  // Note: unless you set resubscribeUserDataStreamAfterReconnect to false, the SDK will\n  // automatically call this method again if reconnected,\n  try {\n    const response = await wsClient.subscribeUserDataStream(\n      WS_KEY_MAP.mainWSAPI, // The `mainWSAPI` wsKey will connect to the \"spot\" Websocket API on Binance.\n    );\n\n    console.log('subscribeUserDataStream response: ', response);\n  } catch (e) {\n    console.log('subscribeUserDataStream error: ', e);\n  }\n}\n\n// Start executing the example workflow\nmain();\n",
                  "metadata": {}
                }
              ]
            },
            {
              "type": "folder",
              "name": "Public",
              "path": "examples/Binance/WebSockets/Public",
              "children": [
                {
                  "type": "file",
                  "name": "ws-public-spot-orderbook.ts",
                  "path": "examples/Binance/WebSockets/Public/ws-public-spot-orderbook.ts",
                  "code": "/* eslint-disable @typescript-eslint/no-unused-vars */\n/* eslint-disable no-unused-vars */\nimport {\n  DefaultLogger,\n  isWsPartialBookDepthEventFormatted,\n  WebsocketClient,\n  WsMessagePartialBookDepthEventFormatted,\n} from 'binance';\n\n(async () => {\n  const logger = {\n    ...DefaultLogger,\n    // trace: () => {},\n  };\n\n  const wsClient = new WebsocketClient(\n    {\n      beautify: true,\n    },\n    logger,\n  );\n\n  const topicsPartialBookDepths: string[] = [];\n\n  /**\n   * Simple example for receiving depth snapshots from spot orderbooks\n   */\n  wsClient.on('formattedMessage', (data) => {\n    if (isWsPartialBookDepthEventFormatted(data)) {\n      const [symbol] = data.streamName.split('@');\n      if (!symbol) {\n        throw new Error('Failed to extract context from event?');\n      }\n\n      console.log(`ws book event for \"${symbol.toUpperCase()}\"`, data);\n      return;\n    }\n\n    console.log('log formattedMessage: ', data);\n  });\n\n  wsClient.on('open', (data) => {\n    console.log('connection opened open:', data.wsKey, data.wsUrl);\n  });\n  wsClient.on('response', (data) => {\n    console.log('log response: ', JSON.stringify(data, null, 2));\n  });\n  wsClient.on('reconnecting', (data) => {\n    console.log('ws automatically reconnecting.... ', data?.wsKey);\n  });\n  wsClient.on('reconnected', (data) => {\n    console.log('ws has reconnected ', data?.wsKey);\n  });\n  wsClient.on('exception', (data) => {\n    console.error('ws exception: ', data?.wsKey, data);\n  });\n\n  // Request subscription to the following symbol events:\n  const symbols = ['BTCUSDT'];\n  // const symbols = ['BTCUSDT', 'ETHUSDT', 'BNBUSDT'];\n\n  // Loop through symbols\n  for (const symbol of symbols) {\n    console.log('subscribing to trades for: ', symbol);\n    // The old way, convenient but unnecessary:\n    // wsClient.subscribePartialBookDepths(symbol, levels, 1000, 'spot');\n\n    // Manually build a topic matching the structure expected by binance:\n    // btcusdt@depth20@1000ms\n\n    const streamName = 'depth';\n    const levels = 20;\n    const updateMs = '@' + 1000 + 'ms';\n\n    const topic = `${symbol.toLowerCase()}@${streamName}${levels}${updateMs}`;\n    topicsPartialBookDepths.push(topic);\n  }\n\n  // Request subscribe for these topics in the main product group (spot markets are under \"main\")\n  wsClient.subscribe(topicsPartialBookDepths, 'main');\n})();\n",
                  "metadata": {}
                },
                {
                  "type": "file",
                  "name": "ws-public-spot-trades.ts",
                  "path": "examples/Binance/WebSockets/Public/ws-public-spot-trades.ts",
                  "code": "import { DefaultLogger, isWsFormattedTrade, WebsocketClient } from 'binance';\n\n(async () => {\n  const logger = {\n    ...DefaultLogger,\n    // trace: () => {},\n  };\n\n  const wsClient = new WebsocketClient(\n    {\n      beautify: true,\n    },\n    logger,\n  );\n\n  wsClient.on('formattedMessage', (data) => {\n    if (isWsFormattedTrade(data)) {\n      console.log('trade event ', data);\n      return;\n    }\n\n    console.log('log formattedMessage: ', data);\n  });\n\n  wsClient.on('open', (data) => {\n    console.log('connection opened open:', data.wsKey, data.wsUrl);\n  });\n  wsClient.on('response', (data) => {\n    console.log('log response: ', JSON.stringify(data, null, 2));\n  });\n  wsClient.on('reconnecting', (data) => {\n    console.log('ws automatically reconnecting.... ', data?.wsKey);\n  });\n  wsClient.on('reconnected', (data) => {\n    console.log('ws has reconnected ', data?.wsKey);\n  });\n\n  // Request subscription to the following symbol trade events:\n  const symbols = ['BTCUSDT', 'ETHUSDT', 'BNBUSDT'];\n\n  // Loop through symbols\n  for (const symbol of symbols) {\n    console.log('subscribing to trades for: ', symbol);\n    wsClient.subscribeSpotTrades(symbol);\n  }\n})();\n",
                  "metadata": {}
                },
                {
                  "type": "file",
                  "name": "ws-public-usdm-funding.ts",
                  "path": "examples/Binance/WebSockets/Public/ws-public-usdm-funding.ts",
                  "code": "import {\n  DefaultLogger,\n  isWsFormattedMarkPriceUpdateArray,\n  WebsocketClient,\n} from 'binance';\n\n(async () => {\n  const logger = {\n    ...DefaultLogger,\n    // trace: () => {},\n  };\n\n  const wsClient = new WebsocketClient(\n    {\n      // api_key: key,\n      // api_secret: secret,\n      beautify: true,\n    },\n    logger,\n  );\n\n  wsClient.on('formattedMessage', (data) => {\n    if (isWsFormattedMarkPriceUpdateArray(data)) {\n      console.log('all mark price evt received ');\n\n      const mapped = data\n        .map((r) => {\n          return {\n            ...r,\n            // value is in decimal, multiply by 100 to get percent value\n            fundingRate: (Number(r.fundingRate) * 100).toFixed(2),\n          };\n        })\n        .sort((a, b) => a.symbol.localeCompare(b.symbol));\n\n      // log table sorted alphabetically by symbol\n      console.table(mapped);\n      return;\n    }\n\n    console.log('log unhandled formatted msg: ', data);\n  });\n\n  wsClient.on('open', (data) => {\n    console.log('connection opened open:', data.wsKey, data.wsUrl);\n  });\n\n  // response to command sent via WS stream (e.g LIST_SUBSCRIPTIONS)\n  wsClient.on('response', (data) => {\n    console.log('log response: ', JSON.stringify(data, null, 2));\n  });\n  wsClient.on('reconnecting', (data) => {\n    console.log('ws automatically reconnecting.... ', data?.wsKey);\n  });\n  wsClient.on('reconnected', (data) => {\n    console.log('ws has reconnected ', data?.wsKey);\n  });\n\n  wsClient.subscribeAllMarketMarkPrice('usdm', 1000);\n})();\n",
                  "metadata": {}
                },
                {
                  "type": "file",
                  "name": "ws-public.ts",
                  "path": "examples/Binance/WebSockets/Public/ws-public.ts",
                  "code": "/* eslint-disable @typescript-eslint/no-unused-vars */\nimport {\n  DefaultLogger,\n  isWsDiffBookDepthEventFormatted,\n  isWsPartialBookDepthEventFormatted,\n  WebsocketClient,\n} from 'binance';\n\n(async () => {\n  // Without typescript:\n  // const logger = {\n  const logger: DefaultLogger = {\n    ...DefaultLogger,\n    trace: (...params) => {\n      // A simple way to suppress heartbeats but receive all other traces\n      // if (params[0].includes('ping') || params[0].includes('pong')) {\n      //   return;\n      // }\n      console.log('\\n', new Date(), 'trace ', ...params);\n    },\n  };\n\n  const wsClient = new WebsocketClient(\n    {\n      // Optional: when enabled, the SDK will try to format incoming data into more readable objects.\n      // Beautified data is emitted via the \"formattedMessage\" event\n      beautify: true,\n    },\n    logger, // Optional: customise logging behaviour by extending or overwriting the default logger implementation\n  );\n\n  // Raw unprocessed incoming data, e.g. if you have the beautifier disabled\n  wsClient.on('message', (data) => {\n    // console.log('raw message received ', JSON.stringify(data, null, 2));\n    // console.log('raw message received ', JSON.stringify(data));\n    console.log('log rawMessage: ', data);\n  });\n\n  // Formatted data that has gone through the beautifier\n  wsClient.on('formattedMessage', (data) => {\n    console.log('log formattedMessage: ', data);\n\n    /**\n     * Optional: we've included type-guards for many formatted websocket topics.\n     *\n     * These can be used within `if` blocks to narrow down specific event types (even for non-typescript users).\n     */\n    // if (isWsAggTradeFormatted(data)) {\n    //   console.log('log agg trade: ', data);\n    //   return;\n    // }\n\n    // // For one symbol\n    // if (isWsFormattedMarkPriceUpdateEvent(data)) {\n    //   console.log('log mark price: ', data);\n    //   return;\n    // }\n\n    // // for many symbols\n    // if (isWsFormattedMarkPriceUpdateArray(data)) {\n    //   console.log('log mark prices: ', data);\n    //   return;\n    // }\n\n    // if (isWsFormattedKline(data)) {\n    //   console.log('log kline: ', data);\n    //   return;\n    // }\n\n    // if (isWsFormattedTrade(data)) {\n    //   return console.log('log trade: ', data);\n    // }\n\n    // if (isWsFormattedForceOrder(data)) {\n    //   return console.log('log force order: ', data);\n    // }\n\n    // if (isWsFormatted24hrTickerArray(data)) {\n    //   return console.log('log 24hr ticker array: ', data);\n    // }\n\n    // if (isWsFormattedRollingWindowTickerArray(data)) {\n    //   return console.log('log rolling window ticker array: ', data);\n    // }\n\n    // if (isWsFormatted24hrTicker(data)) {\n    //   return console.log('log 24hr ticker: ', data);\n    // }\n\n    if (isWsPartialBookDepthEventFormatted(data)) {\n      return console.log('log partial book depth event: ', data);\n    }\n\n    if (isWsDiffBookDepthEventFormatted(data)) {\n      return console.log('log diff book depthUpdate event: ', data);\n    }\n  });\n\n  wsClient.on('formattedUserDataMessage', (data) => {\n    console.log('log formattedUserDataMessage: ', data);\n  });\n\n  wsClient.on('open', (data) => {\n    console.log('connection opened open:', data.wsKey);\n  });\n\n  // response to command sent via WS stream (e.g LIST_SUBSCRIPTIONS)\n  wsClient.on('response', (data) => {\n    console.log('log response: ', data?.message || JSON.stringify(data));\n  });\n\n  wsClient.on('reconnecting', (data) => {\n    console.log('ws automatically reconnecting.... ', data?.wsKey);\n  });\n\n  wsClient.on('reconnected', (data) => {\n    console.log('ws has reconnected ', data?.wsKey);\n    // No action needed here, unless you need to query the REST API after being reconnected.\n  });\n\n  try {\n    /**\n     * The Websocket Client will automatically manage connectivity and active topics/subscriptions for you.\n     *\n     * Simply call wsClient.subscribe(topic, wsKey) as many times as you want, with or without an array.\n     */\n\n    // // E.g. one at a time, routed to the coinm futures websockets:\n    // wsClient.subscribe('btcusd@indexPrice', 'coinm');\n    // wsClient.subscribe('btcusd@miniTicker', 'coinm');\n\n    // // Or send many topics at once to a stream, e.g. the usdm futures stream:\n    // wsClient.subscribe(\n    //   [\n    //     'btcusdt@aggTrade',\n    //     'btcusdt@markPrice',\n    //     '!ticker@arr',\n    //     '!miniTicker@arr',\n    //   ],\n    //   'usdm',\n    // );\n\n    const symbol = 'BTCUSDT';\n    const coinMSymbol = 'ETHUSD_PERP';\n    const coinMSymbol2 = 'ETHUSD';\n\n    /**\n     * Subscribe to each available type of spot market topic, the new way\n     */\n    await wsClient.subscribe(\n      [\n        // Aggregate Trade Streams\n        // https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#aggregate-trade-streams\n        'btcusdt@aggTrade',\n        // Trade Streams\n        // https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#trade-streams\n        'btcusdt@trade',\n        // Kline/Candlestick Streams for UTC\n        // https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#klinecandlestick-streams-for-utc\n        'btcusdt@kline_5m',\n        // Kline/Candlestick Streams with timezone offset\n        // https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#klinecandlestick-streams-with-timezone-offset\n        'btcusdt@kline_5m@+08:00',\n        // Individual Symbol Mini Ticker Stream\n        // https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#individual-symbol-mini-ticker-stream\n        'btcusdt@miniTicker',\n        // All Market Mini Tickers Stream\n        // https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#all-market-mini-tickers-stream\n        '!miniTicker@arr',\n        // Individual Symbol Ticker Streams\n        // https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#individual-symbol-ticker-streams\n        'btcusdt@ticker',\n        // All Market Tickers Stream - DEPRECATED (2025-11-14)\n        // https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#all-market-tickers-stream\n        // '!ticker@arr', // DEPRECATED: Use '<symbol>@ticker' or '!miniTicker@arr' instead\n        // Recommended alternative: '!miniTicker@arr' for all market mini tickers (already subscribed above)\n        // Individual Symbol Rolling Window Statistics Streams\n        // https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#individual-symbol-rolling-window-statistics-streams\n        'btcusdt@ticker_1h',\n        // All Market Rolling Window Statistics Streams\n        // https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#all-market-rolling-window-statistics-streams\n        '!ticker_1h@arr',\n        // Individual Symbol Book Ticker Streams\n        // https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#individual-symbol-book-ticker-streams\n        'btcusdt@bookTicker',\n        // Average Price\n        // https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#average-price\n        'btcusdt@avgPrice',\n        // Partial Book Depth Streams\n        // https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#partial-book-depth-streams\n        'btcusdt@depth5',\n        'btcusdt@depth10@100ms',\n        // Diff. Depth Stream\n        // https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#diff-depth-stream\n        'btcusdt@depth',\n        'btcusdt@depth@100ms',\n      ],\n      // Look at the `WS_KEY_URL_MAP` for a list of values here:\n      // https://github.com/tiagosiebler/binance/blob/master/src/util/websockets/websocket-util.ts\n      // \"main\" connects to wss://stream.binance.com:9443/stream\n      // https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams\n      'main',\n    );\n\n    await wsClient.subscribe(\n      [\n        // Aggregate Trade Stream\n        // https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/Aggregate-Trade-Streams\n        'btcusdt@aggTrade',\n        // Mark Price Stream\n        // https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/Mark-Price-Stream\n        'btcusdt@markPrice',\n        'btcusdt@markPrice@1s',\n        // Mark Price Stream for All market\n        // https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/Mark-Price-Stream-for-All-market\n        '!markPrice@arr',\n        // Kline/Candlestick Streams\n        // https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/Kline-Candlestick-Streams\n        // 'btcusdt@kline_1m',\n        // Continuous Contract Kline/Candlestick Streams\n        // https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/Continuous-Contract-Kline-Candlestick-Streams\n        // 'btcusdt_perpetual@continuousKline_1m', // DOESNT EXIST AS TYPE GUARD, ONLY IN BEAUTIFIER\n        // Individual Symbol Mini Ticker Stream\n        // https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/Individual-Symbol-Mini-Ticker-Stream\n        // 'btcusdt@miniTicker', // DOESNT EXIST AS TYPE GUARD, ONLY FOR RAW MESSAGE\n        // All Market Mini Tickers Stream\n        // https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/All-Market-Mini-Tickers-Stream\n        // '!miniTicker@arr', // DOESNT EXIST AS TYPE GUARD\n        // Individual Symbol Ticker Streams\n        // https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/Individual-Symbol-Ticker-Streams\n        //'btcusdt@ticker',\n        // All Market Tickers Stream\n        // https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/All-Market-Tickers-Stream\n        // '!ticker@arr', // DOESNT EXIST AS TYPE GUARD\n        // Individual Symbol Book Ticker Streams\n        // https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/Individual-Symbol-Book-Ticker-Streams\n        //'btcusdt@bookTicker', // DOESNT EXIST AS TYPE GUARD\n        // All Book Tickers Stream\n        // https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/All-Book-Tickers-Stream\n        // '!bookTicker', // DOESNT EXIST AS TYPE GUARD\n        // Liquidation Order Stream\n        // https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/Liquidation-Order-Streams\n        // 'btcusdt@forceOrder',\n        // Liquidation Order Stream for All market\n        // https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/All-Market-Liquidation-Order-Streams\n        //'!forceOrder@arr',\n        // Partial Book Depth Streams\n        // https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/Partial-Book-Depth-Streams\n        //'btcusdt@depth5',\n        // 'btcusdt@depth10@100ms'\n        // Diff. Book Depth Stream\n        // https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/Diff-Book-Depth-Streams\n        // 'btcusdt@depth',\n        // 'btcusdt@depth@100ms',\n        // 'btcusdt@depth@500ms',\n        // 'btcusdt@depth@1000ms'\n        // Composite Index Symbol Information Streams\n        // https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/Composite-Index-Symbol-Information-Streams\n        // 'btcusdt@compositeIndex' // DOESNT EXIST AS TYPE GUARD\n        // Contract Info Stream\n        // https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/Contract-Info-Stream\n        // '!contractInfo' // DOESNT EXIST AS TYPE GUARD\n        // Multi-Assets Mode Asset Index Stream\n        // https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/Multi-Assets-Mode-Asset-Index\n        // '!assetIndex@arr' // DOESNT EXIST AS TYPE GUARD\n        // 'btcusdt@assetIndex'\n      ],\n      'usdm',\n    );\n\n    /**\n     * Subscribe to each available options market data websocket topic, the new way:\n     *\n     * https://developers.binance.com/docs/derivatives/options-trading/websocket-market-streams/New-Symbol-Info\n     * https://eapi.binance.com/eapi/v1/exchangeInfo\n     */\n\n    const optionsAsset = 'ethusdt';\n    const optionsExpiration = '260128'; // YYMMDD\n    const optionsSymbol = 'ETH-260128-3000-C';\n    const optionsSymbol2 = 'ETH-260129-2950-C';\n    const KlineInterval = '1m';\n    await wsClient.subscribe(\n      [\n        '!optionSymbol',\n        `${optionsAsset}@openInterest@${optionsExpiration}`,\n        `${optionsAsset}@optionMarkPrice`,\n        `${optionsSymbol}@kline_${KlineInterval}`,\n        `${optionsSymbol2}@kline_${KlineInterval}`,\n        '!index@arr',\n        `${symbol}@bookTicker`,\n        `${symbol}@optionTicker`,\n        `${symbol}@optionTrade`,\n        `${symbol}@depth5@100ms`,\n        `${symbol}@depth@100ms`,\n      ],\n      'eoptions',\n    );\n\n    // You can send raw commands, such as asking for list of active subscriptions after 5 seconds. Use with caution:\n    // setTimeout(() => {\n    //   wsClient.tryWsSend(\n    //     'eoptions',\n    //     JSON.stringify({\n    //       method: 'LIST_SUBSCRIPTIONS',\n    //       id: Date.now(),\n    //     }),\n    //   );\n    // }, 1000 * 5);\n\n    // /**\n    //  *\n    //  * For those that used the Node.js Binance SDK before the v3 release, you can\n    //  * still subscribe to available market topics the \"old\" way, for convenience\n    //  * when migrating from the old WebsocketClient to the new multiplex client):\n    //  *\n    //  */\n\n    // wsClient.subscribeAggregateTrades(symbol, 'usdm');\n    // wsClient.subscribeTrades(symbol, 'spot');\n    // wsClient.subscribeTrades(symbol, 'usdm');\n    // wsClient.subscribeTrades(coinMSymbol, 'coinm');\n    // wsClient.subscribeCoinIndexPrice(coinMSymbol2);\n    // wsClient.subscribeAllBookTickers('usdm');\n    // wsClient.subscribeSpotKline(symbol, '1m');\n    // wsClient.subscribeMarkPrice(symbol, 'usdm');\n    // wsClient.subscribeMarkPrice(coinMSymbol, 'coinm');\n    // wsClient.subscribeAllMarketMarkPrice('usdm');\n    // wsClient.subscribeAllMarketMarkPrice('coinm');\n    // wsClient.subscribeKlines(symbol, '1m', 'usdm');\n    // wsClient.subscribeContinuousContractKlines(\n    //   symbol,\n    //   'perpetual',\n    //   '1m',\n    //   'usdm',\n    // );\n    // wsClient.subscribeIndexKlines(coinMSymbol2, '1m');\n    // wsClient.subscribeMarkPriceKlines(coinMSymbol, '1m');\n    // wsClient.subscribeSymbolMini24hrTicker(symbol, 'spot'); // 0116 265 5309, opt 1\n    // wsClient.subscribeSymbolMini24hrTicker(symbol, 'usdm');\n    // wsClient.subscribeSymbolMini24hrTicker(coinMSymbol, 'coinm');\n    // wsClient.subscribeSymbol24hrTicker(symbol, 'spot');\n    // wsClient.subscribeSymbol24hrTicker(symbol, 'usdm');\n    // wsClient.subscribeSymbol24hrTicker(coinMSymbol, 'coinm');\n    // wsClient.subscribeAllMini24hrTickers('spot');\n    // wsClient.subscribeAllMini24hrTickers('usdm');\n    // wsClient.subscribeAllMini24hrTickers('coinm');\n    // wsClient.subscribeAll24hrTickers('spot');\n    // wsClient.subscribeAll24hrTickers('usdm');\n    // wsClient.subscribeAll24hrTickers('coinm');\n    // wsClient.subscribeSymbolLiquidationOrders(symbol, 'usdm');\n    // wsClient.subscribeAllLiquidationOrders('usdm');\n    // wsClient.subscribeAllLiquidationOrders('coinm');\n    // wsClient.subscribeSpotSymbol24hrTicker(symbol);\n    // wsClient.subscribeSpotPartialBookDepth('ETHBTC', 5, 1000);\n    // wsClient.subscribeAllRollingWindowTickers('spot', '1d');\n    // wsClient.subscribeSymbolBookTicker(symbol, 'spot');\n    // wsClient.subscribePartialBookDepths(symbol, 5, 100, 'spot');\n    // wsClient.subscribeDiffBookDepth(symbol, 100, 'spot');\n    // wsClient.subscribeContractInfoStream('usdm');\n    // wsClient.subscribeContractInfoStream('coinm');\n  } catch (e) {\n    console.error('exception on subscribe attempt: ', e);\n  }\n})();\n",
                  "metadata": {}
                }
              ]
            },
            {
              "type": "folder",
              "name": "WS-API",
              "path": "examples/Binance/WebSockets/WS-API",
              "children": [
                {
                  "type": "file",
                  "name": "ws-api-client.ts",
                  "path": "examples/Binance/WebSockets/WS-API/ws-api-client.ts",
                  "code": "/* eslint-disable @typescript-eslint/no-unused-vars */\n\n// or\n\nimport { DefaultLogger, WebsocketAPIClient } from 'binance';\n\n/**\n * The WS API only works with an Ed25519 API key.\n *\n * Check the rest-private-ed25519.md in this folder for more guidance\n * on preparing this Ed25519 API key.\n */\n\nconst publicKey = `-----BEGIN PUBLIC KEY-----\nMCexampleQTxwLU9o=\n-----END PUBLIC KEY-----\n`;\n\nconst privateKey = `-----BEGIN PRIVATE KEY-----\nMC4CAQAexamplewqj5CzUuTy1\n-----END PRIVATE KEY-----\n`;\n\nconst key = process.env.API_KEY_COM;\nconst secret = process.env.API_SECRET_COM;\n\n// returned by binance, generated using the publicKey (above)\n// const key = 'BVv39ATnIme5TTZRcC3I04C3FqLVM7vCw3Hf7mMT7uu61nEZK8xV1V5dmhf9kifm';\n// Your Ed25519 private key is passed as the \"secret\"\n// const secret = privateKey;\n\n// function attachEventHandlers<TWSClient extends WebsocketClient>(\n//   wsClient: TWSClient,\n// ): void {\n//   /**\n//    * General event handlers for monitoring the WebsocketClient\n//    */\n//   wsClient.on('message', (data) => {\n//     // console.log('raw message received ', JSON.stringify(data));\n//   });\n//   wsClient.on('response', (data) => {\n//     // console.log('ws response: ', JSON.stringify(data));\n//   });\n//   wsClient.on('open', (data) => {\n//     console.log('ws connected', data.wsKey);\n//   });\n//   wsClient.on('reconnecting', ({ wsKey }) => {\n//     console.log('ws automatically reconnecting.... ', wsKey);\n//   });\n//   wsClient.on('reconnected', (data) => {\n//     console.log('ws has reconnected ', data?.wsKey);\n//   });\n//   wsClient.on('authenticated', (data) => {\n//     console.log('ws has authenticated ', data?.wsKey);\n//   });\n//   wsClient.on('exception', (data) => {\n//     console.error('ws exception: ', JSON.stringify(data));\n//   });\n// }\n\nasync function main() {\n  const customLogger = {\n    ...DefaultLogger,\n    // For a more detailed view of the WebsocketClient, enable the `trace` level by uncommenting the below line:\n    // trace: (...params) => console.log(new Date(), 'trace', ...params),\n  };\n\n  const wsClient = new WebsocketAPIClient(\n    {\n      api_key: key,\n      api_secret: secret,\n      beautify: true,\n\n      // Enforce testnet ws connections, regardless of supplied wsKey\n      // testnet: true,\n\n      // Note: unless you set this to false, the SDK will automatically call\n      // the `subscribeUserDataStream()` method again if reconnected (if you called it before):\n      // resubscribeUserDataStreamAfterReconnect: true,\n\n      // If you want your own event handlers instead of the default ones with logs, disable this setting and see the `attachEventHandlers` example below:\n      // attachEventListeners: false\n    },\n    customLogger,\n  );\n\n  // Optional, attach basic event handlers, so nothing is left unhandled\n  // attachEventHandlers(wsClient.getWSClient());\n\n  // Optional, if you see RECV Window errors, you can use this to manage time issues.\n  // ! However, make sure you sync your system clock first!\n  // https://github.com/tiagosiebler/awesome-crypto-examples/wiki/Timestamp-for-this-request-is-outside-of-the-recvWindow\n  // wsClient.setTimeOffsetMs(-5000);\n\n  // Optional. Can be used to prepare a connection before sending commands.\n  // Can be done as part of a bootstrapping workflow, to reduce initial latency when sending the first command\n  // await wsClient.getWSClient().connectWSAPI(WS_KEY_MAP.mainWSAPI);\n\n  try {\n    const response = await wsClient.getSpotSessionStatus();\n    console.log('getSessionStatus response: ', response);\n  } catch (e) {\n    console.log('getSessionStatus error: ', e);\n  }\n\n  try {\n    const response = await wsClient.getSpotServerTime();\n    console.log('getSpotServerTime response: ', response);\n  } catch (e) {\n    console.log('getSpotServerTime error: ', e);\n  }\n\n  try {\n    const response = await wsClient.getSpotExchangeInfo();\n    console.log('getSpotExchangeInfo response: ', response);\n  } catch (e) {\n    console.log('getSpotExchangeInfo error: ', e);\n  }\n\n  try {\n    const response = await wsClient.getSpotOrderBook({ symbol: 'BTCUSDT' });\n    console.log('getSpotOrderBook response: ', response);\n  } catch (e) {\n    console.log('getSpotOrderBook error: ', e);\n  }\n\n  try {\n    const response = await wsClient.getSpotHistoricalTrades({\n      symbol: 'BTCUSDT',\n      fromId: 0,\n      limit: 1,\n    });\n    console.log('getSpotHistoricalTrades response: ', response);\n  } catch (e) {\n    console.log('getSpotHistoricalTrades error: ', e);\n  }\n\n  // SPOT - Market data requests\n  try {\n    const response = await wsClient.getSpotRecentTrades({\n      symbol: 'BTCUSDT',\n      limit: 1,\n    });\n    console.log('getSpotRecentTrades response: ', response);\n  } catch (e) {\n    console.log('getSpotRecentTrades error: ', e);\n  }\n\n  try {\n    const response = await wsClient.getSpotAggregateTrades({\n      symbol: 'BNBBTC',\n      fromId: 50000000,\n      limit: 1,\n    });\n    console.log('getSpotAggregateTrades response: ', response);\n  } catch (e) {\n    console.log('getSpotAggregateTrades error: ', e);\n  }\n\n  try {\n    const response = await wsClient.getSpotKlines({\n      symbol: 'BNBBTC',\n      interval: '1h',\n      startTime: 1655969280000,\n      limit: 1,\n    });\n    console.log('getSpotKlines response: ', response);\n  } catch (e) {\n    console.log('getSpotKlines error: ', e);\n  }\n\n  try {\n    const response = await wsClient.getSpotUIKlines({\n      symbol: 'BNBBTC',\n      interval: '1h',\n      startTime: 1655969280000,\n      limit: 1,\n    });\n    console.log('getSpotUIKlines response: ', response);\n  } catch (e) {\n    console.log('getSpotUIKlines error: ', e);\n  }\n\n  try {\n    const response = await wsClient.getSpotAveragePrice({\n      symbol: 'BTCUSDT',\n    });\n    console.log('getSpotAveragePrice response: ', response);\n  } catch (e) {\n    console.log('getSpotAveragePrice error: ', e);\n  }\n\n  try {\n    const response = await wsClient.getSpot24hrTicker({\n      symbol: 'BTCUSDT',\n    });\n    console.log('getSpot24hrTicker response: ', response);\n  } catch (e) {\n    console.log('getSpot24hrTicker error: ', e);\n  }\n\n  try {\n    const response = await wsClient.getSpotTradingDayTicker({\n      symbol: 'BTCUSDT',\n    });\n    console.log('getSpotTradingDayTicker response: ', response);\n  } catch (e) {\n    console.log('getSpotTradingDayTicker error: ', e);\n  }\n\n  try {\n    const response = await wsClient.getSpotTicker({\n      symbol: 'BTCUSDT',\n    });\n    console.log('getSpotTicker response: ', response);\n  } catch (e) {\n    console.log('getSpotTicker error: ', e);\n  }\n\n  try {\n    const response = await wsClient.getSpotSymbolPriceTicker({\n      symbol: 'BTCUSDT',\n    });\n    console.log('getSpotSymbolPriceTicker response: ', response);\n  } catch (e) {\n    console.log('getSpotSymbolPriceTicker error: ', e);\n  }\n\n  try {\n    const response = await wsClient.getSpotSymbolOrderBookTicker({\n      symbol: 'BTCUSDT',\n    });\n    console.log('getSpotSymbolOrderBookTicker response: ', response);\n  } catch (e) {\n    console.log('getSpotSymbolOrderBookTicker error: ', e);\n  }\n\n  // SPOT - Trading requests\n  try {\n    const response = await wsClient.submitNewSpotOrder({\n      symbol: 'BTCUSDT',\n      side: 'SELL',\n      type: 'LIMIT',\n      timeInForce: 'GTC',\n      price: '23416.10000000',\n      quantity: '0.00847000',\n    });\n    console.log('submitNewSpotOrder response: ', response);\n  } catch (e) {\n    console.log('submitNewSpotOrder error: ', e);\n  }\n\n  try {\n    const response = await wsClient.testSpotOrder({\n      symbol: 'BTCUSDT',\n      side: 'SELL',\n      type: 'LIMIT',\n      timeInForce: 'GTC',\n      price: '23416.1',\n      quantity: '0.001',\n      timestamp: Date.now(),\n    });\n    console.log('testSpotOrder response: ', response);\n  } catch (e) {\n    console.log('testSpotOrder error: ', e);\n  }\n\n  try {\n    const response = await wsClient.getSpotOrderStatus({\n      symbol: 'BTCUSDT',\n      orderId: 12345678,\n      timestamp: Date.now(),\n    });\n    console.log('getSpotOrderStatus response: ', response);\n  } catch (e) {\n    console.log('getSpotOrderStatus error: ', e);\n  }\n\n  try {\n    const response = await wsClient.cancelSpotOrder({\n      symbol: 'BTCUSDT',\n      orderId: 12345678,\n      timestamp: Date.now(),\n    });\n    console.log('cancelSpotOrder response: ', response);\n  } catch (e) {\n    console.log('cancelSpotOrder error: ', e);\n  }\n\n  try {\n    const response = await wsClient.cancelReplaceSpotOrder({\n      symbol: 'BTCUSDT',\n      cancelReplaceMode: 'ALLOW_FAILURE',\n      cancelOrigClientOrderId: '4d96324ff9d44481926157',\n      side: 'SELL',\n      type: 'LIMIT',\n      timeInForce: 'GTC',\n      price: '23416.10000000',\n      quantity: '0.00847000',\n      timestamp: Date.now(),\n    });\n    console.log('cancelReplaceSpotOrder response: ', response);\n  } catch (e) {\n    console.log('cancelReplaceSpotOrder error: ', e);\n  }\n\n  try {\n    const response = await wsClient.amendSpotOrderKeepPriority({\n      newQty: '5',\n      origClientOrderId: 'my_test_order1',\n      recvWindow: 5000,\n      symbol: 'BTCUSDT',\n      timestamp: Date.now(),\n    });\n    console.log('amendSpotOrderKeepPriority response: ', response);\n  } catch (e) {\n    console.log('amendSpotOrderKeepPriority error: ', e);\n  }\n\n  try {\n    const response = await wsClient.getSpotOpenOrders({\n      symbol: 'BTCUSDT',\n      timestamp: Date.now(),\n    });\n    console.log('getSpotOpenOrders response: ', response);\n  } catch (e) {\n    console.log('getSpotOpenOrders error: ', e);\n  }\n\n  try {\n    const response = await wsClient.cancelAllSpotOpenOrders({\n      symbol: 'BTCUSDT',\n      timestamp: Date.now(),\n    });\n    console.log('cancelAllSpotOpenOrders response: ', response);\n  } catch (e) {\n    console.log('cancelAllSpotOpenOrders error: ', e);\n  }\n\n  try {\n    const response = await wsClient.placeSpotOrderList({\n      symbol: 'BTCUSDT',\n      side: 'SELL',\n      price: '23420.00000000',\n      quantity: '0.00650000',\n      stopPrice: '23410.00000000',\n      stopLimitPrice: '23405.00000000',\n      stopLimitTimeInForce: 'GTC',\n      newOrderRespType: 'RESULT',\n      timestamp: Date.now(),\n    });\n    console.log('placeSpotOrderList response: ', response);\n  } catch (e) {\n    console.log('placeSpotOrderList error: ', e);\n  }\n\n  try {\n    const response = await wsClient.placeSpotOCOOrderList({\n      symbol: 'LTCBNB',\n      side: 'BUY',\n      quantity: 1,\n      timestamp: 1711062760647,\n      aboveType: 'STOP_LOSS_LIMIT',\n      abovePrice: '1.5',\n      aboveStopPrice: '1.50000001',\n      aboveTimeInForce: 'GTC',\n      belowType: 'LIMIT_MAKER',\n      belowPrice: '1.49999999',\n    });\n    console.log('placeSpotOCOOrderList response: ', response);\n  } catch (e) {\n    console.log('placeSpotOCOOrderList error: ', e);\n  }\n\n  try {\n    const response = await wsClient.placeSpotOTOOrderList({\n      pendingQuantity: 1,\n      pendingSide: 'BUY',\n      pendingType: 'MARKET',\n      symbol: 'LTCBNB',\n      recvWindow: 5000,\n      timestamp: 1712544395951,\n      workingPrice: 1,\n      workingQuantity: 1,\n      workingSide: 'SELL',\n      workingTimeInForce: 'GTC',\n      workingType: 'LIMIT',\n    });\n    console.log('placeSpotOTOOrderList response: ', response);\n  } catch (e) {\n    console.log('placeSpotOTOOrderList error: ', e);\n  }\n\n  try {\n    const response = await wsClient.placeSpotOTOCOOrderList({\n      pendingQuantity: 5,\n      pendingSide: 'SELL',\n      pendingBelowPrice: 5,\n      pendingBelowType: 'LIMIT_MAKER',\n      pendingAboveStopPrice: 0.5,\n      pendingAboveType: 'STOP_LOSS',\n      symbol: 'LTCBNB',\n      recvWindow: 5000,\n      timestamp: Date.now(),\n      workingPrice: 1.5,\n      workingQuantity: 1,\n      workingSide: 'BUY',\n      workingTimeInForce: 'GTC',\n      workingType: 'LIMIT',\n    });\n    console.log('placeSpotOTOCOOrderList response: ', response);\n  } catch (e) {\n    console.log('placeSpotOTOCOOrderList error: ', e);\n  }\n\n  try {\n    const response = await wsClient.getSpotOrderListStatus({\n      orderListId: 12345678,\n      timestamp: Date.now(),\n    });\n    console.log('getSpotOrderListStatus response: ', response);\n  } catch (e) {\n    console.log('getSpotOrderListStatus error: ', e);\n  }\n\n  try {\n    const response = await wsClient.cancelSpotOrderList({\n      symbol: 'BTCUSDT',\n      orderListId: 1274512,\n      timestamp: Date.now(),\n    });\n    console.log('cancelSpotOrderList response: ', response);\n  } catch (e) {\n    console.log('cancelSpotOrderList error: ', e);\n  }\n\n  try {\n    const response = await wsClient.getSpotOpenOrderLists({\n      timestamp: Date.now(),\n    });\n    console.log('getSpotOpenOrderLists response: ', response);\n  } catch (e) {\n    console.log('getSpotOpenOrderLists error: ', e);\n  }\n\n  try {\n    const response = await wsClient.placeSpotSOROrder({\n      symbol: 'BTCUSDT',\n      side: 'BUY',\n      type: 'LIMIT',\n      quantity: 0.5,\n      timeInForce: 'GTC',\n      price: 31000,\n      timestamp: Date.now(),\n    });\n    console.log('placeSpotSOROrder response: ', response);\n  } catch (e) {\n    console.log('placeSpotSOROrder error: ', e);\n  }\n\n  try {\n    const response = await wsClient.testSpotSOROrder({\n      symbol: 'BTCUSDT',\n      side: 'BUY',\n      type: 'LIMIT',\n      quantity: 0.1,\n      timeInForce: 'GTC',\n      price: 0.1,\n      timestamp: Date.now(),\n    });\n    console.log('testSpotSOROrder response: ', response);\n  } catch (e) {\n    console.log('testSpotSOROrder error: ', e);\n  }\n\n  // SPOT - Account requests\n  try {\n    const response = await wsClient.getSpotAccountInformation({\n      timestamp: Date.now(),\n    });\n    console.log('getSpotAccountInformation response: ', response);\n  } catch (e) {\n    console.log('getSpotAccountInformation error: ', e);\n  }\n\n  try {\n    const response = await wsClient.getSpotOrderRateLimits({\n      timestamp: Date.now(),\n    });\n    console.log('getSpotOrderRateLimits response: ', response);\n  } catch (e) {\n    console.log('getSpotOrderRateLimits error: ', e);\n  }\n\n  try {\n    const response = await wsClient.getSpotAllOrders({\n      symbol: 'BTCUSDT',\n      limit: 10,\n    });\n    console.log('getSpotAllOrders response: ', response);\n  } catch (e) {\n    console.log('getSpotAllOrders error: ', e);\n  }\n\n  try {\n    const response = await wsClient.getSpotAllOrderLists({\n      limit: 10,\n    });\n    console.log('getSpotAllOrderLists response: ', response);\n  } catch (e) {\n    console.log('getSpotAllOrderLists error: ', e);\n  }\n\n  try {\n    const response = await wsClient.getSpotMyTrades({\n      symbol: 'BTCUSDT',\n      limit: 10,\n    });\n    console.log('getSpotMyTrades response: ', response);\n  } catch (e) {\n    console.log('getSpotMyTrades error: ', e);\n  }\n\n  try {\n    const response = await wsClient.getSpotPreventedMatches({\n      symbol: 'BTCUSDT',\n    });\n    console.log('getSpotPreventedMatches response: ', response);\n  } catch (e) {\n    console.log('getSpotPreventedMatches error: ', e);\n  }\n\n  try {\n    const response = await wsClient.getSpotAllocations({\n      symbol: 'BTCUSDT',\n      orderId: 12345678,\n    });\n    console.log('getSpotAllocations response: ', response);\n  } catch (e) {\n    console.log('getSpotAllocations error: ', e);\n  }\n\n  try {\n    const response = await wsClient.getSpotAccountCommission({\n      symbol: 'BTCUSDT',\n    });\n    console.log('getSpotAccountCommission response: ', response);\n  } catch (e) {\n    console.log('getSpotAccountCommission error: ', e);\n  }\n\n  // FUTURES - Market data requests\n  try {\n    const response = await wsClient.getFuturesOrderBook({\n      symbol: 'BTCUSDT',\n    });\n    console.log('getFuturesOrderBook response: ', response);\n  } catch (e) {\n    console.log('getFuturesOrderBook error: ', e);\n  }\n\n  try {\n    const response = await wsClient.getFuturesSymbolPriceTicker({\n      symbol: 'BTCUSDT',\n    });\n    console.log('getFuturesSymbolPriceTicker response: ', response);\n  } catch (e) {\n    console.log('getFuturesSymbolPriceTicker error: ', e);\n  }\n\n  try {\n    const response = await wsClient.getFuturesSymbolOrderBookTicker({\n      symbol: 'BTCUSDT',\n    });\n    console.log('getFuturesSymbolOrderBookTicker response: ', response);\n  } catch (e) {\n    console.log('getFuturesSymbolOrderBookTicker error: ', e);\n  }\n\n  // FUTURES - Trading requests\n  try {\n    const response = await wsClient.submitNewFuturesOrder('usdm', {\n      positionSide: 'BOTH',\n      price: '43187.00',\n      quantity: 0.1,\n      side: 'BUY',\n      symbol: 'BTCUSDT',\n      timeInForce: 'GTC',\n      timestamp: Date.now(),\n      type: 'LIMIT',\n    });\n    console.log('submitNewFuturesOrder response: ', response);\n  } catch (e) {\n    console.log('submitNewFuturesOrder error: ', e);\n  }\n\n  try {\n    const response = await wsClient.modifyFuturesOrder('usdm', {\n      orderId: 328971409,\n      origType: 'LIMIT',\n      positionSide: 'SHORT',\n      price: '43769.1',\n      priceMatch: 'NONE',\n      quantity: '0.11',\n      side: 'SELL',\n      symbol: 'BTCUSDT',\n      timestamp: Date.now(),\n    });\n    console.log('modifyFuturesOrder response: ', response);\n  } catch (e) {\n    console.log('modifyFuturesOrder error: ', e);\n  }\n\n  try {\n    const response = await wsClient.cancelFuturesOrder('usdm', {\n      symbol: 'BTCUSDT',\n      orderId: 328971409,\n      timestamp: Date.now(),\n    });\n    console.log('cancelFuturesOrder response: ', response);\n  } catch (e) {\n    console.log('cancelFuturesOrder error: ', e);\n  }\n\n  try {\n    const response = await wsClient.getFuturesOrderStatus('usdm', {\n      orderId: 328999071,\n      symbol: 'BTCUSDT',\n      timestamp: Date.now(),\n    });\n    console.log('getFuturesOrderStatus response: ', response);\n  } catch (e) {\n    console.log('getFuturesOrderStatus error: ', e);\n  }\n\n  try {\n    const response = await wsClient.getFuturesPositionV2({\n      timestamp: Date.now(),\n    });\n    console.log('getFuturesPositionV2 response: ', response);\n  } catch (e) {\n    console.log('getFuturesPositionV2 error: ', e);\n  }\n\n  try {\n    const response = await wsClient.getFuturesPosition('usdm', {\n      timestamp: Date.now(),\n    });\n    console.log('getFuturesPosition response: ', response);\n  } catch (e) {\n    console.log('getFuturesPosition error: ', e);\n  }\n\n  // FUTURES - Account requests\n  try {\n    const response = await wsClient.getFuturesAccountBalanceV2({\n      timestamp: Date.now(),\n    });\n    console.log('getFuturesAccountBalanceV2 response: ', response);\n  } catch (e) {\n    console.log('getFuturesAccountBalanceV2 error: ', e);\n  }\n\n  try {\n    const response = await wsClient.getFuturesAccountBalance('usdm', {\n      timestamp: Date.now(),\n    });\n    console.log('getFuturesAccountBalance response: ', response);\n  } catch (e) {\n    console.log('getFuturesAccountBalance error: ', e);\n  }\n\n  try {\n    const response = await wsClient.getFuturesAccountStatusV2({\n      timestamp: Date.now(),\n    });\n    console.log('getFuturesAccountStatusV2 response: ', response);\n  } catch (e) {\n    console.log('getFuturesAccountStatusV2 error: ', e);\n  }\n\n  try {\n    const response = await wsClient.getFuturesAccountStatus('usdm', {\n      timestamp: Date.now(),\n    });\n    console.log('getFuturesAccountStatus response: ', response);\n  } catch (e) {\n    console.log('getFuturesAccountStatus error: ', e);\n  }\n\n  try {\n    const response = await wsClient.submitNewFuturesAlgoOrder({\n      algoType: 'CONDITIONAL',\n      symbol: 'BTCUSDT',\n      side: 'BUY',\n      type: 'STOP',\n      timeInForce: 'GTC',\n      price: '100000.10000000',\n      stopPrice: '100000.10000000',\n      quantity: '0.00847000',\n      timestamp: Date.now(),\n    });\n    console.log('submitNewFuturesAlgoOrder response: ', response);\n  } catch (e) {\n    console.log('submitNewFuturesAlgoOrder error: ', e);\n  }\n\n  try {\n    const response = await wsClient.cancelFuturesAlgoOrder({\n      algoid: 1028312903,\n      timestamp: Date.now(),\n    });\n    console.log('cancelFuturesAlgoOrder response: ', response);\n  } catch (e) {\n    console.log('cancelFuturesAlgoOrder error: ', e);\n  }\n}\n\n// Start executing the example workflow\nmain();\n",
                  "metadata": {}
                },
                {
                  "type": "file",
                  "name": "ws-api-raw-promises.ts",
                  "path": "examples/Binance/WebSockets/WS-API/ws-api-raw-promises.ts",
                  "code": "/* eslint-disable @typescript-eslint/no-unused-vars */\nimport {\n  DefaultLogger,\n  WebsocketClient,\n  WS_KEY_MAP,\n  WSAPIWsKey,\n} from 'binance';\n\nconst logger = {\n  ...DefaultLogger,\n  // For a more detailed view of the WebsocketClient, enable the `trace` level by uncommenting the below line:\n  trace: (...params: any[]) => console.log(new Date(), 'trace', ...params),\n};\n\nlet key = process.env.API_KEY_COM;\nlet secret = process.env.API_SECRET_COM;\n\nconst privateKey = `-----BEGIN PRIVATE KEY-----\nMC4CAQAwasdfasfasf4VI6HF5a1mmn6Xwbbwqj5CzUuTy1\n-----END PRIVATE KEY-----\n`;\n\nconst publicKey = `-----BEGIN PUBLIC KEY-----\nMCowBQYDK2Vasdfasfasfasfasfn38QTxwLU9o=\n-----END PUBLIC KEY-----\n`;\n\nkey = 'TQpJN8MYasdfdasfadsfasf7DoCxTjQEbrobdG';\nsecret = privateKey;\n\nconst wsClient = new WebsocketClient(\n  {\n    api_key: key,\n    api_secret: secret,\n    beautify: true,\n    // testnet: true,\n  },\n  logger, // Optional: inject a custom logger\n);\n\n/**\n * General event handlers for monitoring the WebsocketClient\n */\nwsClient.on('message', (data) => {\n  console.log('raw message received ', JSON.stringify(data));\n});\nwsClient.on('response', (data) => {\n  // WS API responses can be processed here too, but that is optional\n  // console.log('ws response: ', JSON.stringify(data));\n});\nwsClient.on('open', (data) => {\n  console.log('ws connected', data.wsKey);\n});\nwsClient.on('reconnecting', ({ wsKey }) => {\n  console.log('ws automatically reconnecting.... ', wsKey);\n});\nwsClient.on('reconnected', (data) => {\n  console.log('ws has reconnected ', data?.wsKey);\n});\nwsClient.on('authenticated', (data) => {\n  console.log('ws has authenticated ', data?.wsKey);\n});\nwsClient.on('exception', (data) => {\n  console.error('ws exception: ', JSON.stringify(data));\n});\n\nasync function main() {\n  /**\n   *\n   * If you haven't connected yet, the WebsocketClient will automatically connect and authenticate you as soon as you send\n   * your first command. That connection will then be reused for every command you send, unless the connection drops - then\n   * it will automatically be replaced with a healthy connection.\n   *\n   * This \"not connected yet\" scenario can add an initial delay to your first command. If you want to prepare a connection\n   * in advance, you can ask the WebsocketClient to prepare it before you start submitting commands (using the connectWSAPI() method shown below). This is optional.\n   *\n   */\n\n  /**\n   * Websockets (with their unique URLs) are tracked using the concept of a \"WsKey\".\n   *\n   * This WsKey identifies the \"main\" WS API connection URL (e.g. for spot & margin markets):\n   * wss://ws-api.binance.com:443/ws-api/v3\n   *\n   * Other notable keys:\n   * - mainWSAPI2: alternative for \"main\"\n   * - mainWSAPITestnet: \"main\" testnet\n   * - usdmWSAPI: usdm futures\n   * - usdmWSAPITestnet: usdm futures testnet\n   * - coinmWSAPI: coinm futures\n   * - coinmWSAPITestnet: coinm futures testnet\n   */\n\n  // Note: if you set \"testnet: true\" in the config, this will automatically resolve to WS_KEY_MAP.mainWSAPITestnet (you can keep using mainWSAPI).\n  const WS_API_WS_KEY: WSAPIWsKey = WS_KEY_MAP.mainWSAPI;\n\n  // Optional, if you see RECV Window errors, you can use this to manage time issues. However, make sure you sync your system clock first!\n  // https://github.com/tiagosiebler/awesome-crypto-examples/wiki/Timestamp-for-this-request-is-outside-of-the-recvWindow\n  // wsClient.setTimeOffsetMs(-5000);\n\n  // Optional, see above. Can be used to prepare a connection before sending commands. This is not required and will happen automatically\n  // await wsClient.connectWSAPI(WS_API_WS_KEY);\n\n  try {\n    const wsAPIResponse = await wsClient.sendWSAPIRequest(\n      WS_API_WS_KEY,\n      'ping',\n    );\n    console.log(new Date(), 'wsapi PING: ', wsAPIResponse);\n  } catch (e) {\n    console.log(new Date(), 'wsapi PING error:', e);\n  }\n\n  try {\n    const wsAPIResponse = await wsClient.sendWSAPIRequest(\n      WS_API_WS_KEY,\n      'session.status',\n    );\n    console.log(new Date(), 'wsapi sessionStatus: ', wsAPIResponse, {\n      authSince: wsAPIResponse.result.authorizedSince,\n    });\n  } catch (e) {\n    console.log(new Date(), 'wsapi sessionStatus error:', e);\n  }\n\n  try {\n    const wsAPIResponse = await wsClient.sendWSAPIRequest(\n      WS_API_WS_KEY,\n      'exchangeInfo',\n    );\n    console.log(new Date(), 'wsapi exchangeInfo: ', wsAPIResponse, {\n      // rateLimits: wsAPIResponse.result.rateLimits,\n      // symbols: wsAPIResponse.result.symbols,\n    });\n  } catch (e) {\n    console.log(new Date(), 'wsapi exchangeInfo error:', e);\n  }\n\n  try {\n    const wsAPIResponse = await wsClient.sendWSAPIRequest(\n      WS_API_WS_KEY,\n      'order.place',\n      {\n        symbol: 'BTCUSDT',\n        type: 'MARKET',\n        side: 'SELL',\n        quantity: 10,\n        timestamp: Date.now(),\n      },\n    );\n    console.log(new Date(), 'wsapi orderPlace: ', wsAPIResponse, {});\n  } catch (e) {\n    console.log(new Date(), 'wsapi orderPlace error:', e);\n  }\n}\n\n// Start executing the example workflow\nmain().catch((e) => {\n  console.log('mainError', e);\n});\n",
                  "metadata": {}
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "type": "folder",
      "name": "Bitget",
      "path": "examples/Bitget",
      "children": [
        {
          "type": "folder",
          "name": "Auth",
          "path": "examples/Bitget/Auth",
          "children": [
            {
              "type": "file",
              "name": "fasterHmacSign.ts",
              "path": "examples/Bitget/Auth/fasterHmacSign.ts",
              "code": "import { DefaultLogger, RestClientV3, WebsocketClientV3 } from 'bitget-api';\nimport { createHmac } from 'crypto';\n\n// import { DefaultLogger, RestClientV3, WebsocketClientV3 } from 'bitget-api';\n\n/**\n * Injecting a custom signMessage function.\n *\n * As of version 3.0.0 of the bitget-api Node.js/TypeScript/JavaScript\n * SDK for Bitget, the SDK uses the Web Crypto API for signing requests.\n * While it is compatible with Node and Browser environments, it is\n * slightly slower than using Node's native crypto module (only\n * available in backend Node environments).\n *\n * For latency sensitive users, you can inject the previous node crypto sign\n * method (or your own even faster implementation), if this change affects you.\n *\n * This example demonstrates how to inject a custom sign function, to achieve\n * the same peformance as seen before the Web Crypto API was introduced.\n *\n * For context on standard usage, the \"signMessage\" function is used:\n * - During every single API call\n * - After opening a new private WebSocket connection\n */\n\nconst apiKey = process.env.API_KEY_COM;\nconst apiSecret = process.env.API_SECRET_COM;\nconst apiPass = process.env.API_PASS_COM;\n\nconst restClient = new RestClientV3({\n  apiKey: apiKey,\n  apiSecret: apiSecret,\n  apiPass: apiPass,\n  /**\n   * Set this to true to enable demo trading:\n   */\n  demoTrading: true,\n  /**\n   * Overkill in almost every case, but if you need any optimisation available,\n   * you can inject a faster sign mechanism such as node's native createHmac:\n   */\n  customSignMessageFn: async (message, secret) => {\n    return createHmac('sha256', secret).update(message).digest('hex');\n  },\n});\n\n// Optional, uncomment the \"trace\" override to log a lot more info about what the WS client is doing\nconst customLogger = {\n  ...DefaultLogger,\n  // trace: (...params) => console.log('trace', ...params),\n};\n\nconst wsClient = new WebsocketClientV3(\n  {\n    apiKey: apiKey,\n    apiSecret: apiSecret,\n    apiPass: apiPass,\n    /**\n     * Set this to true to enable demo trading for the private account data WS\n     * Topics: order,execution,position,wallet,greeks\n     */\n    demoTrading: true,\n    /**\n     * Overkill in almost every case, but if you need any optimisation available,\n     * you can inject a faster sign mechanism such as node's native createHmac:\n     */\n    customSignMessageFn: async (message, secret) => {\n      return createHmac('sha256', secret).update(message).digest('hex');\n    },\n  },\n  customLogger,\n);\n\nfunction setWsClientEventListeners(\n  websocketClient: WebsocketClientV3,\n  accountRef: string,\n): Promise<void> {\n  return new Promise((resolve) => {\n    websocketClient.on('update', (data) => {\n      console.log(new Date(), accountRef, 'data ', JSON.stringify(data));\n      // console.log('raw message received ', JSON.stringify(data, null, 2));\n    });\n\n    websocketClient.on('open', (data) => {\n      console.log(\n        new Date(),\n        accountRef,\n        'connection opened open:',\n        data.wsKey,\n      );\n    });\n    websocketClient.on('response', (data) => {\n      console.log(\n        new Date(),\n        accountRef,\n        'log response: ',\n        JSON.stringify(data, null, 2),\n      );\n\n      if (typeof data.req_id === 'string') {\n        const topics = data.req_id.split(',');\n        if (topics.length) {\n          console.log(new Date(), accountRef, 'Subscribed to topics: ', topics);\n          return resolve();\n        }\n      }\n    });\n    websocketClient.on('reconnect', ({ wsKey }) => {\n      console.log(\n        new Date(),\n        accountRef,\n        'ws automatically reconnecting.... ',\n        wsKey,\n      );\n    });\n    websocketClient.on('reconnected', (data) => {\n      console.log(new Date(), accountRef, 'ws has reconnected ', data?.wsKey);\n    });\n    websocketClient.on('exception', (data) => {\n      console.error(new Date(), accountRef, 'ws exception: ', data);\n    });\n  });\n}\n\n(async () => {\n  try {\n    const onSubscribed = setWsClientEventListeners(wsClient, 'demoAcc');\n\n    wsClient.subscribe(['position', 'account', 'order'], 'v3Private');\n\n    // Simple promise to ensure we're subscribed before trying anything else\n    await onSubscribed;\n\n    // Start trading\n    const balResponse1 = await restClient.getBalances();\n    console.log('balResponse1: ', JSON.stringify(balResponse1, null, 2));\n  } catch (e) {\n    console.error('request failed: ', e);\n  }\n})();\n",
              "metadata": {}
            },
            {
              "type": "file",
              "name": "rest-private-rsa.ts",
              "path": "examples/Bitget/Auth/rest-private-rsa.ts",
              "code": "import { RestClientV2, RestClientV3 } from 'bitget-api';\n\n// Import frmo NPM:\n\n// or if you prefer require:\n\n// Received after creating a new API key with a self-generated RSA public key on Bitget\nconst API_KEY = 'bg_0866563123123123123f567e83e52fd';\n\n// The self-generated RSA private key, this is never directly given to Bitget, but used to generate a signature\n// Note: this MUST include the \"BEGIN PRIVATE KEY\" header so that the SDK understands this is RSA auth\nconst rsaPrivateKey = `\n-----BEGIN PRIVATE KEY-----\nMIIJQQIBADANBgkqhkiG9w0BAQEFAASCCSswggknAgEAAoICAQC4kNgO71O0xkuH\nFjHnr5pimpEeiGPAtDTAeJoS55+kVrh3ThHsm0ARf36zimU\ngwrCWAnKqPlbqzWzs9mH9JvZWrEaOgWy\n8wMSJ21vtz1rRJhfaUUsOC1KLoWyvzqWW44zKaxoKSqCUMJqDbxIq7RjGlmc8KGJ\nscFWRSdfGEEpvqLlpTLoEtWHZP0pUUamSWrH/IgieFFhKaOPvmED24DJAlqSeEFw\nz7TW4dfWPRgjCRu4AAfgCtjb+3/7ONeQfx5XFvKFM7VNi/9sRh+alRqpzKrlI\n79bM1p/egrC4c8KUqrNk2s5c3HIU......THISISANEXAMPLE\n-----END PRIVATE KEY-----\n`;\n\n// This is set by you when registering your RSA API key in Bitget's website.\nconst API_PASS = 'TestingRSA';\n\nconst client = new RestClientV2({\n  apiKey: API_KEY,\n  apiSecret: rsaPrivateKey,\n  apiPass: API_PASS,\n});\n\nconst clientV3 = new RestClientV3({\n  apiKey: API_KEY,\n  apiSecret: rsaPrivateKey,\n  apiPass: API_PASS,\n});\n\n// const wsClient = new WebsocketClientV2({\n//   apiKey: API_KEY,\n//   apiSecret: rsaPrivateKey,\n//   apiPass: API_PASS,\n// });\n\n(async () => {\n  try {\n    console.log('V2 private api call result: ', await client.getBalances());\n  } catch (e) {\n    console.error('V2 request failed: ', e);\n  }\n  try {\n    console.log('V3 private api call result: ', await clientV3.getBalances());\n  } catch (e) {\n    console.error('V3 request failed: ', e);\n  }\n})();\n",
              "metadata": {}
            }
          ]
        },
        {
          "type": "folder",
          "name": "V2 - Classic",
          "path": "examples/Bitget/V2 - Classic",
          "children": [
            {
              "type": "folder",
              "name": "Rest",
              "path": "examples/Bitget/V2 - Classic/Rest",
              "children": [
                {
                  "type": "file",
                  "name": "rest-private-futures.ts",
                  "path": "examples/Bitget/V2 - Classic/Rest/rest-private-futures.ts",
                  "code": "import { RestClientV2 } from 'bitget-api';\n\n// read from environmental variables\nconst API_KEY = process.env.API_KEY_COM;\nconst API_SECRET = process.env.API_SECRET_COM;\nconst API_PASS = process.env.API_PASS_COM;\n\n// If running from CLI in unix, you can pass env vars as such:\n// API_KEY_COM='lkm12n3-2ba3-1mxf-fn13-lkm12n3a' API_SECRET_COM='035B2B9637E1BDFFEE2646BFBDDB8CE4' API_PASSPHRASE_COM='ComplexPa$$!23$5^' ts-node examples/rest-private-futures.ts\n\n// note the single quotes, preventing special characters such as $ from being incorrectly passed\n\nconst client = new RestClientV2({\n  apiKey: API_KEY,\n  apiSecret: API_SECRET,\n  apiPass: API_PASS,\n  // apiKey: 'apiKeyHere',\n  // apiSecret: 'apiSecretHere',\n  // apiPass: 'apiPassHere',\n});\n\n/** This is a simple script wrapped in a immediately invoked function expression, designed to check for any available BTC balance and immediately sell the full amount for USDT */\n(async () => {\n  try {\n    const now = new Date();\n    const fromTime = new Date(now.getTime() - 24 * 60 * 60 * 1000);\n\n    console.log(\n      await client.getFuturesAccountBills({\n        productType: 'USDT-FUTURES',\n        startTime: fromTime.getTime() + '', // should be sent as a string\n        endTime: now.getTime() + '', // should be sent as a string\n        limit: '100',\n      }),\n    );\n  } catch (e) {\n    console.error('request failed: ', e);\n  }\n})();\n",
                  "metadata": {}
                },
                {
                  "type": "file",
                  "name": "rest-private-spot.ts",
                  "path": "examples/Bitget/V2 - Classic/Rest/rest-private-spot.ts",
                  "code": "import { RestClientV2 } from 'bitget-api';\n\n// read from environmental variables\nconst API_KEY = process.env.API_KEY_COM;\nconst API_SECRET = process.env.API_SECRET_COM;\nconst API_PASS = process.env.API_PASS_COM;\n// If running from CLI in unix, you can pass env vars as such:\n// API_KEY_COM='lkm12n3-2ba3-1mxf-fn13-lkm12n3a' API_SECRET_COM='035B2B9637E1BDFFEE2646BFBDDB8CE4' API_PASSPHRASE_COM='ComplexPa$$!23$5^' ts-node examples/rest-private-spot.ts\n\n// note the single quotes, preventing special characters such as $ from being incorrectly passed\n\nconst client = new RestClientV2({\n  apiKey: API_KEY,\n  apiSecret: API_SECRET,\n  apiPass: API_PASS,\n  // apiKey: 'apiKeyHere',\n  // apiSecret: 'apiSecretHere',\n  // apiPass: 'apiPassHere',\n});\n\n/** This is a simple script wrapped in a immediately invoked function expression, designed to check for any available BTC balance and immediately sell the full amount for USDT */\n(async () => {\n  try {\n    console.log(await client.getSpotAccount());\n  } catch (e) {\n    console.error('request failed: ', e);\n  }\n})();\n",
                  "metadata": {}
                },
                {
                  "type": "file",
                  "name": "rest-public-futures.ts",
                  "path": "examples/Bitget/V2 - Classic/Rest/rest-public-futures.ts",
                  "code": "import { RestClientV2 } from 'bitget-api';\n\nconst restClient = new RestClientV2();\n\nconst symbol = 'BTCUSDT';\n\n(async () => {\n  try {\n    // Fetch the last 1000 1min candles for a symbol\n    const timestampNow = Date.now();\n    const msPerCandle = 60 * 1000; // 60 seconds x 1000\n    const candlesToFetch = 1000;\n    const msFor1kCandles = candlesToFetch * msPerCandle;\n    const startTime = timestampNow - msFor1kCandles;\n\n    const response = await restClient.getFuturesCandles({\n      symbol,\n      productType: 'USDT-FUTURES',\n      granularity: '1m',\n      startTime: startTime.toString(),\n      endTime: timestampNow.toString(),\n      limit: candlesToFetch.toString(),\n    });\n\n    console.table(response.data);\n\n    console.log('getCandles returned ' + response.data.length + ' candles');\n  } catch (e) {\n    console.error('request failed: ', e);\n  }\n})();\n",
                  "metadata": {}
                },
                {
                  "type": "file",
                  "name": "rest-public-spot.ts",
                  "path": "examples/Bitget/V2 - Classic/Rest/rest-public-spot.ts",
                  "code": "import { RestClientV2 } from 'bitget-api';\n\nconst restClient = new RestClientV2();\n\n(async () => {\n  try {\n    const response = await restClient.getSpotCandles({\n      symbol: 'BTCUSDT',\n      granularity: '1min',\n      limit: '1000',\n    });\n\n    console.table(response.data);\n    console.log('getCandles: ', response.data.length);\n  } catch (e) {\n    console.error('request failed: ', e);\n  }\n})();\n",
                  "metadata": {}
                },
                {
                  "type": "file",
                  "name": "rest-trade-futures.ts",
                  "path": "examples/Bitget/V2 - Classic/Rest/rest-trade-futures.ts",
                  "code": "import {\n  FuturesPlaceOrderRequestV2,\n  RestClientV2,\n  WebsocketClientV2,\n} from 'bitget-api';\n\n// read from environmental variables\nconst API_KEY = process.env.API_KEY_COM;\nconst API_SECRET = process.env.API_SECRET_COM;\nconst API_PASS = process.env.API_PASS_COM;\n\n// If running from CLI in unix, you can pass env vars as such:\n// API_KEY_COM='lkm12n3-2ba3-1mxf-fn13-lkm12n3a' API_SECRET_COM='035B2B9637E1BDFFEE2646BFBDDB8CE4' API_PASSPHRASE_COM='ComplexPa$$!23$5^' ts-node examples/rest-trade-futures.ts\n\n// note the single quotes, preventing special characters such as $ from being incorrectly passed\n\nconst client = new RestClientV2({\n  apiKey: API_KEY,\n  apiSecret: API_SECRET,\n  apiPass: API_PASS,\n  // apiKey: 'apiKeyHere',\n  // apiSecret: 'apiSecretHere',\n  // apiPass: 'apiPassHere',\n});\n\nconst wsClient = new WebsocketClientV2({\n  apiKey: API_KEY,\n  apiSecret: API_SECRET,\n  apiPass: API_PASS,\n});\n\nfunction logWSEvent(type: string, data: any) {\n  console.log(new Date(), `WS ${type} event: `, data);\n}\n\n// simple sleep function\nfunction promiseSleep(milliseconds: number) {\n  return new Promise((resolve) => setTimeout(resolve, milliseconds));\n}\n\n/**\n * This is a simple script wrapped in a immediately invoked function expression (to execute the below workflow immediately).\n *\n * It is designed to:\n * - open a private websocket channel to log account events\n * - check for any available USDT balance in the futures account\n * - immediately open a minimum sized long position on BTCUSDT\n * - check active positions\n * - immediately send closing orders for any active futures positions\n * - check positions again\n *\n */\n(async () => {\n  try {\n    // Add event listeners to log websocket events on account\n    wsClient.on('update', (data) => logWSEvent('update', data));\n\n    wsClient.on('open', (data) => logWSEvent('open', data));\n    wsClient.on('response', (data) => logWSEvent('response', data));\n    wsClient.on('reconnect', (data) => logWSEvent('reconnect', data));\n    wsClient.on('reconnected', (data) => logWSEvent('reconnected', data));\n    wsClient.on('authenticated', (data) => logWSEvent('authenticated', data));\n    wsClient.on('exception', (data) => logWSEvent('exception', data));\n\n    // futures private\n    // : account updates\n    wsClient.subscribeTopic('USDT-FUTURES', 'account');\n\n    // : position updates\n    wsClient.subscribeTopic('USDT-FUTURES', 'positions');\n\n    // : order updates\n    wsClient.subscribeTopic('USDT-FUTURES', 'orders');\n\n    // wait briefly for ws to be ready (could also use the response or authenticated events, to make sure topics are subscribed to before starting)\n    await promiseSleep(2.5 * 1000);\n\n    const symbol = 'BTCUSDT';\n    const marginCoin = 'USDT';\n\n    const balanceResult = await client.getFuturesAccountAssets({\n      productType: 'USDT-FUTURES',\n    });\n    const accountBalance = balanceResult.data;\n    // const balances = allBalances.filter((bal) => Number(bal.available) != 0);\n    const assetList = accountBalance.find(\n      (bal) => bal.marginCoin === marginCoin,\n    )?.assetList;\n    const usdtAmount = assetList?.find(\n      (asset) => asset.coin === 'USDT',\n    )?.balance;\n\n    console.log('USDT balance: ', usdtAmount);\n\n    if (!usdtAmount) {\n      console.error('No USDT to trade');\n      return;\n    }\n\n    const symbolRulesResult = await client.getFuturesContractConfig({\n      symbol,\n      productType: 'USDT-FUTURES',\n    });\n    const bitcoinUSDFuturesRule = symbolRulesResult.data.find(\n      (row) => row.symbol === symbol,\n    );\n\n    console.log('symbol rules: ', bitcoinUSDFuturesRule);\n    if (!bitcoinUSDFuturesRule) {\n      console.error('Failed to get trading rules for ' + symbol);\n      return;\n    }\n\n    const order: FuturesPlaceOrderRequestV2 = {\n      marginCoin: marginCoin,\n      marginMode: 'crossed',\n      productType: 'USDT-FUTURES',\n      orderType: 'market',\n      side: 'buy',\n      size: bitcoinUSDFuturesRule.minTradeNum,\n      symbol: symbol,\n    } as const;\n\n    console.log('placing order: ', order);\n\n    const result = await client.futuresSubmitOrder(order);\n\n    console.log('order result: ', result);\n\n    const positionsResult = await client.getFuturesPositions({\n      productType: 'USDT-FUTURES',\n    });\n    const positionsToClose = positionsResult.data.filter(\n      (pos) => pos.total !== '0',\n    );\n\n    console.log('open positions to close: ', positionsToClose);\n\n    // Loop through any active positions and send a closing market order on each position\n    for (const position of positionsToClose) {\n      const closingSide = position.holdSide === 'long' ? 'sell' : 'buy';\n      const closingOrder: FuturesPlaceOrderRequestV2 = {\n        marginCoin: position.marginCoin,\n        marginMode: 'crossed',\n        productType: 'USDT-FUTURES',\n        orderType: 'market',\n        side: closingSide,\n        size: position.available,\n        symbol: position.symbol,\n      };\n\n      console.log('closing position with market order: ', closingOrder);\n\n      const result = await client.futuresSubmitOrder(closingOrder);\n      console.log('position closing order result: ', result);\n    }\n\n    console.log(\n      'positions after closing all: ',\n      await client.getFuturesPositions({\n        productType: 'USDT-FUTURES',\n      }),\n    );\n  } catch (e) {\n    console.error('request failed: ', e);\n  }\n})();\n",
                  "metadata": {}
                },
                {
                  "type": "file",
                  "name": "rest-trade-spot.ts",
                  "path": "examples/Bitget/V2 - Classic/Rest/rest-trade-spot.ts",
                  "code": "import {\n  RestClientV2,\n  SpotOrderRequestV2,\n  WebsocketClientV2,\n} from 'bitget-api';\n\n// read from environmental variables\nconst API_KEY = process.env.API_KEY_COM;\nconst API_SECRET = process.env.API_SECRET_COM;\nconst API_PASS = process.env.API_PASS_COM;\n\n// If running from CLI in unix, you can pass env vars as such:\n// API_KEY_COM='lkm12n3-2ba3-1mxf-fn13-lkm12n3a' API_SECRET_COM='035B2B9637E1BDFFEE2646BFBDDB8CE4' API_PASSPHRASE_COM='ComplexPa$$!23$5^' ts-node examples/rest-trade-spot.ts\n\n// note the single quotes, preventing special characters such as $ from being incorrectly passed\n\nconst client = new RestClientV2({\n  apiKey: API_KEY,\n  apiSecret: API_SECRET,\n  apiPass: API_PASS,\n  // apiKey: 'apiKeyHere',\n  // apiSecret: 'apiSecretHere',\n  // apiPass: 'apiPassHere',\n});\n\nconst wsClient = new WebsocketClientV2({\n  apiKey: API_KEY,\n  apiSecret: API_SECRET,\n  apiPass: API_PASS,\n});\n\nfunction logWSEvent(type: string, data: any) {\n  console.log(new Date(), `WS ${type} event: `, data);\n}\n\n// simple sleep function\nfunction promiseSleep(milliseconds: number) {\n  return new Promise((resolve) => setTimeout(resolve, milliseconds));\n}\n\n/** This is a simple script wrapped in a immediately invoked function expression, designed to check for any available BTC balance and immediately sell the full amount for USDT */\n(async () => {\n  try {\n    // Add event listeners to log websocket events on account\n    wsClient.on('update', (data) => logWSEvent('update', data));\n    wsClient.on('open', (data) => logWSEvent('open', data));\n    wsClient.on('response', (data) => logWSEvent('response', data));\n    wsClient.on('reconnect', (data) => logWSEvent('reconnect', data));\n    wsClient.on('reconnected', (data) => logWSEvent('reconnected', data));\n    wsClient.on('authenticated', (data) => logWSEvent('authenticated', data));\n    wsClient.on('exception', (data) => logWSEvent('exception', data));\n\n    // Subscribe to private account topics\n    // spot private\n    // : account updates\n    wsClient.subscribeTopic('SPOT', 'account');\n\n    // : order updates (note: symbol is required)\n    wsClient.subscribeTopic('SPOT', 'orders', 'BTCUSDT');\n\n    // wait briefly for ws to be ready (could also use the response or authenticated events, to make sure topics are subscribed to before starting)\n    await promiseSleep(2.5 * 1000);\n\n    const balanceResult = await client.getSpotAccountAssets();\n    const allBalances = balanceResult.data;\n\n    const balanceBTC = allBalances.find(\n      (bal) => bal.coin === 'BTC' || bal.coin === 'btc',\n    );\n    const btcAmount = balanceBTC ? Number(balanceBTC.available) : 0;\n    // console.log('balance: ', JSON.stringify(balances, null, 2));\n    console.log('BTC balance result: ', balanceBTC);\n\n    if (!btcAmount) {\n      console.error('No BTC to trade');\n      return;\n    }\n\n    console.log(`BTC available: ${btcAmount}`);\n    const symbol = 'BTCUSDT';\n\n    const symbolsResult = await client.getSpotSymbolInfo();\n    const btcRules = symbolsResult.data.find((rule) => rule.symbol === symbol);\n    console.log('btc trading rules: ', btcRules);\n    if (!btcRules) {\n      return console.log('no rules found for trading ' + symbol);\n    }\n\n    const quantity = btcRules.minTradeAmount;\n\n    const order: SpotOrderRequestV2 = {\n      symbol: symbol,\n      side: 'sell',\n      orderType: 'market',\n      force: 'gtc',\n      size: quantity,\n    } as const;\n\n    console.log('submitting order: ', order);\n\n    const sellResult = await client.spotSubmitOrder(order);\n\n    console.log('sell result: ', sellResult);\n  } catch (e) {\n    console.error('request failed: ', e);\n  }\n})();\n",
                  "metadata": {}
                }
              ]
            },
            {
              "type": "folder",
              "name": "Websocket",
              "path": "examples/Bitget/V2 - Classic/Websocket",
              "children": [
                {
                  "type": "file",
                  "name": "ws-demo-trading.ts",
                  "path": "examples/Bitget/V2 - Classic/Websocket/ws-demo-trading.ts",
                  "code": "import { DefaultLogger, WebsocketClientV2 } from 'bitget-api';\n\n(async () => {\n  const logger = {\n    ...DefaultLogger,\n    trace: (...params: any[]) => console.log('trace', ...params),\n  };\n\n  const API_KEY = process.env.API_KEY_COM;\n  const API_SECRET = process.env.API_SECRET_COM;\n  const API_PASS = process.env.API_PASS_COM;\n\n  // If running from CLI in unix, you can pass env vars as such:\n  // API_KEY_COM='lkm12n3-2ba3-1mxf-fn13-lkm12n3a' API_SECRET_COM='035B2B9637E1BDFFEE2646BFBDDB8CE4' API_PASSPHRASE_COM='ComplexPa$$!23$5^' ts-node examples/ws-private.ts\n\n  const wsClient = new WebsocketClientV2(\n    {\n      // restOptions: {\n      // optionally provide rest options, e.g. to pass through a proxy\n      // },\n\n      // Set demoTrading to true, to route all connections to the demo trading wss URLs:\n      demoTrading: true,\n\n      // If using private topics, make sure to include API keys\n      apiKey: API_KEY,\n      apiSecret: API_SECRET,\n      apiPass: API_PASS,\n    },\n    logger,\n  );\n\n  wsClient.on('update', (data) => {\n    console.log('WS raw message received ', data);\n    // console.log('WS raw message received ', JSON.stringify(data, null, 2));\n  });\n\n  wsClient.on('open', (data) => {\n    console.log('WS connection opened:', data.wsKey);\n  });\n  wsClient.on('response', (data) => {\n    console.log('WS response: ', JSON.stringify(data, null, 2));\n  });\n  wsClient.on('reconnect', ({ wsKey }) => {\n    console.log('WS automatically reconnecting.... ', wsKey);\n  });\n  wsClient.on('reconnected', (data) => {\n    console.log('WS reconnected ', data?.wsKey);\n  });\n  wsClient.on('exception', (data) => {\n    console.log('WS error', data);\n  });\n\n  /**\n   * Public events\n   */\n\n  const symbol = 'BTCUSDT';\n  wsClient.subscribeTopic('SPOT', 'ticker', symbol);\n\n  wsClient.subscribeTopic('USDC-FUTURES', 'account');\n})();\n",
                  "metadata": {}
                },
                {
                  "type": "file",
                  "name": "ws-private.ts",
                  "path": "examples/Bitget/V2 - Classic/Websocket/ws-private.ts",
                  "code": "import { DefaultLogger, WebsocketClientV2 } from 'bitget-api';\n\n(async () => {\n  const logger = {\n    ...DefaultLogger,\n    trace: (...params: any[]) => console.log('trace', ...params),\n  };\n\n  const API_KEY = process.env.API_KEY_COM;\n  const API_SECRET = process.env.API_SECRET_COM;\n  const API_PASS = process.env.API_PASS_COM;\n\n  // If running from CLI in unix, you can pass env vars as such:\n  // API_KEY_COM='lkm12n3-2ba3-1mxf-fn13-lkm12n3a' API_SECRET_COM='035B2B9637E1BDFFEE2646BFBDDB8CE4' API_PASSPHRASE_COM='ComplexPa$$!23$5^' ts-node examples/ws-private.ts\n\n  // note the single quotes, preventing special characters such as $ from being incorrectly passed\n\n  const wsClient = new WebsocketClientV2(\n    {\n      apiKey: API_KEY,\n      apiSecret: API_SECRET,\n      apiPass: API_PASS,\n      // restOptions: {\n      // optionally provide rest options, e.g. to pass through a proxy\n      // },\n    },\n    logger,\n  );\n\n  wsClient.on('update', (data) => {\n    console.log('WS raw message received ', data);\n    // console.log('WS raw message received ', JSON.stringify(data, null, 2));\n  });\n\n  wsClient.on('open', (data) => {\n    console.log('WS connection opened:', data.wsKey);\n  });\n  wsClient.on('response', (data) => {\n    console.log('WS response: ', JSON.stringify(data, null, 2));\n  });\n  wsClient.on('reconnect', ({ wsKey }) => {\n    console.log('WS automatically reconnecting.... ', wsKey);\n  });\n  wsClient.on('reconnected', (data) => {\n    console.log('WS reconnected ', data?.wsKey);\n  });\n  // auth happens async after the ws connection opens\n  wsClient.on('authenticated', (data) => {\n    console.log('WS authenticated', data);\n    // wsClient.subscribePublicSpotTickers(['BTCUSDT', 'LTCUSDT']);\n  });\n  wsClient.on('exception', (data) => {\n    console.log('WS error', data);\n  });\n\n  /**\n   * Private account updates\n   */\n\n  // spot private\n  // : account updates\n  wsClient.subscribeTopic('SPOT', 'account');\n\n  // : order updates (note: symbol is required)\n  // wsClient.subscribeTopic('SPOT', 'orders', 'BTCUSDT');\n\n  // futures private\n  // : account updates\n  wsClient.subscribeTopic('USDT-FUTURES', 'account');\n  wsClient.subscribeTopic('USDC-FUTURES', 'account');\n\n  // : position updates\n  // wsClient.subscribeTopic('USDT-FUTURES', 'positions');\n\n  // : order updates\n  // wsClient.subscribeTopic('USDT-FUTURES', 'orders');\n\n  // : plan order updates\n  // wsClient.subscribeTopic('USDT-FUTURES', 'orders-algo');\n\n  // wsClient\n  //   .getWsStore()\n  //   .getKeys()\n  //   .forEach((wsKey) => {\n  //     const state = wsClient.getWsStore().get(wsKey);\n  //     console.log(`${wsKey} state: `, state.subscribedTopics.values());\n  //   });\n\n  // setTimeout(() => {\n  //   wsClient.unsubscribeTopic('USDT-FUTURES', 'account');\n  // }, 1000 * 2);\n\n  // setTimeout(() => {\n  //   wsClient\n  //     .getWsStore()\n  //     .getKeys()\n  //     .forEach((wsKey) => {\n  //       const state = wsClient.getWsStore().get(wsKey);\n  //       console.log(`${wsKey} state: `, state.subscribedTopics.values());\n  //     });\n  // }, 1000 * 5);\n})();\n",
                  "metadata": {}
                },
                {
                  "type": "file",
                  "name": "ws-public.ts",
                  "path": "examples/Bitget/V2 - Classic/Websocket/ws-public.ts",
                  "code": "import { DefaultLogger, WebsocketClientV2, WS_KEY_MAP } from 'bitget-api';\n\n(async () => {\n  const logger = {\n    ...DefaultLogger,\n    trace: (...params: any[]) => console.log('trace', ...params),\n  };\n\n  const wsClient = new WebsocketClientV2(\n    {\n      // restOptions: {\n      // optionally provide rest options, e.g. to pass through a proxy\n      // },\n    },\n    logger,\n  );\n\n  wsClient.on('update', (data) => {\n    console.log('WS raw message received ', data);\n    // console.log('WS raw message received ', JSON.stringify(data, null, 2));\n  });\n\n  wsClient.on('open', (data) => {\n    console.log('WS connection opened:', data.wsKey);\n  });\n  wsClient.on('response', (data) => {\n    console.log('WS response: ', JSON.stringify(data, null, 2));\n  });\n  wsClient.on('reconnect', ({ wsKey }) => {\n    console.log('WS automatically reconnecting.... ', wsKey);\n  });\n  wsClient.on('reconnected', (data) => {\n    console.log('WS reconnected ', data?.wsKey);\n  });\n  wsClient.on('exception', (data) => {\n    console.log('WS error', data);\n  });\n\n  /**\n   * Public events\n   */\n\n  const symbol = 'BTCUSDT';\n\n  // Spot public\n\n  // tickers\n  wsClient.subscribeTopic('SPOT', 'ticker', symbol);\n\n  // candles\n  // wsClient.subscribeTopic('SPOT', 'candle1m', symbol);\n\n  // orderbook updates\n  // wsClient.subscribeTopic('SPOT', 'books', symbol);\n\n  // trades\n  // wsClient.subscribeTopic('SPOT', 'trade', symbol);\n\n  // Futures public\n\n  // tickers\n  // wsClient.subscribeTopic('USDT-FUTURES', 'ticker', symbol);\n\n  // candles\n  // wsClient.subscribeTopic('USDT-FUTURES', 'candle1m', symbol);\n\n  // orderbook updates\n  // wsClient.subscribeTopic('USDT-FUTURES', 'books', symbol);\n\n  // trades\n  // wsClient.subscribeTopic('USDT-FUTURES', 'trade', symbol);\n\n  // Topics are tracked per websocket type\n  // Get a list of subscribed topics (e.g. all  public topics) (after a 5 second delay)\n  setTimeout(() => {\n    const publicTopics = wsClient.getWsStore().getTopics(WS_KEY_MAP.v2Public);\n\n    console.log('public  topics: ', publicTopics);\n  }, 5 * 1000);\n})();\n",
                  "metadata": {}
                }
              ]
            }
          ]
        },
        {
          "type": "folder",
          "name": "V3 - UTA",
          "path": "examples/Bitget/V3 - UTA",
          "children": [
            {
              "type": "folder",
              "name": "Rest",
              "path": "examples/Bitget/V3 - UTA/Rest",
              "children": [
                {
                  "type": "file",
                  "name": "rest-private.ts",
                  "path": "examples/Bitget/V3 - UTA/Rest/rest-private.ts",
                  "code": "import { RestClientV3 } from 'bitget-api';\n\n// read from environmental variables\nconst API_KEY = process.env.API_KEY_COM;\nconst API_SECRET = process.env.API_SECRET_COM;\nconst API_PASS = process.env.API_PASS_COM;\n\n// If running from CLI in unix, you can pass env vars as such:\n// API_KEY_COM='lkm12n3-2ba3-1mxf-fn13-lkm12n3a' API_SECRET_COM='035B2B9637E1BDFFEE2646BFBDDB8CE4' API_PASSPHRASE_COM='ComplexPa$$!23$5^' ts-node examples/V3/rest-private-futures.ts\n\n// note the single quotes, preventing special characters such as $ from being incorrectly passed\n\nconst client = new RestClientV3({\n  apiKey: API_KEY,\n  apiSecret: API_SECRET,\n  apiPass: API_PASS,\n  // apiKey: 'apiKeyHere',\n  // apiSecret: 'apiSecretHere',\n  // apiPass: 'apiPassHere',\n});\n\n/** This is a simple script wrapped in a immediately invoked function expression, designed to check account assets for futures trading */\n(async () => {\n  try {\n    console.log(await client.getBalances());\n  } catch (e) {\n    console.error('request failed: ', e);\n  }\n})();\n",
                  "metadata": {}
                },
                {
                  "type": "file",
                  "name": "rest-public-UTA-futures.ts",
                  "path": "examples/Bitget/V3 - UTA/Rest/rest-public-UTA-futures.ts",
                  "code": "import { RestClientV3 } from 'bitget-api';\n\nconst restClient = new RestClientV3();\n\nconst symbol = 'BTCUSDT';\n\n(async () => {\n  try {\n    const response = await restClient.getCandles({\n      symbol,\n      category: 'USDT-FUTURES',\n      interval: '1m',\n    });\n\n    console.table(response.data);\n\n    console.log('getCandles returned ' + response.data.length + ' candles');\n  } catch (e) {\n    console.error('request failed: ', e);\n  }\n})();\n",
                  "metadata": {}
                },
                {
                  "type": "file",
                  "name": "rest-public-UTA-spot.ts",
                  "path": "examples/Bitget/V3 - UTA/Rest/rest-public-UTA-spot.ts",
                  "code": "import { RestClientV3 } from 'bitget-api';\n\nconst restClient = new RestClientV3();\n\n(async () => {\n  try {\n    const response = await restClient.getCandles({\n      symbol: 'BTCUSDT',\n      category: 'SPOT',\n      interval: '1m',\n    });\n\n    console.table(response.data);\n    console.log('getCandles: ', response.data.length);\n  } catch (e) {\n    console.error('request failed: ', e);\n  }\n})();\n",
                  "metadata": {}
                },
                {
                  "type": "file",
                  "name": "rest-trade-UTA-futures.ts",
                  "path": "examples/Bitget/V3 - UTA/Rest/rest-trade-UTA-futures.ts",
                  "code": "/* eslint-disable @typescript-eslint/no-unused-vars */\nimport {\n  PlaceOrderRequestV3,\n  RestClientV3,\n  WebsocketClientV3,\n} from 'bitget-api';\n\n// read from environmental variables\nconst API_KEY = process.env.API_KEY_COM;\nconst API_SECRET = process.env.API_SECRET_COM;\nconst API_PASS = process.env.API_PASS_COM;\n\n// If running from CLI in unix, you can pass env vars as such:\n// API_KEY_COM='lkm12n3-2ba3-1mxf-fn13-lkm12n3a' API_SECRET_COM='035B2B9637E1BDFFEE2646BFBDDB8CE4' API_PASSPHRASE_COM='ComplexPa$$!23$5^' ts-node examples/V3/rest-trade-futures.ts\n\n// note the single quotes, preventing special characters such as $ from being incorrectly passed\n\nconst client = new RestClientV3({\n  apiKey: API_KEY,\n  apiSecret: API_SECRET,\n  apiPass: API_PASS,\n  // apiKey: 'apiKeyHere',\n  // apiSecret: 'apiSecretHere',\n  // apiPass: 'apiPassHere',\n});\n\nconst wsClient = new WebsocketClientV3({\n  apiKey: API_KEY,\n  apiSecret: API_SECRET,\n  apiPass: API_PASS,\n});\n\nfunction logWSEvent(type: string, data: any) {\n  console.log(new Date(), `WS ${type} event: `, data);\n}\n\n// simple sleep function\nfunction promiseSleep(milliseconds: number) {\n  return new Promise((resolve) => setTimeout(resolve, milliseconds));\n}\n\n/**\n * This is a simple script wrapped in a immediately invoked function expression (to execute the below workflow immediately).\n *\n * It is designed to:\n * - open a private websocket channel to log account events\n * - check for any available USDT balance in the account\n * - immediately open a minimum sized long position on BTCUSDT\n * - check active positions\n * - immediately send closing orders for any active futures positions\n * - check positions again\n *\n */\n(async () => {\n  try {\n    // Add event listeners to log websocket events on account\n    wsClient.on('update', (data) => logWSEvent('update', data));\n\n    wsClient.on('open', (data) => logWSEvent('open', data));\n    wsClient.on('response', (data) => logWSEvent('response', data));\n    wsClient.on('reconnect', (data) => logWSEvent('reconnect', data));\n    wsClient.on('reconnected', (data) => logWSEvent('reconnected', data));\n    wsClient.on('authenticated', (data) => logWSEvent('authenticated', data));\n    wsClient.on('exception', (data) => logWSEvent('exception', data));\n\n    // Subscribe to private topics for UTA account\n    wsClient.subscribe(\n      {\n        topic: 'account',\n        payload: {\n          instType: 'UTA',\n        },\n      },\n      'v3Private',\n    );\n\n    // Subscribe to position updates\n    wsClient.subscribe(\n      {\n        topic: 'position',\n        payload: {\n          instType: 'UTA',\n        },\n      },\n      'v3Private',\n    );\n\n    // Subscribe to order updates\n    wsClient.subscribe(\n      {\n        topic: 'order',\n        payload: {\n          instType: 'UTA',\n        },\n      },\n      'v3Private',\n    );\n\n    // wait briefly for ws to be ready (could also use the response or authenticated events, to make sure topics are subscribed to before starting)\n    await promiseSleep(2.5 * 1000);\n\n    const symbol = 'BTCUSDT';\n\n    const balanceResult = await client.getBalances();\n    const accountBalance = balanceResult.data;\n\n    const usdtAsset = accountBalance.assets?.find(\n      (asset) => asset.coin === 'USDT',\n    );\n    const usdtAmount = usdtAsset ? Number(usdtAsset.available) : 0;\n\n    console.log('USDT balance: ', usdtAmount);\n\n    if (!usdtAmount) {\n      console.error('No USDT to trade');\n      return;\n    }\n\n    const symbolRulesResult = await client.getInstruments({\n      category: 'USDT-FUTURES',\n      symbol: symbol,\n    });\n    const bitcoinUSDFuturesRule = symbolRulesResult.data.find(\n      (row) => row.symbol === symbol,\n    );\n\n    console.log('symbol rules: ', bitcoinUSDFuturesRule);\n    if (!bitcoinUSDFuturesRule) {\n      console.error('Failed to get trading rules for ' + symbol);\n      return;\n    }\n\n    const order: PlaceOrderRequestV3 = {\n      category: 'USDT-FUTURES',\n      orderType: 'market',\n      side: 'buy',\n      qty: bitcoinUSDFuturesRule.minOrderQty,\n      symbol: symbol,\n    } as const;\n\n    console.log('placing order: ', order);\n\n    const result = await client.submitNewOrder(order);\n\n    console.log('order result: ', result);\n\n    const positionsResult = await client.getCurrentPosition({\n      category: 'USDT-FUTURES',\n    });\n    const positionsToClose = positionsResult.data.list.filter(\n      (pos) => pos.total !== '0',\n    );\n\n    console.log('open positions to close: ', positionsToClose);\n\n    // Loop through any active positions and send a closing market order on each position\n    for (const position of positionsToClose) {\n      const closingSide = position.posSide === 'long' ? 'sell' : 'buy';\n      const closingOrder: PlaceOrderRequestV3 = {\n        category: 'USDT-FUTURES',\n        orderType: 'market',\n        side: closingSide,\n        qty: position.total,\n        symbol: position.symbol,\n      };\n\n      console.log('closing position with market order: ', closingOrder);\n\n      const result = await client.submitNewOrder(closingOrder);\n      console.log('position closing order result: ', result);\n    }\n\n    console.log(\n      'positions after closing all: ',\n      await client.getCurrentPosition({\n        category: 'USDT-FUTURES',\n      }),\n    );\n  } catch (e) {\n    console.error('request failed: ', e);\n  }\n})();\n",
                  "metadata": {}
                },
                {
                  "type": "file",
                  "name": "rest-trade-UTA-spot.ts",
                  "path": "examples/Bitget/V3 - UTA/Rest/rest-trade-UTA-spot.ts",
                  "code": "/* eslint-disable @typescript-eslint/no-unused-vars */\nimport {\n  PlaceOrderRequestV3,\n  RestClientV3,\n  WebsocketClientV3,\n} from 'bitget-api';\n\n// read from environmental variables\nconst API_KEY = process.env.API_KEY_COM;\nconst API_SECRET = process.env.API_SECRET_COM;\nconst API_PASS = process.env.API_PASS_COM;\n\n// If running from CLI in unix, you can pass env vars as such:\n// API_KEY_COM='lkm12n3-2ba3-1mxf-fn13-lkm12n3a' API_SECRET_COM='035B2B9637E1BDFFEE2646BFBDDB8CE4' API_PASSPHRASE_COM='ComplexPa$$!23$5^' ts-node examples/V3/rest-trade-spot.ts\n\n// note the single quotes, preventing special characters such as $ from being incorrectly passed\n\nconst client = new RestClientV3({\n  apiKey: API_KEY,\n  apiSecret: API_SECRET,\n  apiPass: API_PASS,\n  // apiKey: 'apiKeyHere',\n  // apiSecret: 'apiSecretHere',\n  // apiPass: 'apiPassHere',\n});\n\nconst wsClient = new WebsocketClientV3({\n  apiKey: API_KEY,\n  apiSecret: API_SECRET,\n  apiPass: API_PASS,\n});\n\nfunction logWSEvent(type: string, data: any) {\n  console.log(new Date(), `WS ${type} event: `, data);\n}\n\n// simple sleep function\nfunction promiseSleep(milliseconds: number) {\n  return new Promise((resolve) => setTimeout(resolve, milliseconds));\n}\n\n/** This is a simple script wrapped in a immediately invoked function expression, designed to check for any available BTC balance and immediately sell the full amount for USDT */\n(async () => {\n  try {\n    // Add event listeners to log websocket events on account\n    wsClient.on('update', (data) => logWSEvent('update', data));\n    wsClient.on('open', (data) => logWSEvent('open', data));\n    wsClient.on('response', (data) => logWSEvent('response', data));\n    wsClient.on('reconnect', (data) => logWSEvent('reconnect', data));\n    wsClient.on('reconnected', (data) => logWSEvent('reconnected', data));\n    wsClient.on('authenticated', (data) => logWSEvent('authenticated', data));\n    wsClient.on('exception', (data) => logWSEvent('exception', data));\n\n    // Subscribe to private account topics\n    // Account updates for UTA (unified trading account)\n    wsClient.subscribe(\n      {\n        topic: 'account',\n        payload: {\n          instType: 'UTA',\n        },\n      },\n      'v3Private',\n    );\n\n    // Order updates for spot\n    wsClient.subscribe(\n      {\n        topic: 'order',\n        payload: {\n          instType: 'UTA',\n        },\n      },\n      'v3Private',\n    );\n\n    // wait briefly for ws to be ready (could also use the response or authenticated events, to make sure topics are subscribed to before starting)\n    await promiseSleep(2.5 * 1000);\n\n    const balanceResult = await client.getBalances();\n    const allBalances = balanceResult.data;\n\n    const balanceBTC = allBalances.assets?.find(\n      (bal) => bal.coin === 'BTC' || bal.coin === 'btc',\n    );\n    const btcAmount =\n      Number(allBalances.usdtEquity) > 0 ? Number(balanceBTC?.available) : 0;\n    console.log('balance: ', JSON.stringify(allBalances, null, 2));\n    console.log('BTC balance result: ', balanceBTC);\n\n    if (!btcAmount) {\n      console.error('No BTC to trade');\n      return;\n    }\n\n    console.log(`BTC available: ${btcAmount}`);\n    const symbol = 'BTCUSDT';\n\n    const symbolsResult = await client.getInstruments({\n      category: 'SPOT',\n      symbol: symbol,\n    });\n    const btcRules = symbolsResult.data.find((rule) => rule.symbol === symbol);\n    console.log('btc trading rules: ', btcRules);\n    if (!btcRules) {\n      return console.log('no rules found for trading ' + symbol);\n    }\n\n    const quantity = btcRules.minOrderQty;\n\n    const order: PlaceOrderRequestV3 = {\n      symbol: symbol,\n      side: 'sell',\n      orderType: 'market',\n      category: 'SPOT',\n      qty: quantity,\n    } as const;\n\n    console.log('submitting order: ', order);\n\n    const sellResult = await client.submitNewOrder(order);\n\n    console.log('sell result: ', sellResult);\n  } catch (e) {\n    console.error('request failed: ', e);\n  }\n})();\n",
                  "metadata": {}
                }
              ]
            },
            {
              "type": "folder",
              "name": "Websocket",
              "path": "examples/Bitget/V3 - UTA/Websocket",
              "children": [
                {
                  "type": "file",
                  "name": "ws-private.ts",
                  "path": "examples/Bitget/V3 - UTA/Websocket/ws-private.ts",
                  "code": "import { DefaultLogger, WebsocketClientV3, WS_KEY_MAP } from 'bitget-api';\n\n(async () => {\n  const logger = {\n    ...DefaultLogger,\n    trace: (...params: any[]) => console.log('trace', ...params),\n  };\n\n  const API_KEY = process.env.API_KEY_COM;\n  const API_SECRET = process.env.API_SECRET_COM;\n  const API_PASS = process.env.API_PASS_COM;\n\n  // If running from CLI in unix, you can pass env vars as such:\n  // API_KEY_COM='lkm12n3-2ba3-1mxf-fn13-lkm12n3a' API_SECRET_COM='035B2B9637E1BDFFEE2646BFBDDB8CE4' API_PASSPHRASE_COM='ComplexPa$$!23$5^' ts-node examples/ws-private.ts\n\n  const wsClient = new WebsocketClientV3(\n    {\n      apiKey: API_KEY,\n      apiSecret: API_SECRET,\n      apiPass: API_PASS,\n    },\n    logger,\n  );\n\n  wsClient.on('update', (data) => {\n    console.log('WS raw message received ', data);\n    // console.log('WS raw message received ', JSON.stringify(data, null, 2));\n  });\n\n  wsClient.on('open', (data) => {\n    console.log('WS connection opened:', data.wsKey);\n  });\n  wsClient.on('response', (data) => {\n    console.log('WS response: ', JSON.stringify(data, null, 2));\n  });\n  wsClient.on('reconnect', ({ wsKey }) => {\n    console.log('WS automatically reconnecting.... ', wsKey);\n  });\n  wsClient.on('reconnected', (data) => {\n    console.log('WS reconnected ', data?.wsKey);\n  });\n  wsClient.on('exception', (data) => {\n    console.log('WS error', data);\n  });\n\n  // You can subscribe to one topic at a time\n  wsClient.subscribe(\n    {\n      topic: 'account',\n      payload: {\n        instType: 'UTA', // Note: all account events go on the UTA instType\n      },\n    },\n    WS_KEY_MAP.v3Private, // This parameter points to private or public\n  );\n\n  // Note: all account events go on the UTA instType\n  const ACCOUNT_INST_TYPE = 'UTA';\n  const ACCOUNT_WS_KEY = WS_KEY_MAP.v3Private;\n\n  // Or multiple at once:\n  wsClient.subscribe(\n    [\n      {\n        topic: 'account',\n        payload: {\n          instType: ACCOUNT_INST_TYPE,\n        },\n      },\n      {\n        topic: 'position',\n        payload: {\n          instType: ACCOUNT_INST_TYPE,\n        },\n      },\n      {\n        topic: 'fill',\n        payload: {\n          instType: ACCOUNT_INST_TYPE,\n        },\n      },\n      {\n        topic: 'order',\n        payload: {\n          instType: ACCOUNT_INST_TYPE,\n        },\n      },\n    ],\n    ACCOUNT_WS_KEY,\n  );\n\n  // Topics are tracked per websocket type\n  // The below example will pull a list of subscribed topics on that connection (e.g. all private topics), after a 5 second delay:\n  setTimeout(() => {\n    const privateTopics = wsClient.getWsStore().getTopics(WS_KEY_MAP.v3Private);\n\n    console.log('private topics currently in state: ', privateTopics);\n  }, 5 * 1000);\n})();\n",
                  "metadata": {}
                },
                {
                  "type": "file",
                  "name": "ws-public.ts",
                  "path": "examples/Bitget/V3 - UTA/Websocket/ws-public.ts",
                  "code": "import { DefaultLogger, WebsocketClientV3, WS_KEY_MAP } from 'bitget-api';\n\n(async () => {\n  const logger = {\n    ...DefaultLogger,\n    trace: (...params: any[]) => console.log('trace', ...params),\n  };\n\n  const wsClient = new WebsocketClientV3({}, logger);\n\n  wsClient.on('update', (data) => {\n    console.log('WS raw message received ', data);\n    // console.log('WS raw message received ', JSON.stringify(data, null, 2));\n  });\n\n  wsClient.on('open', (data) => {\n    console.log('WS connection opened:', data.wsKey);\n  });\n  wsClient.on('response', (data) => {\n    console.log('WS response: ', JSON.stringify(data, null, 2));\n  });\n  wsClient.on('reconnect', ({ wsKey }) => {\n    console.log('WS automatically reconnecting.... ', wsKey);\n  });\n  wsClient.on('reconnected', (data) => {\n    console.log('WS reconnected ', data?.wsKey);\n  });\n  wsClient.on('exception', (data) => {\n    console.log('WS error', data);\n  });\n\n  /**\n   * Public events\n   */\n\n  // You can subscribe to one topic at a time\n  wsClient.subscribe(\n    {\n      topic: 'ticker',\n      payload: {\n        instType: 'spot',\n        symbol: 'BTCUSDT',\n      },\n    },\n    WS_KEY_MAP.v3Public, // This parameter points to private or public\n  );\n\n  // Or multiple at once:\n  wsClient.subscribe(\n    [\n      {\n        topic: 'ticker',\n        payload: {\n          instType: 'spot',\n          symbol: 'BTCUSDT',\n        },\n      },\n      {\n        topic: 'ticker',\n        payload: {\n          instType: 'spot',\n          symbol: 'ETHUSDT',\n        },\n      },\n      {\n        topic: 'ticker',\n        payload: {\n          instType: 'spot',\n          symbol: 'XRPUSDT',\n        },\n      },\n      {\n        topic: 'ticker',\n        payload: {\n          instType: 'usdt-futures',\n          symbol: 'BTCUSDT',\n        },\n      },\n      {\n        topic: 'ticker',\n        payload: {\n          instType: 'usdt-futures',\n          symbol: 'BTCUSDT',\n        },\n      },\n    ],\n    WS_KEY_MAP.v3Public,\n  );\n\n  // Topics are tracked per websocket type\n  // The below example will pull a list of subscribed topics on that connection (e.g. all public topics), after a 5 second delay:\n  setTimeout(() => {\n    const publicTopics = wsClient.getWsStore().getTopics(WS_KEY_MAP.v3Public);\n\n    console.log('public topics: ', publicTopics);\n  }, 5 * 1000);\n})();\n",
                  "metadata": {}
                }
              ]
            },
            {
              "type": "folder",
              "name": "WS-API",
              "path": "examples/Bitget/V3 - UTA/WS-API",
              "children": [
                {
                  "type": "file",
                  "name": "ws-api-client-trade.ts",
                  "path": "examples/Bitget/V3 - UTA/WS-API/ws-api-client-trade.ts",
                  "code": "import { DefaultLogger, WebsocketAPIClient } from 'bitget-api';\n\n// function attachEventHandlers<TWSClient extends WebsocketClientV3>(\n//   wsClient: TWSClient,\n// ): void {\n//   wsClient.on('update', (data) => {\n//     console.log('raw message received ', JSON.stringify(data));\n//   });\n//   wsClient.on('open', (data) => {\n//     console.log('ws connected', data.wsKey);\n//   });\n//   wsClient.on('reconnect', ({ wsKey }) => {\n//     console.log('ws automatically reconnecting.... ', wsKey);\n//   });\n//   wsClient.on('reconnected', (data) => {\n//     console.log('ws has reconnected ', data?.wsKey);\n//   });\n//   wsClient.on('authenticated', (data) => {\n//     console.log('ws has authenticated ', data?.wsKey);\n//   });\n// }\n\n(async () => {\n  const logger = {\n    ...DefaultLogger,\n    trace: (...params: any[]) => console.log('trace', ...params),\n  };\n\n  const API_KEY = process.env.API_KEY_COM;\n  const API_SECRET = process.env.API_SECRET_COM;\n  const API_PASS = process.env.API_PASS_COM;\n\n  // If running from CLI in unix, you can pass env vars as such:\n  // API_KEY_COM='lkm12n3-2ba3-1mxf-fn13-lkm12n3a' API_SECRET_COM='035B2B9637E1BDFFEE2646BFBDDB8CE4' API_PASSPHRASE_COM='ComplexPa$$!23$5^' ts-node examples/ws-private.ts\n\n  const wsClient = new WebsocketAPIClient(\n    {\n      apiKey: API_KEY,\n      apiSecret: API_SECRET,\n      apiPass: API_PASS,\n\n      // Whether to use the demo trading wss connection\n      // demoTrading: true,\n\n      // If you want your own event handlers instead of the default ones with logs,\n      // disable this setting and see the `attachEventHandlers` example below:\n      // attachEventListeners: false\n    },\n    logger, // Optional: inject a custom logger\n  );\n\n  // Optional, see above \"attachEventListeners\". Attach basic event handlers, so nothing is left unhandled\n  // attachEventHandlers(wsClient.getWSClient());\n\n  // Optional: prepare the WebSocket API connection in advance.\n  // This happens automatically but you can do this early before making any API calls, to prevent delays from a cold start.\n  await wsClient.getWSClient().connectWSAPI();\n\n  /**\n   * Bitget's WebSocket API be used like a REST API, through this SDK's WebsocketAPIClient. The WebsocketAPIClient is a utility class wrapped around WebsocketClientV3's sendWSAPIRequest() capabilities.\n   *\n   * Each request sent via the WebsocketAPIClient will automatically:\n   * - route via the active WS API connection\n   * - return a Promise, which automatically resolves/rejects when a matching response is received\n   *\n   * Note: this requires V3/UTA API keys!\n   */\n\n  /**\n   * Place Order\n   * https://www.bitget.com/api-doc/uta/websocket/private/Place-Order-Channel#request-parameters\n   */\n  try {\n    const res = await wsClient.submitNewOrder('spot', {\n      orderType: 'limit',\n      price: '100',\n      qty: '0.1',\n      side: 'buy',\n      symbol: 'BTCUSDT',\n      timeInForce: 'gtc',\n    });\n    /**\n      const res = {\n        \"event\": \"trade\",\n        \"id\": \"1750034396082\",\n        \"category\": \"spot\",\n        \"topic\": \"place-order\",\n        \"args\": [\n          {\n            \"symbol\": \"BTCUSDT\",\n            \"orderId\": \"xxxxxxxx\",\n            \"clientOid\": \"xxxxxxxx\",\n            \"cTime\": \"1750034397008\"\n          }\n        ],\n        \"code\": \"0\",\n        \"msg\": \"success\",\n        \"ts\": \"1750034397076\"\n      };\n     */\n\n    console.log(new Date(), 'WS API \"submitNewOrder()\" result: ', res);\n  } catch (e) {\n    console.error(new Date(), 'Exception with WS API \"submitNewOrder()\": ', e);\n  }\n\n  /**\n   * Batch Place Order Channel\n   * https://www.bitget.com/api-doc/uta/websocket/private/Batch-Place-Order-Channel\n   */\n\n  try {\n    /**\n     * Note: batch place will never reject the request, even if all orders were rejected. Check the \"code\" and \"msg\" properties for individual orders in the response, to detect batch place errors.\n     */\n    const res = await wsClient.placeBatchOrders('spot', [\n      {\n        clientOid: 'xxxxxxxx1',\n        orderType: 'limit',\n        price: '100',\n        qty: '0.1',\n        side: 'buy',\n        symbol: 'BTCUSDT',\n        timeInForce: 'gtc',\n      },\n      {\n        clientOid: 'xxxxxxxx2',\n        orderType: 'limit',\n        price: '100',\n        qty: '0.15',\n        side: 'buy',\n        symbol: 'BTCUSDT',\n        timeInForce: 'gtc',\n      },\n    ]);\n\n    /**\n      const res = {\n        \"event\": \"trade\",\n        \"id\": \"1750035029506\",\n        \"category\": \"spot\",\n        \"topic\": \"batch-place\",\n        \"args\": [\n          {\n            \"code\": \"0\",\n            \"msg\": \"Success\",\n            \"symbol\": \"BTCUSDT\",\n            \"orderId\": \"xxxxxxxx\",\n            \"clientOid\": \"xxxxxxxx\"\n          },\n          {\n            \"code\": \"0\",\n            \"msg\": \"Success\",\n            \"symbol\": \"BTCUSDT\",\n            \"orderId\": \"xxxxxxxx\",\n            \"clientOid\": \"xxxxxxxx\"\n          }\n        ],\n        \"code\": \"0\",\n        \"msg\": \"Success\",\n        \"ts\": \"1750035029925\"\n      }\n     */\n\n    console.log(new Date(), 'WS API \"placeBatchOrders()\" result: ', res);\n  } catch (e) {\n    console.error(\n      new Date(),\n      'Exception with WS API \"placeBatchOrders()\": ',\n      e,\n    );\n  }\n\n  /**\n   * Cancel Order\n   * https://www.bitget.com/api-doc/uta/websocket/private/Cancel-Order-Channel\n   */\n\n  try {\n    const res = await wsClient.cancelOrder('spot', {\n      clientOid: 'xxxxxxxx1',\n    });\n\n    /**\n      const res = {\n        \"event\": \"trade\",\n        \"id\": \"1750034870205\",\n        \"topic\": \"cancel-order\",\n        \"args\": [\n          {\n            \"orderId\": \"xxxxxxxx\",\n            \"clientOid\": \"xxxxxxxx\"\n          }\n        ],\n        \"code\": \"0\",\n        \"msg\": \"Success\",\n        \"ts\": \"1750034870597\"\n      }\n     */\n\n    console.log(new Date(), 'WS API \"cancelOrder()\" result: ', res);\n  } catch (e) {\n    console.error(new Date(), 'Exception with WS API \"cancelOrder()\": ', e);\n  }\n\n  /**\n   * Batch Cancel Order\n   * https://www.bitget.com/api-doc/uta/websocket/private/Batch-Cancel-Order-Channel\n   */\n\n  try {\n    const res = await wsClient.cancelBatchOrders('spot', [\n      {\n        clientOid: 'xxxxxxxx1',\n      },\n      {\n        orderId: '123123123',\n      },\n    ]);\n\n    /**\n      const res = {\n        \"event\": \"trade\",\n        \"id\": \"bb553cc0-c1fa-454e-956d-c96c8d715760\",\n        \"topic\": \"batch-cancel\",\n        \"args\": [\n          {\n            \"code\": \"0\",\n            \"msg\": \"Success\",\n            \"orderId\": \"xxxxxxxxxxxxx\"\n          },\n          {\n            \"code\": \"25204\",\n            \"msg\": \"Order does not exist\",\n            \"orderId\": \"xxxxxxxxxxxxx\"\n          }\n        ],\n        \"code\": \"0\",\n        \"msg\": \"Success\",\n        \"ts\": \"1751980011084\"\n      }\n     */\n\n    console.log(new Date(), 'WS API \"cancelBatchOrders()\" result: ', res);\n  } catch (e) {\n    console.error(\n      new Date(),\n      'Exception with WS API \"cancelBatchOrders()\": ',\n      e,\n    );\n  }\n\n  console.log(new Date(), 'Reached end of example.');\n})();\n",
                  "metadata": {}
                },
                {
                  "type": "file",
                  "name": "ws-api-trade-raw.ts",
                  "path": "examples/Bitget/V3 - UTA/WS-API/ws-api-trade-raw.ts",
                  "code": "import { DefaultLogger, WebsocketClientV3, WS_KEY_MAP } from 'bitget-api';\n\n(async () => {\n  const logger = {\n    ...DefaultLogger,\n    trace: (...params: any[]) => console.log('trace', ...params),\n  };\n\n  const API_KEY = process.env.API_KEY_COM;\n  const API_SECRET = process.env.API_SECRET_COM;\n  const API_PASS = process.env.API_PASS_COM;\n\n  // If running from CLI in unix, you can pass env vars as such:\n  // API_KEY_COM='lkm12n3-2ba3-1mxf-fn13-lkm12n3a' API_SECRET_COM='035B2B9637E1BDFFEE2646BFBDDB8CE4' API_PASSPHRASE_COM='ComplexPa$$!23$5^' ts-node examples/ws-private.ts\n\n  const wsClient = new WebsocketClientV3(\n    {\n      apiKey: API_KEY,\n      apiSecret: API_SECRET,\n      apiPass: API_PASS,\n    },\n    logger,\n  );\n\n  wsClient.on('update', (data) => {\n    console.log('WS raw message received ', data);\n    // console.log('WS raw message received ', JSON.stringify(data, null, 2));\n  });\n\n  wsClient.on('open', (data) => {\n    console.log('WS connection opened:', data.wsKey);\n  });\n  wsClient.on('response', (data) => {\n    console.log('WS response: ', JSON.stringify(data, null, 2));\n  });\n  wsClient.on('reconnect', ({ wsKey }) => {\n    console.log('WS automatically reconnecting.... ', wsKey);\n  });\n  wsClient.on('reconnected', (data) => {\n    console.log('WS reconnected ', data?.wsKey);\n  });\n  wsClient.on('exception', (data) => {\n    console.log('WS error', data);\n  });\n\n  /**\n   * Bitget's WebSocket API can be used via the sendWSAPIRequest() method.\n   *\n   * Use the `WS_KEY_MAP.v3Private` connection key for any requests.\n   *\n   * Note: this requires V3/UTA API keys!\n   * Note: for a better user experience, it is recommended to use the WebsocketAPIClient.\n   */\n\n  // Use the V3 private wss connection URL\n  const wsConnectionKey = WS_KEY_MAP.v3Private;\n\n  /**\n   * Place Order\n   * https://www.bitget.com/api-doc/uta/websocket/private/Place-Order-Channel#request-parameters\n   */\n  try {\n    const res = await wsClient.sendWSAPIRequest(\n      wsConnectionKey,\n      'place-order',\n      'spot',\n      {\n        orderType: 'limit',\n        price: '100',\n        qty: '0.1',\n        side: 'buy',\n        symbol: 'BTCUSDT',\n        timeInForce: 'gtc',\n      },\n    );\n\n    /**\n      const res = {\n        \"event\": \"trade\",\n        \"id\": \"1750034396082\",\n        \"category\": \"spot\",\n        \"topic\": \"place-order\",\n        \"args\": [\n          {\n            \"symbol\": \"BTCUSDT\",\n            \"orderId\": \"xxxxxxxx\",\n            \"clientOid\": \"xxxxxxxx\",\n            \"cTime\": \"1750034397008\"\n          }\n        ],\n        \"code\": \"0\",\n        \"msg\": \"success\",\n        \"ts\": \"1750034397076\"\n      };\n     */\n\n    console.log(new Date(), 'WS API \"place-order\" result: ', res);\n  } catch (e) {\n    console.error(new Date(), 'Exception with WS API \"place-order\": ', e);\n  }\n\n  /**\n   * Batch Place Order Channel\n   * https://www.bitget.com/api-doc/uta/websocket/private/Batch-Place-Order-Channel\n   */\n\n  try {\n    /**\n     * Note: batch place will never reject the request, even if all orders were rejected. Check the \"code\" and \"msg\" properties for individual orders in the response, to detect batch place errors.\n     */\n    const res = await wsClient.sendWSAPIRequest(\n      wsConnectionKey,\n      'batch-place',\n      'spot',\n      [\n        {\n          clientOid: 'xxxxxxxx1',\n          orderType: 'limit',\n          price: '100',\n          qty: '0.1',\n          side: 'buy',\n          symbol: 'BTCUSDT',\n          timeInForce: 'gtc',\n        },\n        {\n          clientOid: 'xxxxxxxx2',\n          orderType: 'limit',\n          price: '100',\n          qty: '0.15',\n          side: 'buy',\n          symbol: 'BTCUSDT',\n          timeInForce: 'gtc',\n        },\n      ],\n    );\n\n    /**\n      const res = {\n        \"event\": \"trade\",\n        \"id\": \"1750035029506\",\n        \"category\": \"spot\",\n        \"topic\": \"batch-place\",\n        \"args\": [\n          {\n            \"code\": \"0\",\n            \"msg\": \"Success\",\n            \"symbol\": \"BTCUSDT\",\n            \"orderId\": \"xxxxxxxx\",\n            \"clientOid\": \"xxxxxxxx\"\n          },\n          {\n            \"code\": \"0\",\n            \"msg\": \"Success\",\n            \"symbol\": \"BTCUSDT\",\n            \"orderId\": \"xxxxxxxx\",\n            \"clientOid\": \"xxxxxxxx\"\n          }\n        ],\n        \"code\": \"0\",\n        \"msg\": \"Success\",\n        \"ts\": \"1750035029925\"\n      }\n     */\n\n    console.log(new Date(), 'WS API \"batch-place\" result: ', res);\n  } catch (e) {\n    console.error(new Date(), 'Exception with WS API \"batch-place\": ', e);\n  }\n\n  /**\n   * Cancel Order\n   * https://www.bitget.com/api-doc/uta/websocket/private/Cancel-Order-Channel\n   */\n\n  try {\n    const res = await wsClient.sendWSAPIRequest(\n      wsConnectionKey,\n      'cancel-order',\n      'spot',\n      {\n        clientOid: 'xxxxxxxx1',\n      },\n    );\n\n    /**\n      const res = {\n        \"event\": \"trade\",\n        \"id\": \"1750034870205\",\n        \"topic\": \"cancel-order\",\n        \"args\": [\n          {\n            \"orderId\": \"xxxxxxxx\",\n            \"clientOid\": \"xxxxxxxx\"\n          }\n        ],\n        \"code\": \"0\",\n        \"msg\": \"Success\",\n        \"ts\": \"1750034870597\"\n      }\n     */\n\n    console.log(new Date(), 'WS API \"cancel-order\" result: ', res);\n  } catch (e) {\n    console.error(new Date(), 'Exception with WS API \"cancel-order\": ', e);\n  }\n\n  /**\n   * Batch Cancel Order\n   * https://www.bitget.com/api-doc/uta/websocket/private/Batch-Cancel-Order-Channel\n   */\n\n  try {\n    const res = await wsClient.sendWSAPIRequest(\n      wsConnectionKey,\n      'batch-cancel',\n      'spot',\n      [\n        {\n          clientOid: 'xxxxxxxx1',\n        },\n        {\n          orderId: '123123123',\n        },\n      ],\n    );\n\n    /**\n      const res = {\n        \"event\": \"trade\",\n        \"id\": \"bb553cc0-c1fa-454e-956d-c96c8d715760\",\n        \"topic\": \"batch-cancel\",\n        \"args\": [\n          {\n            \"code\": \"0\",\n            \"msg\": \"Success\",\n            \"orderId\": \"xxxxxxxxxxxxx\"\n          },\n          {\n            \"code\": \"25204\",\n            \"msg\": \"Order does not exist\",\n            \"orderId\": \"xxxxxxxxxxxxx\"\n          }\n        ],\n        \"code\": \"0\",\n        \"msg\": \"Success\",\n        \"ts\": \"1751980011084\"\n      }\n     */\n\n    console.log(new Date(), 'WS API \"batch-cancel\" result: ', res);\n  } catch (e) {\n    console.error(new Date(), 'Exception with WS API \"batch-cancel\": ', e);\n  }\n\n  console.log(new Date(), 'Reached end of example.');\n})();\n",
                  "metadata": {}
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "type": "folder",
      "name": "Bitmart",
      "path": "examples/Bitmart",
      "children": [
        {
          "type": "folder",
          "name": "Auth",
          "path": "examples/Bitmart/Auth",
          "children": [
            {
              "type": "file",
              "name": "fasterHmacSign.ts",
              "path": "examples/Bitmart/Auth/fasterHmacSign.ts",
              "code": "import { RestClient } from 'bitmart-api';\nimport { createHmac } from 'crypto';\n\nconst account = {\n  key: process.env.API_KEY || 'apiKeyHere',\n  secret: process.env.API_SECRET || 'apiSecretHere',\n  memo: process.env.API_MEMO || 'apiMemoHere',\n};\n\nconst client = new RestClient({\n  apiKey: account.key,\n  apiSecret: account.secret,\n  apiMemo: account.memo,\n  /**\n   * Overkill in almost every case, but if you need any optimisation available,\n   * you can inject a faster sign mechanism such as node's native createHmac:\n   */\n  customSignMessageFn: async (message, secret) => {\n    return createHmac('sha256', secret).update(message).digest('hex');\n  },\n});\n\nasync function getSpotBalances() {\n  try {\n    const balances = await client.getAccountBalancesV1();\n\n    console.log('Balances: ', JSON.stringify(balances, null, 2));\n  } catch (e) {\n    console.error('Req error: ', e);\n  }\n}\n\ngetSpotBalances();\n",
              "metadata": {}
            }
          ]
        },
        {
          "type": "folder",
          "name": "Rest",
          "path": "examples/Bitmart/Rest",
          "children": [
            {
              "type": "folder",
              "name": "Futures",
              "path": "examples/Bitmart/Rest/Futures",
              "children": [
                {
                  "type": "file",
                  "name": "futures-get-balances.ts",
                  "path": "examples/Bitmart/Rest/Futures/futures-get-balances.ts",
                  "code": "import { FuturesClientV2 } from 'bitmart-api';\n\nconst account = {\n  key: process.env.API_KEY || 'apiKeyHere',\n  secret: process.env.API_SECRET || 'apiSecretHere',\n  memo: process.env.API_MEMO || 'apiMemoHere',\n};\n\nconst client = new FuturesClientV2({\n  apiKey: account.key,\n  apiSecret: account.secret,\n  apiMemo: account.memo,\n});\n\nasync function getFuturesAssets() {\n  try {\n    const balances = await client.getFuturesAccountAssets();\n\n    console.log('Balances: ', JSON.stringify(balances, null, 2));\n  } catch (e) {\n    console.error('Req error: ', e);\n  }\n}\n\ngetFuturesAssets();\n",
                  "metadata": {}
                },
                {
                  "type": "file",
                  "name": "futures-get-klines.ts",
                  "path": "examples/Bitmart/Rest/Futures/futures-get-klines.ts",
                  "code": "import { FuturesClientV2 } from 'bitmart-api';\n\nconst client = new FuturesClientV2();\n\nasync function getFuturesKlines() {\n  try {\n    const klines = await client.getFuturesKlines({\n      symbol: 'BTCUSDT',\n      start_time: 1709130476,\n      end_time: 1709131476,\n    });\n\n    console.log('Tickers: ', JSON.stringify(klines, null, 2));\n  } catch (e) {\n    console.error('Req error: ', e);\n  }\n}\n\ngetFuturesKlines();\n",
                  "metadata": {}
                },
                {
                  "type": "file",
                  "name": "futures-get-tickers.ts",
                  "path": "examples/Bitmart/Rest/Futures/futures-get-tickers.ts",
                  "code": "import { FuturesClientV2 } from 'bitmart-api';\n\nconst client = new FuturesClientV2();\n\nasync function getFuturesTickers() {\n  try {\n    const tickers = await client.getFuturesContractDetails();\n\n    console.log('Tickers: ', JSON.stringify(tickers, null, 2));\n  } catch (e) {\n    console.error('Req error: ', e);\n  }\n}\n\ngetFuturesTickers();\n",
                  "metadata": {}
                },
                {
                  "type": "file",
                  "name": "futures-submit-order.ts",
                  "path": "examples/Bitmart/Rest/Futures/futures-submit-order.ts",
                  "code": "import { FuturesClientV2 } from 'bitmart-api';\n\nconst account = {\n  key: process.env.API_KEY || 'apiKeyHere',\n  secret: process.env.API_SECRET || 'apiSecretHere',\n  memo: process.env.API_MEMO || 'apiMemoHere',\n};\n\nconst client = new FuturesClientV2({\n  apiKey: account.key,\n  apiSecret: account.secret,\n  apiMemo: account.memo,\n});\n\nasync function SumbitFuturesOrder() {\n  try {\n    const order = await client.submitFuturesOrder({\n      symbol: 'BTCUSDT',\n      type: 'market',\n      side: 1, // Order side - 1=buy_open_long  -2=buy_close_short  -3=sell_close_long  -4=sell_open_short\n      size: 1,\n      leverage: '1',\n      open_type: 'cross',\n    });\n\n    console.log('Order: ', JSON.stringify(order, null, 2));\n  } catch (e) {\n    console.error('Req error: ', e);\n  }\n}\n\nSumbitFuturesOrder();\n",
                  "metadata": {}
                }
              ]
            },
            {
              "type": "folder",
              "name": "Spot",
              "path": "examples/Bitmart/Rest/Spot",
              "children": [
                {
                  "type": "file",
                  "name": "spot-get-balances.ts",
                  "path": "examples/Bitmart/Rest/Spot/spot-get-balances.ts",
                  "code": "import { RestClient } from 'bitmart-api';\n\nconst account = {\n  key: process.env.API_KEY || 'apiKeyHere',\n  secret: process.env.API_SECRET || 'apiSecretHere',\n  memo: process.env.API_MEMO || 'apiMemoHere',\n};\n\nconst client = new RestClient({\n  apiKey: account.key,\n  apiSecret: account.secret,\n  apiMemo: account.memo,\n});\n\nasync function getSpotBalances() {\n  try {\n    const balances = await client.getAccountBalancesV1();\n\n    console.log('Balances: ', JSON.stringify(balances, null, 2));\n  } catch (e) {\n    console.error('Req error: ', e);\n  }\n}\n\ngetSpotBalances();\n",
                  "metadata": {}
                },
                {
                  "type": "file",
                  "name": "spot-get-klines.ts",
                  "path": "examples/Bitmart/Rest/Spot/spot-get-klines.ts",
                  "code": "import { RestClient } from 'bitmart-api';\n\nconst client = new RestClient();\n\nasync function getKlines() {\n  try {\n    const klines = await client.getSpotLatestKlineV3({ symbol: 'BTC_USDT' });\n\n    console.log('Tickers: ', JSON.stringify(klines, null, 2));\n  } catch (e) {\n    console.error('Req error: ', e);\n  }\n}\n\ngetKlines();\n",
                  "metadata": {}
                },
                {
                  "type": "file",
                  "name": "spot-get-symbols.ts",
                  "path": "examples/Bitmart/Rest/Spot/spot-get-symbols.ts",
                  "code": "import { RestClient } from 'bitmart-api';\n\nconst client = new RestClient();\n\nasync function getTickers() {\n  try {\n    const tickers = await client.getSpotTickersV3();\n\n    console.log('Tickers: ', JSON.stringify(tickers, null, 2));\n  } catch (e) {\n    console.error('Req error: ', e);\n  }\n}\n\ngetTickers();\n",
                  "metadata": {}
                },
                {
                  "type": "file",
                  "name": "spot-submit-order.ts",
                  "path": "examples/Bitmart/Rest/Spot/spot-submit-order.ts",
                  "code": "import { RestClient } from 'bitmart-api';\n\nconst account = {\n  key: process.env.API_KEY || 'apiKeyHere',\n  secret: process.env.API_SECRET || 'apiSecretHere',\n  memo: process.env.API_MEMO || 'apiMemoHere',\n};\n\nasync function start() {\n  const client = new RestClient({\n    apiKey: account.key,\n    apiSecret: account.secret,\n    apiMemo: account.memo,\n  });\n\n  try {\n    // const usdValue = 6;\n    // const price = 52000;\n    // const qty = usdValue / price;\n\n    // const limitBuyOrder = {\n    //   symbol: 'BTC_USDT',\n    //   side: 'buy',\n    //   type: 'limit',\n    //   size: String(qty),\n    //   price: String(price),\n    // };\n\n    // const res = await client.submitSpotOrder({\n    //   symbol: 'BTC_USDT',\n    //   side: 'buy',\n    //   type: 'market',\n    //   size: String(qty),\n    // });\n\n    const res = await client.submitSpotOrderV2({\n      symbol: 'BTC_USDT',\n      side: 'sell',\n      type: 'market',\n      size: String(0.00011),\n    });\n    console.log('res ', JSON.stringify(res, null, 2));\n  } catch (e) {\n    console.error('Req error: ', e);\n  }\n}\n\nstart();\n",
                  "metadata": {}
                }
              ]
            }
          ]
        },
        {
          "type": "folder",
          "name": "Websocket",
          "path": "examples/Bitmart/Websocket",
          "children": [
            {
              "type": "file",
              "name": "ws-custom-logger.ts",
              "path": "examples/Bitmart/Websocket/ws-custom-logger.ts",
              "code": "import { DefaultLogger, LogParams, WebsocketClient } from 'bitmart-api';\n\n/** Optional, implement a custom logger */\nconst customLogger: typeof DefaultLogger = {\n  trace: (...params: LogParams): void => {\n    console.log('silly', ...params);\n  },\n  info: (...params: LogParams): void => {\n    console.info(params);\n  },\n  error: (...params: LogParams): void => {\n    console.error(params);\n  },\n};\n\nasync function start() {\n  const client = new WebsocketClient(undefined, customLogger);\n\n  client.on('open', (data) => {\n    console.log('open: ', data?.wsKey);\n  });\n\n  // Data received\n  client.on('update', (data) => {\n    console.info('update: ', data);\n  });\n\n  // Something happened, attempting to reconenct\n  client.on('reconnect', (data) => {\n    console.log('reconnect: ', data);\n  });\n\n  // Reconnect successful\n  client.on('reconnected', (data) => {\n    console.log('reconnected: ', data);\n  });\n\n  // Connection closed. If unexpected, expect reconnect -> reconnected.\n  client.on('close', (data) => {\n    console.error('close: ', data);\n  });\n\n  // Reply to a request, e.g. \"subscribe\"/\"unsubscribe\"/\"authenticate\"\n  client.on('response', (data) => {\n    console.info('response: ', data);\n  });\n\n  client.on('exception', (data) => {\n    console.error('exception: ', data);\n  });\n\n  client.on('authenticated', (data) => {\n    console.error('authenticated: ', data);\n  });\n\n  try {\n    client.subscribe('spot/ticker:BTC_USDT', 'spot');\n    //\n  } catch (e) {\n    console.error('Req error: ', e);\n  }\n}\n\nstart();\n",
              "metadata": {}
            },
            {
              "type": "file",
              "name": "ws-futures-private.ts",
              "path": "examples/Bitmart/Websocket/ws-futures-private.ts",
              "code": "import { DefaultLogger, LogParams, WebsocketClient } from 'bitmart-api';\n\nconst account = {\n  key: process.env.API_KEY || 'apiKeyHere',\n  secret: process.env.API_SECRET || 'apiSecretHere',\n  memo: process.env.API_MEMO || 'apiMemoHere',\n};\n\nDefaultLogger.trace = (...params: LogParams): void => {\n  console.log('silly', ...params);\n};\n\nasync function start() {\n  const client = new WebsocketClient({\n    apiKey: account.key,\n    apiSecret: account.secret,\n    apiMemo: account.memo,\n  });\n\n  client.on('open', (data) => {\n    console.log('connected ', data?.wsKey);\n  });\n\n  // Data received\n  client.on('update', (data) => {\n    console.info('data received: ', JSON.stringify(data));\n  });\n\n  // Something happened, attempting to reconenct\n  client.on('reconnect', (data) => {\n    console.log('reconnect: ', data);\n  });\n\n  // Reconnect successful\n  client.on('reconnected', (data) => {\n    console.log('reconnected: ', data);\n  });\n\n  // Connection closed. If unexpected, expect reconnect -> reconnected.\n  client.on('close', (data) => {\n    console.error('close: ', data);\n  });\n\n  // Reply to a request, e.g. \"subscribe\"/\"unsubscribe\"/\"authenticate\"\n  client.on('response', (data) => {\n    console.info('response: ', data);\n  });\n\n  client.on('exception', (data) => {\n    console.error('exception: ', data);\n  });\n\n  client.on('authenticated', (data) => {\n    console.error('authenticated: ', data);\n  });\n\n  try {\n    // Assets Channel\n    client.subscribe(\n      ['futures/asset:USDT', 'futures/asset:BTC', 'futures/asset:ETH'],\n      'futures',\n    );\n\n    // Position Channel\n    // client.subscribe('futures/position', 'futures');\n\n    // Order Channel\n    // client.subscribe('futures/order', 'futures');\n  } catch (e) {\n    console.error('Req error: ', e);\n  }\n}\n\nstart();\n",
              "metadata": {}
            },
            {
              "type": "file",
              "name": "ws-futures-public.ts",
              "path": "examples/Bitmart/Websocket/ws-futures-public.ts",
              "code": "import { WebsocketClient } from 'bitmart-api';\n\nasync function start() {\n  const client = new WebsocketClient();\n\n  client.on('open', (data) => {\n    console.log('connected ', data?.wsKey);\n  });\n\n  // Data received\n  client.on('update', (data) => {\n    console.info('data received: ', JSON.stringify(data));\n  });\n\n  // Something happened, attempting to reconenct\n  client.on('reconnect', (data) => {\n    console.log('reconnect: ', data);\n  });\n\n  // Reconnect successful\n  client.on('reconnected', (data) => {\n    console.log('reconnected: ', data);\n  });\n\n  // Connection closed. If unexpected, expect reconnect -> reconnected.\n  client.on('close', (data) => {\n    console.error('close: ', data);\n  });\n\n  // Reply to a request, e.g. \"subscribe\"/\"unsubscribe\"/\"authenticate\"\n  client.on('response', (data) => {\n    console.info('response: ', data);\n  });\n\n  client.on('exception', (data) => {\n    console.error('exception: ', data);\n  });\n\n  try {\n    // Ticker Channel\n    // client.subscribe('futures/ticker', 'futures');\n\n    // Depth Channel\n    // client.subscribe('futures/depth20:BTCUSDT', 'futures');\n\n    // Trade Channel\n    // client.subscribe('futures/trade:BTCUSDT', 'futures');\n\n    // KlineBin Channel\n    // client.subscribe('futures/klineBin1m:BTCUSDT', 'futures');\n\n    // Or have multiple topics in one array:\n    client.subscribe(\n      [\n        'futures/klineBin1m:BTCUSDT',\n        'futures/klineBin1m:ETHUSDT',\n        'futures/klineBin1m:XRPUSDT',\n        'futures/klineBin1m:BMXUSDT',\n        'futures/klineBin1m:SOLUSDT',\n      ],\n      'futures',\n    );\n  } catch (e) {\n    console.error('Req error: ', e);\n  }\n}\n\nstart();\n",
              "metadata": {}
            },
            {
              "type": "file",
              "name": "ws-spot-private.ts",
              "path": "examples/Bitmart/Websocket/ws-spot-private.ts",
              "code": "import { LogParams, WebsocketClient } from 'bitmart-api';\n\nconst account = {\n  key: process.env.API_KEY || 'apiKeyHere',\n  secret: process.env.API_SECRET || 'apiSecretHere',\n  memo: process.env.API_MEMO || 'apiMemoHere',\n};\n\nconst customLogger = {\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  trace: (...params: LogParams): void => {\n    console.log('trace', ...params);\n  },\n  info: (...params: LogParams): void => {\n    console.log('info', ...params);\n  },\n  error: (...params: LogParams): void => {\n    console.error('error', ...params);\n  },\n};\n\nasync function start() {\n  const client = new WebsocketClient(\n    {\n      apiKey: account.key,\n      apiSecret: account.secret,\n      apiMemo: account.memo,\n    },\n    customLogger,\n  );\n\n  client.on('open', (data) => {\n    console.log('connected ', data?.wsKey);\n  });\n\n  // Data received\n  client.on('update', (data) => {\n    console.info('data received: ', JSON.stringify(data));\n  });\n\n  // Something happened, attempting to reconenct\n  client.on('reconnect', (data) => {\n    console.log('reconnect: ', data);\n  });\n\n  // Reconnect successful\n  client.on('reconnected', (data) => {\n    console.log('reconnected: ', data);\n  });\n\n  // Connection closed. If unexpected, expect reconnect -> reconnected.\n  client.on('close', (data) => {\n    console.error('close: ', data);\n  });\n\n  // Reply to a request, e.g. \"subscribe\"/\"unsubscribe\"/\"authenticate\"\n  client.on('response', (data) => {\n    console.info('response: ', data);\n  });\n\n  client.on('exception', (data) => {\n    console.error('exception: ', data);\n  });\n\n  client.on('authenticated', (data) => {\n    console.error('authenticated: ', data);\n  });\n\n  try {\n    // order progress\n    client.subscribe('spot/user/order:BTC_USDT', 'spot');\n\n    // balance updates\n    // client.subscribe('spot/user/balance:BALANCE_UPDATE', 'spot');\n  } catch (e) {\n    console.error('Req error: ', e);\n  }\n}\n\nstart();\n",
              "metadata": {}
            },
            {
              "type": "file",
              "name": "ws-spot-public.ts",
              "path": "examples/Bitmart/Websocket/ws-spot-public.ts",
              "code": "import { WebsocketClient } from 'bitmart-api';\n\nasync function start() {\n  const client = new WebsocketClient();\n\n  client.on('open', (data) => {\n    console.log('open: ', data?.wsKey);\n\n    // Some topics allow requests, here's an example for sending a request\n    // const wsKey = 'spotPublicV1';\n    // if (data?.wsKey === wsKey) {\n    //   const depthIncreaseDataRequest: WsSpotOperation = {\n    //     op: 'request',\n    //     args: ['spot/depth/increase100:BTC_USDT'],\n    //   };\n\n    //   client.tryWsSend(\n    //     'spotPublicV1',\n    //     JSON.stringify(depthIncreaseDataRequest),\n    //   );\n    // }\n  });\n\n  // Data received\n  client.on('update', (data) => {\n    console.info('data received: ', JSON.stringify(data));\n  });\n\n  // Something happened, attempting to reconenct\n  client.on('reconnect', (data) => {\n    console.log('reconnect: ', data);\n  });\n\n  // Reconnect successful\n  client.on('reconnected', (data) => {\n    console.log('reconnected: ', data);\n  });\n\n  // Connection closed. If unexpected, expect reconnect -> reconnected.\n  client.on('close', (data) => {\n    console.error('close: ', data);\n  });\n\n  // Reply to a request, e.g. \"subscribe\"/\"unsubscribe\"/\"authenticate\"\n  client.on('response', (data) => {\n    console.info('response: ', data);\n  });\n\n  client.on('exception', (data) => {\n    console.error('exception: ', data);\n  });\n\n  try {\n    /**\n     * Use the client subscribe(topic, market) pattern to subscribe to any websocket topic.\n     *\n     * You can subscribe to topics one at a time:\n     */\n\n    // Ticker Channel\n    // client.subscribe('spot/ticker:BTC_USDT', 'spot');\n\n    // KLine/Candles Channel\n    // client.subscribe('spot/kline1m:BTC_USDT', 'spot');\n\n    // Depth-All Channel\n    // client.subscribe('spot/depth5:BTC_USDT', 'spot');\n\n    // Depth-Increase Channel\n    // client.subscribe('spot/depth/increase100:BTC_USDT', 'spot');\n\n    // Trade Channel\n    // client.subscribe('spot/trade:BTC_USDT', 'spot');\n\n    /**\n     * Or have multiple topics in one array, in a single request:\n     */\n    client.subscribe(\n      [\n        'spot/ticker:BTC_USDT',\n        'spot/ticker:ETH_USDT',\n        'spot/ticker:XRP_USDT',\n        'spot/ticker:BMX_USDT',\n        'spot/ticker:SOL_USDT',\n      ],\n      'spot',\n    );\n  } catch (e) {\n    console.error('Req error: ', e);\n  }\n}\n\nstart();\n",
              "metadata": {}
            }
          ]
        }
      ]
    },
    {
      "type": "folder",
      "name": "Bybit",
      "path": "examples/Bybit",
      "children": [
        {
          "type": "folder",
          "name": "Auth",
          "path": "examples/Bybit/Auth",
          "children": [
            {
              "type": "file",
              "name": "fasterHmacSign.ts",
              "path": "examples/Bybit/Auth/fasterHmacSign.ts",
              "code": "import { DefaultLogger, RestClientV5, WebsocketClient } from 'bybit-api';\nimport { createHmac } from 'crypto';\n\n// import { DefaultLogger, RestClientV5, WebsocketClient } from 'bybit-api';\n\n/**\n * Injecting a custom signMessage function.\n *\n * As of version 4.0.0 of the bybit-api Node.js/TypeScript/JavaScript\n * SDK for Bybit, the SDK uses the Web Crypto API for signing requests.\n * While it is compatible with Node and Browser environments, it is\n * slightly slower than using Node's native crypto module (only\n * available in backend Node environments).\n *\n * For latency sensitive users, you can inject the previous node crypto sign\n * method (or your own even faster-implementation), if this change affects you.\n *\n * This example demonstrates how to inject a custom sign function, to achieve\n * the same peformance as seen before the Web Crypto API was introduced.\n *\n * For context on standard usage, the \"signMessage\" function is used:\n * - During every single API call\n * - After opening a new private WebSocket connection\n *\n */\n\nconst key = process.env.API_KEY_COM;\nconst secret = process.env.API_SECRET_COM;\n\nconst restClient = new RestClientV5({\n  key: key,\n  secret: secret,\n  parseAPIRateLimits: true,\n  /**\n   * Set this to true to enable demo trading:\n   */\n  demoTrading: true,\n  /**\n   * Overkill in almost every case, but if you need any optimisation available,\n   * you can inject a faster sign mechanism such as node's native createHmac:\n   */\n  customSignMessageFn: async (message, secret) => {\n    return createHmac('sha256', secret).update(message).digest('hex');\n  },\n});\n\n// Optional, uncomment the \"trace\" override to log a lot more info about what the WS client is doing\nconst customLogger = {\n  ...DefaultLogger,\n  // trace: (...params) => console.log('trace', ...params),\n};\n\nconst wsClient = new WebsocketClient(\n  {\n    key: key,\n    secret: secret,\n    /**\n     * Set this to true to enable demo trading for the private account data WS\n     * Topics: order,execution,position,wallet,greeks\n     */\n    demoTrading: true,\n    /**\n     * Overkill in almost every case, but if you need any optimisation available,\n     * you can inject a faster sign mechanism such as node's native createHmac:\n     */\n    customSignMessageFn: async (message, secret) => {\n      return createHmac('sha256', secret).update(message).digest('hex');\n    },\n  },\n  customLogger,\n);\n\nfunction setWsClientEventListeners(\n  websocketClient: WebsocketClient,\n  accountRef: string,\n): Promise<void> {\n  return new Promise((resolve) => {\n    websocketClient.on('update', (data) => {\n      console.log(new Date(), accountRef, 'data ', JSON.stringify(data));\n      // console.log('raw message received ', JSON.stringify(data, null, 2));\n    });\n\n    websocketClient.on('open', (data) => {\n      console.log(\n        new Date(),\n        accountRef,\n        'connection opened open:',\n        data.wsKey,\n      );\n    });\n    websocketClient.on('response', (data) => {\n      console.log(\n        new Date(),\n        accountRef,\n        'log response: ',\n        JSON.stringify(data, null, 2),\n      );\n\n      if (typeof data.req_id === 'string') {\n        const topics = data.req_id.split(',');\n        if (topics.length) {\n          console.log(new Date(), accountRef, 'Subscribed to topics: ', topics);\n          return resolve();\n        }\n      }\n    });\n    websocketClient.on('reconnect', ({ wsKey }) => {\n      console.log(\n        new Date(),\n        accountRef,\n        'ws automatically reconnecting.... ',\n        wsKey,\n      );\n    });\n    websocketClient.on('reconnected', (data) => {\n      console.log(new Date(), accountRef, 'ws has reconnected ', data?.wsKey);\n    });\n    websocketClient.on('exception', (data) => {\n      console.error(new Date(), accountRef, 'ws exception: ', data);\n    });\n  });\n}\n\n(async () => {\n  try {\n    const onSubscribed = setWsClientEventListeners(wsClient, 'demoAcc');\n\n    wsClient.subscribeV5(['position', 'execution', 'wallet'], 'linear');\n\n    // Simple promise to ensure we're subscribed before trying anything else\n    await onSubscribed;\n\n    // Start trading\n    const balResponse1 = await restClient.getWalletBalance({\n      accountType: 'UNIFIED',\n    });\n    console.log('balResponse1: ', JSON.stringify(balResponse1, null, 2));\n\n    const demoFunds = await restClient.requestDemoTradingFunds();\n    console.log('requested demo funds: ', demoFunds);\n\n    const balResponse2 = await restClient.getWalletBalance({\n      accountType: 'UNIFIED',\n    });\n    console.log('balResponse2: ', JSON.stringify(balResponse2, null, 2));\n\n    /** Simple examples for private REST API calls with bybit's V5 REST APIs */\n    const response = await restClient.getPositionInfo({\n      category: 'linear',\n      symbol: 'BTCUSDT',\n    });\n\n    console.log('response:', response);\n\n    // Trade USDT linear perps\n    const buyOrderResult = await restClient.submitOrder({\n      category: 'linear',\n      symbol: 'BTCUSDT',\n      orderType: 'Market',\n      qty: '1',\n      side: 'Buy',\n    });\n    console.log('buyOrderResult:', buyOrderResult);\n\n    const sellOrderResult = await restClient.submitOrder({\n      category: 'linear',\n      symbol: 'BTCUSDT',\n      orderType: 'Market',\n      qty: '1',\n      side: 'Sell',\n    });\n    console.log('sellOrderResult:', sellOrderResult);\n\n    const balResponse3 = await restClient.getWalletBalance({\n      accountType: 'UNIFIED',\n    });\n    console.log('balResponse2: ', JSON.stringify(balResponse3, null, 2));\n  } catch (e) {\n    console.error('request failed: ', e);\n  }\n})();\n",
              "metadata": {}
            },
            {
              "type": "file",
              "name": "RSA-sign.ts",
              "path": "examples/Bybit/Auth/RSA-sign.ts",
              "code": "/**\n * Example demonstrating RSA authentication support in Bybit API client\n *\n * The client now automatically detects the key type and uses the appropriate\n * signing algorithm:\n * - HMAC keys (string): HMAC-SHA256 with hex encoding\n * - RSA keys (PEM format): RSA-SHA256 with base64 encoding\n */\n\nimport { RestClientV5 } from 'bybit-api';\n\n// Received after creating a new API key with a self-generated RSA public key on bybit\nconst api_key = 'your-api-key-here';\n\n// The self-generated RSA private key, this is never directly given to bybit, but used to generate a signature\n// Note: this MUST include the \"BEGIN PRIVATE KEY\" header so the SDK understands this is RSA auth\nconst rsaPrivateKey = `-----BEGIN PRIVATE KEY-----\nMIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQDEV3l9bqvoZU63\n2kclUF4GNTKhvolN9ddW+aL9Fc4fU0H/gmCOULGp1kMFh/w7wWcEUVIu5d+IRxJ+\n5g9pKlq+DDBuglJc/KGG3IlUXgcJs2JVXFI6MGgPEvdrUsvfc1D9QlmIfhJkgaXz\nVPhO+I1NyxfU/MpFXF4Ol6e3NQRbDsDlS/5Ox4tyNSSHgf8hLZRnaZVUPAvhlx7e\nhFPNDk9G1b5BotoN2Bii14kBMwG+R/rX1AAgl6WdoPNPT88MsoW+01qI93j9HGps\nMTAfolLDtBDHwUWlwzMoK4k+JPvmUcog3EiJyVuOtak9DDvf9lmS156K6okQlDQl\nHNmyTNo9AgMBAAECggEAMIVMhvinX4hPpoQ5Aknk3oRdhZasYFmBdKM/CevOUzP0\nUqQh3/GloirKx85mAU9neavuExxoPAmSUs1gYBUhNSeWfWzT1VpyQX11K6YL97P+\nuEkXIf2t7ZG6lqlwrAEXseqobSB4w6E9hU+JiJyIcQHgWxh4lSEBNnp4bkBaGfUx\nRquXlkZ/XM07+uiDTjMrPDnxAwZFRo/xl0edAhsAHqZiDCO4NUTM26bvxYMLPtNW\nttsCmrNdQXys85CALMgvslqGXAV6AtYChm4ZA+fnSeVx5X3SwieQmQUqNcQ3Z8E9\nKI3eUhQrIubIBKiVhD3wjLW53o43IfRuW4+CGmb5CQKBgQD4XphiZMxjv84VGyRL\nKS7v0IKcRNkShWAvCViLGhkbMOLSDg7UaZm21KIDogebmfrUzaMi5dKA6LuNpz1V\nWR2n/45CUogsYmLk9zwgCF4f4DIL5gnBEJKTZZMo4zk5EpsyDYvwFDNG2scsy9Cq\n4eketMN6IT3VeosweNOS2N0qpQKBgQDKX69fbJX6i2TvCowBTqCRIheuYNp4pkr0\nGNHzT2tizsaP7hSIQHfeY9qB+F7DMYa2MnBaIlJbPumiXa7busqg+FcTP6YOien9\nlIdv2u8Pr8PjdanPQvBl1eAJNuEKm/gM9O/jPQCwa65L9NtRLw+PjpY4tkGe3Wev\n5ORQOFuVuQKBgCiv1mbH/HOayDfM6nUlmfrPPZY78ROHpeoOreKbs+EwcPfYNbW2\nVugMjT3rHTPwVZbm2QKug316or7h1rpUjvcmdjeHLaeXtnurxL26oTC3mXs5g/+M\np3Zd/W2FS6p90c6xSWta48uHq3k7KkPUHkxZcGxhZa/DE2otYPt9az3BAoGAYXug\nDbZPtIWLFD6fXE3UuLSUdbI/6tgnyNdf4vVBxDHYoiJMD6oGU8ED05GhjCMCQief\nyTs5MqzmfAjmnv+mdc3KnAIP6nbymO0AJJhwibzf/mSCbM1Q4a0ZozalRqgE37Dp\nESwkddcY+Yu0TbH+q+dCY4UfrPf351m5xQ6wxzkCgYEAmVdilDWFYhY6b4S+IKLZ\n9OmY7i7/Rpq0U7IZmE6q/vwaEz0hKc/iAgci/s5Furyd/d/4ChPa3zr6mbjWGjTk\n77tJ39eN1eSascL06gvAK5lVym4hJD61HQXpyXEAm5D1liRtvNA8CDynXYU19C9j\nDj5BEbMNzhbwWKTxLDpqUso=\n-----END PRIVATE KEY-----`;\n\nconst client = new RestClientV5({\n  key: api_key,\n  secret: rsaPrivateKey,\n  testnet: true,\n});\n\n(async () => {\n  try {\n    console.log('private api call result: ', await client.getAccountInfo());\n  } catch (e) {\n    console.error('request failed: ', e);\n  }\n})();\n",
              "metadata": {}
            }
          ]
        },
        {
          "type": "folder",
          "name": "Rest",
          "path": "examples/Bybit/Rest",
          "children": [
            {
              "type": "file",
              "name": "demo-trading.ts",
              "path": "examples/Bybit/Rest/demo-trading.ts",
              "code": "import { DefaultLogger, RestClientV5, WebsocketClient } from 'bybit-api';\n\nconst key = process.env.API_KEY_COM;\nconst secret = process.env.API_SECRET_COM;\n\n/**\n *\n *\n * This example demonstrates how to use Bybit's demo trading functionality, both for REST and WS.\n *\n * Refer to the API docs for more information: https://bybit-exchange.github.io/docs/v5/demo\n *\n *\n */\n\nconst restClient = new RestClientV5({\n  key: key,\n  secret: secret,\n  parseAPIRateLimits: true,\n  /**\n   * Set this to true to enable demo trading:\n   */\n  demoTrading: true,\n});\n\n// Optional, uncomment the \"trace\" override to log a lot more info about what the WS client is doing\nconst customLogger = {\n  ...DefaultLogger,\n  // trace: (...params) => console.log('trace', ...params),\n};\n\nconst wsClient = new WebsocketClient(\n  {\n    key: key,\n    secret: secret,\n\n    /**\n     * Set this to true to enable demo trading for the private account data WS\n     * Topics: order,execution,position,wallet,greeks\n     */\n    demoTrading: true,\n  },\n  customLogger,\n);\n\nfunction setWsClientEventListeners(\n  websocketClient: WebsocketClient,\n  accountRef: string,\n): Promise<void> {\n  return new Promise((resolve) => {\n    websocketClient.on('update', (data) => {\n      console.log(new Date(), accountRef, 'data ', JSON.stringify(data));\n      // console.log('raw message received ', JSON.stringify(data, null, 2));\n    });\n\n    websocketClient.on('open', (data) => {\n      console.log(\n        new Date(),\n        accountRef,\n        'connection opened open:',\n        data.wsKey,\n      );\n    });\n    websocketClient.on('response', (data) => {\n      console.log(\n        new Date(),\n        accountRef,\n        'log response: ',\n        JSON.stringify(data, null, 2),\n      );\n\n      if (typeof data.req_id === 'string') {\n        const topics = data.req_id.split(',');\n        if (topics.length) {\n          console.log(new Date(), accountRef, 'Subscribed to topics: ', topics);\n          return resolve();\n        }\n      }\n    });\n    websocketClient.on('reconnect', ({ wsKey }) => {\n      console.log(\n        new Date(),\n        accountRef,\n        'ws automatically reconnecting.... ',\n        wsKey,\n      );\n    });\n    websocketClient.on('reconnected', (data) => {\n      console.log(new Date(), accountRef, 'ws has reconnected ', data?.wsKey);\n    });\n    websocketClient.on('exception', (data) => {\n      console.error(new Date(), accountRef, 'ws exception: ', data);\n    });\n  });\n}\n\n(async () => {\n  try {\n    const onSubscribed = setWsClientEventListeners(wsClient, 'demoAcc');\n\n    wsClient.subscribeV5(['position', 'execution', 'wallet'], 'linear');\n\n    // Simple promise to ensure we're subscribed before trying anything else\n    await onSubscribed;\n\n    // Start trading\n    const balResponse1 = await restClient.getWalletBalance({\n      accountType: 'UNIFIED',\n    });\n    console.log('balResponse1: ', JSON.stringify(balResponse1, null, 2));\n\n    const demoFunds = await restClient.requestDemoTradingFunds();\n    console.log('requested demo funds: ', demoFunds);\n\n    const balResponse2 = await restClient.getWalletBalance({\n      accountType: 'UNIFIED',\n    });\n    console.log('balResponse2: ', JSON.stringify(balResponse2, null, 2));\n\n    /** Simple examples for private REST API calls with bybit's V5 REST APIs */\n    const response = await restClient.getPositionInfo({\n      category: 'linear',\n      symbol: 'BTCUSDT',\n    });\n\n    console.log('response:', response);\n\n    // Trade USDT linear perps\n    const buyOrderResult = await restClient.submitOrder({\n      category: 'linear',\n      symbol: 'BTCUSDT',\n      orderType: 'Market',\n      qty: '1',\n      side: 'Buy',\n    });\n    console.log('buyOrderResult:', buyOrderResult);\n\n    const sellOrderResult = await restClient.submitOrder({\n      category: 'linear',\n      symbol: 'BTCUSDT',\n      orderType: 'Market',\n      qty: '1',\n      side: 'Sell',\n    });\n    console.log('sellOrderResult:', sellOrderResult);\n\n    const balResponse3 = await restClient.getWalletBalance({\n      accountType: 'UNIFIED',\n    });\n    console.log('balResponse2: ', JSON.stringify(balResponse3, null, 2));\n  } catch (e) {\n    console.error('request failed: ', e);\n  }\n})();\n",
              "metadata": {}
            },
            {
              "type": "file",
              "name": "rest-v5-all.ts",
              "path": "examples/Bybit/Rest/rest-v5-all.ts",
              "code": "import { RestClientV5 } from 'bybit-api';\n\nconst key = process.env.API_KEY_COM;\nconst secret = process.env.API_SECRET_COM;\n\nconst client = new RestClientV5({\n  key: key,\n  secret: secret,\n});\n\n/**\n * If you don't plan on making any private api calls,\n * you can instance the REST client without any parameters:\n *\n * const client = new RestClientV5();\n */\n\n(async () => {\n  try {\n    const klineResult = await client.getKline({\n      category: 'linear',\n      interval: '15',\n      symbol: 'BTCUSDT',\n    });\n    console.log('klineResult: ', klineResult);\n\n    const markPriceKlineResult = await client.getMarkPriceKline({\n      category: 'linear',\n      interval: '15',\n      symbol: 'BTCUSDT',\n    });\n    console.log('markPriceKlineResult: ', markPriceKlineResult);\n\n    const indexPriceKline = await client.getIndexPriceKline({\n      category: 'linear',\n      interval: '15',\n      symbol: 'BTCUSDT',\n    });\n    console.log('indexPriceKline: ', indexPriceKline);\n  } catch (e) {\n    console.error('request failed: ', e);\n  }\n})();\n",
              "metadata": {}
            },
            {
              "type": "file",
              "name": "rest-v5-custom-url.ts",
              "path": "examples/Bybit/Rest/rest-v5-custom-url.ts",
              "code": "import { RestClientV5 } from 'bybit-api';\n\n/**\n * The first parameter of the REST client allows you to pass any configuration parameters supported by the SDK.\n *\n * These include API keys, if you wish to use private endpoints, but also expose other features such as\n * setting a custom base URL (e.g. for Turkish users).\n *\n * Refer to the API documentation for a complete list of domains: https://bybit-exchange.github.io/docs/v5/guide#authentication\n */\nconst client = new RestClientV5({\n  /**\n   * You can pass a completely custom base URL,\n   * e.g. if you're trying to use a domain that hasn't been added yet (please let us know)\n   */\n  // baseUrl: 'https://api5.bybit.com',\n  //\n  //\n  /**\n   *\n   * There are also predefined API regions, which you can easily use with the \"apiRegion\" property:\n   *\n   */\n  //\n  //\n  // default: routes to api.bybit.com\n  // apiRegion: 'default',\n  //\n  //\n  // bytick: routes to api.bytick.com\n  // apiRegion: 'bytick',\n  //\n  //\n  // NL: routes to api.bybit.nl (for Netherland users)\n  // apiRegion: 'NL',\n  //\n  //\n  // HK: routes to api.byhkbit.com (for Hong Kong users)\n  // apiRegion: 'HK',\n  //\n  //\n  // TK: routes to api.bybit-tr.com (for Turkey users)\n  // apiRegion: 'TK',\n});\n\n(async () => {\n  try {\n    const time1 = await client.getServerTime();\n\n    console.log('time res: ', { time1 });\n  } catch (e) {\n    console.error('request failed: ', e);\n  }\n})();\n",
              "metadata": {}
            },
            {
              "type": "file",
              "name": "rest-v5-next-cursor.ts",
              "path": "examples/Bybit/Rest/rest-v5-next-cursor.ts",
              "code": "import { RestClientV5, UniversalTransferRecordV5 } from 'bybit-api';\n\nconst client = new RestClientV5({\n  testnet: false,\n  key: 'insert_api_key',\n  secret: 'insert_api_secret',\n});\n\nasync function getAllUniversalTransfers() {\n  const allTransfers: UniversalTransferRecordV5[] = [];\n  let nextCursor = '';\n  let pages = 0;\n\n  do {\n    pages++;\n    console.log(`Fetching data from page ${pages}`);\n    const response = await client.getUniversalTransferRecords({\n      limit: 50, // Maximum page size per request\n      cursor: nextCursor || undefined, // Only send cursor if we have one\n    });\n\n    if (response.result.list && response.result.list.length > 0) {\n      allTransfers.push(...response.result.list);\n    }\n\n    nextCursor = response.result.nextPageCursor;\n\n    // Optional: Add a small delay to avoid rate limits\n    await new Promise((resolve) => setTimeout(resolve, 100));\n  } while (nextCursor);\n\n  console.log('Total transfers fetched:', allTransfers.length);\n  console.log('All transfers:', allTransfers);\n}\n\ngetAllUniversalTransfers().catch(console.error);\n",
              "metadata": {}
            },
            {
              "type": "file",
              "name": "rest-v5-p2p.ts",
              "path": "examples/Bybit/Rest/rest-v5-p2p.ts",
              "code": "import { RestClientV5 } from 'bybit-api';\nimport fs from 'fs';\nimport path from 'path';\n\n// ENDPOINT: /v5/p2p/oss/upload_file\n// METHOD: POST\n// PUBLIC: NO\n// NOTE: Node.js only (Buffer required)\n\nconst key = process.env.API_KEY_COM;\nconst secret = process.env.API_SECRET_COM;\n\nconst client = new RestClientV5({\n  key: key,\n  secret: secret,\n});\n\nasync function uploadP2PChatFile() {\n  try {\n    // You must read the file yourself and pass the Buffer + filename\n    const filePath = './docs/images/logo1.png';\n    const fileBuffer = fs.readFileSync(filePath);\n\n    /**\n     *\n     *\n     *\n     *\n     *\n     *\n     */\n\n    // Test basic P2P API connectivity\n    const result0 = await client.getP2POrders({\n      page: 1,\n      size: 1,\n    });\n    console.log('Get P2P orders result:', result0);\n\n    // Example 1: Upload from file path\n    const result1 = await client.uploadP2PChatFile({\n      fileBuffer: fileBuffer,\n      fileName: path.basename(filePath), // Extract filename from path\n    });\n    console.log(\n      'Upload from file path result:',\n      JSON.stringify(result1, null, 2),\n    );\n\n    // Example 2: Upload with custom filename\n    // You control the filename sent to Bybit\n    const result2 = await client.uploadP2PChatFile({\n      fileBuffer: fileBuffer,\n      fileName: 'custom-name.png', // Use any filename you want\n    });\n    console.log('Upload with custom filename result:', result2);\n\n    // Example 3: Upload different file\n    const pdfBuffer = fs.readFileSync('./document.pdf');\n    const result3 = await client.uploadP2PChatFile({\n      fileBuffer: pdfBuffer,\n      fileName: 'document.pdf',\n    });\n    console.log('Upload PDF result:', result3);\n\n    // Supported file types (determined by filename extension):\n    // - Images: jpg, jpeg, png\n    // - Documents: pdf\n    // - Videos: mp4\n  } catch (e) {\n    console.error('Error uploading file:', e);\n  }\n}\n\nuploadP2PChatFile();\n",
              "metadata": {}
            },
            {
              "type": "file",
              "name": "rest-v5-private.ts",
              "path": "examples/Bybit/Rest/rest-v5-private.ts",
              "code": "import { RestClientV5 } from 'bybit-api';\n\nconst key = process.env.API_KEY_COM;\nconst secret = process.env.API_SECRET_COM;\n\nconst client = new RestClientV5({\n  key: key,\n  secret: secret,\n});\n\n(async () => {\n  try {\n    /** Simple examples for private REST API calls with bybit's V5 REST APIs */\n    const response = await client.getPositionInfo({\n      category: 'linear',\n      symbol: 'BTCUSDT',\n    });\n\n    console.log('response:', response);\n\n    // Trade USDT linear perps\n    const buyOrderResult = await client.submitOrder({\n      category: 'linear',\n      symbol: 'BTCUSDT',\n      orderType: 'Market',\n      qty: '1',\n      side: 'Buy',\n    });\n    console.log('buyOrderResult:', buyOrderResult);\n\n    const sellOrderResult = await client.submitOrder({\n      category: 'linear',\n      symbol: 'BTCUSDT',\n      orderType: 'Market',\n      qty: '1',\n      side: 'Sell',\n    });\n    console.log('sellOrderResult:', sellOrderResult);\n  } catch (e) {\n    console.error('request failed: ', e);\n  }\n})();\n",
              "metadata": {}
            },
            {
              "type": "file",
              "name": "rest-v5-proxies.ts",
              "path": "examples/Bybit/Rest/rest-v5-proxies.ts",
              "code": "import { RestClientV5 } from 'bybit-api';\n\nconst key = process.env.API_KEY_COM;\nconst secret = process.env.API_SECRET_COM;\n\nconst client = new RestClientV5(\n  {\n    key: key,\n    secret: secret,\n    parseAPIRateLimits: true,\n    testnet: true,\n    // Sometimes using a proxy introduces recv timestamp errors (due to the extra latency)\n    // If that happens, you can try increasing the recv window (which is 5000ms by default)\n    // recv_window: 10000,\n  },\n  {\n    /**\n     * Axios has a native way of supporting http/https proxies. It works for most proxy services but not all.\n     * If you have issues making any proxied requests this way, take a look at the rest-v5-proxies2.ts example using the https-proxy-agent.\n     */\n    proxy: {\n      protocol: 'http', // or 'https'\n      host: 'proxyhost',\n      port: Number('proxyport'),\n      auth: {\n        username: 'proxyuserifneeded',\n        password: 'proxypassifneeded',\n      },\n    },\n  },\n);\n\n(async () => {\n  try {\n    const res = await client.getWalletBalance({ accountType: 'UNIFIED' });\n\n    console.log('response: ', JSON.stringify(res, null, 2));\n\n    // const orders = await client.batchSubmitOrders('linear', [\n    //   {\n    //     symbol: 'ETHUSDT',\n    //     orderType: 'Limit',\n    //     side: 'Buy',\n    //     qty: '1',\n    //     orderIv: '6',\n    //     timeInForce: 'GTC',\n    //     orderLinkId: 'option-test-001',\n    //     mmp: false,\n    //     reduceOnly: false,\n    //   },\n    //   {\n    //     symbol: 'ETHUSDT',\n    //     orderType: 'Limit',\n    //     side: 'Sell',\n    //     qty: '2',\n    //     price: '700',\n    //     timeInForce: 'GTC',\n    //     orderLinkId: 'option-test-001',\n    //     mmp: false,\n    //     reduceOnly: false,\n    //   },\n    // ]);\n\n    // console.log('orders: ', JSON.stringify(orders, null, 2));\n  } catch (e) {\n    console.error('request failed: ', e);\n  }\n})();\n",
              "metadata": {}
            },
            {
              "type": "file",
              "name": "rest-v5-proxies2.ts",
              "path": "examples/Bybit/Rest/rest-v5-proxies2.ts",
              "code": "import { RestClientV5 } from 'bybit-api';\nimport { HttpsProxyAgent } from 'https-proxy-agent';\n\nconst key = process.env.API_KEY_COM;\nconst secret = process.env.API_SECRET_COM;\n\n/**\n * Some proxy services don't work with the proxy configuration that axios supports.\n *\n * For these, you can try using HttpsProxyAgent or SocksProxyAgent (depending on your proxy type, HTTP or SOCKS).\n *\n * The following example uses the HttpsProxyAgent (via the npm module https-proxy-agent).\n */\n\nconst proxyDetails = {\n  user: 'yourProxyUser',\n  pass: 'yourProxyPassword',\n  host: '127.0.0.1',\n  port: 31413,\n};\n\nconst proxyURL = `http://${proxyDetails.user}:${proxyDetails.pass}@${proxyDetails.host}:${proxyDetails.port}`;\nconst proxyAgent = new HttpsProxyAgent(proxyURL);\n\nconst client = new RestClientV5(\n  {\n    key: key,\n    secret: secret,\n    parseAPIRateLimits: true,\n    testnet: true,\n    // Sometimes using a proxy introduces recv timestamp errors (due to the extra latency)\n    // If that happens, you can try increasing the recv window (which is 5000ms by default)\n    // recv_window: 10000,\n  },\n  {\n    httpAgent: proxyAgent,\n    httpsAgent: proxyAgent,\n  },\n);\n\n(async () => {\n  try {\n    const res = await client.getWalletBalance({ accountType: 'UNIFIED' });\n\n    console.log('response: ', JSON.stringify(res, null, 2));\n  } catch (e) {\n    console.error('request failed: ', e);\n  }\n})();\n",
              "metadata": {}
            },
            {
              "type": "file",
              "name": "rest-v5-public.ts",
              "path": "examples/Bybit/Rest/rest-v5-public.ts",
              "code": "import { RestClientV5 } from 'bybit-api';\n\n/**\n * If you don't plan on making any private api calls,\n * you can instance the REST client without any parameters\n */\nconst client = new RestClientV5();\n\n(async () => {\n  try {\n    // const klineResult = await client.getKline({\n    //   category: 'linear',\n    //   interval: '15',\n    //   symbol: 'BTCUSDT',\n    // });\n    // console.log('klineResult: ', klineResult);\n\n    // const markPriceKlineResult = await client.getMarkPriceKline({\n    //   category: 'linear',\n    //   interval: '15',\n    //   symbol: 'BTCUSDT',\n    // });\n    // console.log('markPriceKlineResult: ', markPriceKlineResult);\n\n    // const indexPriceKline = await client.getIndexPriceKline({\n    //   category: 'linear',\n    //   interval: '15',\n    //   symbol: 'BTCUSDT',\n    // });\n    // console.log('indexPriceKline: ', indexPriceKline);\n\n    // const openInterest = await client.getOpenInterest({\n    //   category: 'linear',\n    //   symbol: 'BTCUSDT',\n    //   intervalTime: '5min',\n    // });\n\n    const tickers = await client.getTickers({ category: 'linear' });\n    // console.log(\n    //   JSON.stringify(\n    //     tickers.result.list.map((ticker) => ticker.symbol),\n    //     null,\n    //     2,\n    //   ),\n    // );\n\n    console.log('response', tickers);\n    // openInterest.result.list.forEach((row) => {\n    //   console.log('int: ', {\n    //     timestamp: row.timestamp,\n    //     value: row.openInterest,\n    //   });\n    // });\n    // console.log('openInterest: ', openInterest.result.list);\n  } catch (e) {\n    console.error('request failed: ', e);\n  }\n})();\n",
              "metadata": {}
            }
          ]
        },
        {
          "type": "folder",
          "name": "Websocket",
          "path": "examples/Bybit/Websocket",
          "children": [
            {
              "type": "folder",
              "name": "Private",
              "path": "examples/Bybit/Websocket/Private",
              "children": [
                {
                  "type": "file",
                  "name": "ws-private-v5.ts",
                  "path": "examples/Bybit/Websocket/Private/ws-private-v5.ts",
                  "code": "/* eslint-disable @typescript-eslint/no-empty-function */\nimport { DefaultLogger, WebsocketClient, WS_KEY_MAP } from 'bybit-api';\n\n// Create & inject a custom logger to enable the trace logging level (empty function)\nconst logger = {\n  ...DefaultLogger,\n  // trace: (...params) => console.log('trace', ...params),\n};\n\nconst key = process.env.API_KEY_COM;\nconst secret = process.env.API_SECRET_COM;\n\n/**\n * Prepare an instance of the WebSocket client. This client handles all aspects of connectivity for you:\n * - Connections are opened when you subscribe to topics\n * - If key & secret are provided, authentication is handled automatically\n * - If you subscribe to topics from different v5 products (e.g. spot and linear perps),\n *    subscription events are automatically routed to the different ws endpoints on bybit's side\n * - Heartbeats/ping/pong/reconnects are all handled automatically.\n *    If a connection drops, the client will clean it up, respawn a fresh connection and resubscribe for you.\n */\nconst wsClient = new WebsocketClient(\n  {\n    key: key,\n    secret: secret,\n    // testnet: false,\n    // demoTrading: false, // set testnet to false, if you plan on using demo trading\n  },\n  logger,\n);\n\nwsClient.on('update', (data) => {\n  console.log('raw message received ', JSON.stringify(data));\n  // console.log('raw message received ', JSON.stringify(data, null, 2));\n});\n\nwsClient.on('open', (data) => {\n  console.log('connection opened open:', data.wsKey);\n});\nwsClient.on('response', (data) => {\n  console.log('log response: ', JSON.stringify(data, null, 2));\n});\nwsClient.on('reconnect', ({ wsKey }) => {\n  console.log('ws automatically reconnecting.... ', wsKey);\n});\nwsClient.on('reconnected', (data) => {\n  console.log('ws has reconnected ', data?.wsKey);\n});\n// wsClient.on('exception', (data) => {\n//   console.error('ws exception: ', data);\n// });\n\n/**\n * For private V5 topics, us the subscribeV5() method on the ws client or use the original subscribe() method.\n *\n * Note: for private endpoints the \"category\" field is ignored since there is only one private endpoint\n * (compared to one public one per category).\n * The \"category\" is only needed for public topics since bybit has one endpoint for public events per category.\n */\n\nwsClient.subscribeV5('position', 'linear');\nwsClient.subscribeV5(['order', 'wallet', 'greeks'], 'linear');\n\nwsClient.subscribeV5('execution', 'linear');\n// wsClient.subscribeV5('execution.fast', 'linear');\n// wsClient.subscribeV5('execution.fast.linear', 'linear');\n\n/**\n * The following has the same effect as above, since there's only one private endpoint for V5 account topics:\n */\n// wsClient.subscribe('position');\n// wsClient.subscribe('execution');\n// wsClient.subscribe(['order', 'wallet', 'greek']);\n\n// To unsubscribe from topics (after a 5 second delay, in this example):\n// setTimeout(() => {\n//   console.log('unsubscribing');\n//   wsClient.unsubscribeV5('execution', 'linear');\n// }, 5 * 1000);\n\n// Topics are tracked per websocket type\n// Get a list of subscribed topics (e.g. for public v3 spot topics) (after a 5 second delay)\nsetTimeout(() => {\n  const activePrivateTopics = wsClient\n    .getWsStore()\n    .getTopics(WS_KEY_MAP.v5Private);\n  console.log('Active private v5 topics: ', activePrivateTopics);\n\n  const activePublicLinearTopics = wsClient\n    .getWsStore()\n    .getTopics(WS_KEY_MAP.v5LinearPublic);\n  console.log('Active public linear v5 topics: ', activePublicLinearTopics);\n\n  const activePublicSpotTopis = wsClient\n    .getWsStore()\n    .getTopics(WS_KEY_MAP.v5SpotPublic);\n  console.log('Active public spot v5 topics: ', activePublicSpotTopis);\n\n  const activePublicOptionsTopics = wsClient\n    .getWsStore()\n    .getTopics(WS_KEY_MAP.v5OptionPublic);\n  console.log('Active public option v5 topics: ', activePublicOptionsTopics);\n}, 5 * 1000);\n",
                  "metadata": {}
                }
              ]
            },
            {
              "type": "folder",
              "name": "Public",
              "path": "examples/Bybit/Websocket/Public",
              "children": [
                {
                  "type": "file",
                  "name": "ws-public-allLiquidations.ts",
                  "path": "examples/Bybit/Websocket/Public/ws-public-allLiquidations.ts",
                  "code": "import {\n  isWsAllLiquidationEvent,\n  RestClientV5,\n  WebsocketClient,\n} from 'bybit-api';\n\n//   RestClientV5,\n//   WebsocketClient,\n//   isWsAllLiquidationEvent,\n// } from 'bybit-api';\n\nfunction onAllLiquidationEvent(event: unknown) {\n  console.log(\n    new Date(),\n    'allLiquidationEvent',\n    JSON.stringify(event, null, 2),\n  );\n}\n\nconst wsClient = new WebsocketClient({});\n\nwsClient.on('update', (data) => {\n  if (isWsAllLiquidationEvent(data)) {\n    return onAllLiquidationEvent(data);\n  }\n\n  console.log('raw unahndled message received ', JSON.stringify(data));\n});\n\nwsClient.on('open', (data) => {\n  console.log('connection opened open:', data.wsKey);\n});\nwsClient.on('response', (data) => {\n  console.log('log response: ', JSON.stringify(data, null, 2));\n});\nwsClient.on('reconnect', ({ wsKey }) => {\n  console.log('ws automatically reconnecting.... ', wsKey);\n});\nwsClient.on('reconnected', (data) => {\n  console.log('ws has reconnected ', data?.wsKey);\n});\n\nwsClient.on('exception', (data) => {\n  console.error('ws exception: ', data);\n});\n\n/**\n *\n * If you want to receive data for all available symbols, this websocket topic\n * requires you to subscribe to each symbol individually.\n *\n * This can be easily automated by fetching a list of symbols via the REST client,\n * generating a list of topics (one per symbol), before simply passing an\n * array of topics to the websocket client per product group (linear & inverse perps).\n *\n */\nasync function start() {\n  const restClientV5 = new RestClientV5();\n\n  const allSymbolsV5ResultLinear = await restClientV5.getTickers({\n    category: 'linear',\n  });\n  const allSymbolsV5ResultInverse = await restClientV5.getTickers({\n    category: 'inverse',\n  });\n\n  const allLinearSymbols = allSymbolsV5ResultLinear.result.list.map(\n    (ticker) => ticker.symbol,\n  );\n  const allInverseSymbols = allSymbolsV5ResultInverse.result.list.map(\n    (ticker) => ticker.symbol,\n  );\n\n  console.log('all v5 linear symbols: ', JSON.stringify(allLinearSymbols));\n  console.log('all v5 inverse symbols: ', JSON.stringify(allInverseSymbols));\n\n  const TOPIC_NAME = 'allLiquidation';\n\n  // Make an array of topics ready for submission\n  const allLinearTopics = allLinearSymbols.map(\n    (symbol) => `${TOPIC_NAME}.${symbol}`,\n  );\n  const inverseTopics = allInverseSymbols.map(\n    (symbol) => `${TOPIC_NAME}.${symbol}`,\n  );\n\n  // subscribe to all linear symbols\n  wsClient.subscribeV5(allLinearTopics, 'linear');\n\n  // subscribe to all inverse symbols\n  wsClient.subscribeV5(inverseTopics, 'inverse');\n}\n\nstart().catch((e) => console.error('exception in main logic: ', e));\n",
                  "metadata": {}
                },
                {
                  "type": "file",
                  "name": "ws-public-v5.ts",
                  "path": "examples/Bybit/Websocket/Public/ws-public-v5.ts",
                  "code": "import { DefaultLogger, WebsocketClient, WS_KEY_MAP } from 'bybit-api';\n\nconst logger = {\n  ...DefaultLogger,\n  trace: (...params: any[]) => console.log('trace', ...params),\n};\n\n/**\n * Prepare an instance of the WebSocket client. This client handles all aspects of connectivity for you:\n * - Connections are opened when you subscribe to topics\n * - If key & secret are provided, authentication is handled automatically\n * - If you subscribe to topics from different v5 products (e.g. spot and linear perps),\n *    subscription events are automatically routed to the different ws endpoints on bybit's side\n * - Heartbeats/ping/pong/reconnects are all handled automatically.\n *    If a connection drops, the client will clean it up, respawn a fresh connection and resubscribe for you.\n */\n\nconst wsClient = new WebsocketClient({}, logger);\n\nwsClient.on('update', (data) => {\n  console.log('raw message received ', JSON.stringify(data));\n});\n\nwsClient.on('open', (data) => {\n  console.log('connection opened open:', data.wsKey);\n});\nwsClient.on('response', (data) => {\n  console.log('log response: ', JSON.stringify(data, null, 2));\n});\nwsClient.on('reconnect', ({ wsKey }) => {\n  console.log('ws automatically reconnecting.... ', wsKey);\n});\nwsClient.on('reconnected', (data) => {\n  console.log('ws has reconnected ', data?.wsKey);\n});\n\nwsClient.on('exception', (data) => {\n  console.error('ws exception: ', data);\n});\n\n/**\n * For public V5 topics, use the subscribeV5 method and include the API category this topic is for.\n * Category is required, since each category has a different websocket endpoint.\n */\n\n// Linear v5\n// -> Just one topic per call\n// wsClient.subscribeV5('orderbook.50.BTCUSDT', 'linear');\n\n// -> Or multiple topics in one call\n// wsClient.subscribeV5(\n//   ['orderbook.50.BTCUSDT', 'orderbook.50.ETHUSDT'],\n//   'linear'\n// );\n\n// Inverse v5\n// wsClient.subscribeV5('orderbook.50.BTCUSD', 'inverse');\n\n// Spot v5\n// wsClient.subscribeV5('orderbook.50.BTCUSDT', 'spot');\n\n// Option v5\n// wsClient.subscribeV5('publicTrade.BTC', 'option');\n\nconst topics = ['kline.5.XRPUSDT', 'kline.5.BTCUSDT', 'kline.5.ETHUSDT'];\n\n// Use the subscribeV5() call for most subscribe calls with v5 websockets\nwsClient.subscribeV5(topics, 'spot');\n\n// Alternatively, you can also use objects in the wsClient.subscribe() call\n// wsClient.subscribe({\n//   topic: 'orderook.50.BTCUSDT',\n//   category: 'spot',\n// });\n\n/**\n * For private V5 topics, just call the same subscribeV5() method on the ws client or use the original subscribe() method.\n *\n * Note: for private endpoints the \"category\" field is ignored since there is only one private endpoint\n * (compared to one public one per category)\n */\n\n// wsClient.subscribeV5('position', 'linear');\n// wsClient.subscribeV5('execution', 'linear');\n// wsClient.subscribeV5(['order', 'wallet', 'greek'], 'linear');\n\n// To unsubscribe from topics (after a 5 second delay, in this example):\nsetTimeout(() => {\n  console.log('unsubscribing');\n  wsClient.unsubscribeV5('kline.5.ETHUSDT', 'spot');\n}, 5 * 1000);\n\n// Topics are tracked per websocket type\n// Get a list of subscribed topics (e.g. for public v3 spot topics) (after a 5 second delay)\nsetTimeout(() => {\n  const activePrivateTopics = wsClient\n    .getWsStore()\n    .getTopics(WS_KEY_MAP.v5Private);\n\n  console.log('Active private v5 topics: ', activePrivateTopics);\n\n  const activePublicLinearTopics = wsClient\n    .getWsStore()\n    .getTopics(WS_KEY_MAP.v5LinearPublic);\n  console.log('Active public linear v5 topics: ', activePublicLinearTopics);\n\n  const activePublicSpotTopis = wsClient\n    .getWsStore()\n    .getTopics(WS_KEY_MAP.v5SpotPublic);\n  console.log('Active public spot v5 topics: ', activePublicSpotTopis);\n\n  const activePublicOptionsTopics = wsClient\n    .getWsStore()\n    .getTopics(WS_KEY_MAP.v5OptionPublic);\n  console.log('Active public option v5 topics: ', activePublicOptionsTopics);\n}, 15 * 1000);\n",
                  "metadata": {}
                }
              ]
            },
            {
              "type": "folder",
              "name": "WS-API",
              "path": "examples/Bybit/Websocket/WS-API",
              "children": [
                {
                  "type": "file",
                  "name": "ws-api-client.ts",
                  "path": "examples/Bybit/Websocket/WS-API/ws-api-client.ts",
                  "code": "import { DefaultLogger, WebsocketAPIClient } from 'bybit-api';\n\n// const { DefaultLogger, WebsocketAPIClient } = require('bybit-api');\n\nconst key = process.env.API_KEY_COM;\nconst secret = process.env.API_SECRET_COM;\n\n// function attachEventHandlers<TWSClient extends WebsocketClient>(\n//   wsClient: TWSClient,\n// ): void {\n//   wsClient.on('update', (data) => {\n//     console.log('raw message received ', JSON.stringify(data));\n//   });\n//   wsClient.on('open', (data) => {\n//     console.log('ws connected', data.wsKey);\n//   });\n//   wsClient.on('reconnect', ({ wsKey }) => {\n//     console.log('ws automatically reconnecting.... ', wsKey);\n//   });\n//   wsClient.on('reconnected', (data) => {\n//     console.log('ws has reconnected ', data?.wsKey);\n//   });\n//   wsClient.on('authenticated', (data) => {\n//     console.log('ws has authenticated ', data?.wsKey);\n//   });\n// }\n\nasync function main() {\n  // Optional\n  const logger = {\n    ...DefaultLogger,\n    // For a more detailed view of the WebsocketClient, enable the `trace` level by uncommenting the below line:\n    // trace: (...params) => console.log('trace', ...params),\n  };\n\n  const wsClient = new WebsocketAPIClient(\n    {\n      key: key,\n      secret: secret,\n      // testnet: true, // Whether to use the testnet environment: https://testnet.bybit.com/app/user/api-management\n\n      // Whether to use the livenet demo trading environment\n      // Note: As of Jan 2025, demo trading only supports consuming events, it does\n      // NOT support the WS API.\n      // demoTrading: false,\n\n      // If you want your own event handlers instead of the default ones with logs,\n      // disable this setting and see the `attachEventHandlers` example below:\n      // attachEventListeners: false\n    },\n    logger, // Optional: inject a custom logger\n  );\n\n  // Optional, see above \"attachEventListeners\". Attach basic event handlers, so nothing is left unhandled\n  // attachEventHandlers(wsClient.getWSClient());\n\n  // Optional, if you see RECV Window errors, you can use this to manage time issues.\n  // ! However, make sure you sync your system clock first!\n  // https://github.com/tiagosiebler/awesome-crypto-examples/wiki/Timestamp-for-this-request-is-outside-of-the-recvWindow\n  // wsClient.setTimeOffsetMs(-5000);\n\n  // Optional: prepare the WebSocket API connection in advance.\n  // This happens automatically but you can do this early before making any API calls, to prevent delays from a cold start.\n  // await wsClient.getWSClient().connectWSAPI();\n\n  try {\n    const response = await wsClient.submitNewOrder({\n      category: 'linear',\n      symbol: 'BTCUSDT',\n      orderType: 'Limit',\n      qty: '0.001',\n      side: 'Buy',\n      price: '50000',\n    });\n    console.log('submitNewOrder response: ', response);\n  } catch (e) {\n    console.log('submitNewOrder error: ', e);\n  }\n\n  try {\n    const response = await wsClient.amendOrder({\n      category: 'linear',\n      symbol: 'BTCUSDT',\n      orderId: 'b4b9e205-793c-4777-8112-0bf3c2d26b6e',\n      qty: '0.001',\n      price: '60000',\n    });\n    console.log('amendOrder response: ', response);\n  } catch (e) {\n    console.log('amendOrder error: ', e);\n  }\n\n  try {\n    const response = await wsClient.cancelOrder({\n      category: 'linear',\n      symbol: 'BTCUSDT',\n      orderId: 'b4b9e205-793c-4777-8112-0bf3c2d26b6e',\n    });\n    console.log('cancelOrder response: ', response);\n  } catch (e) {\n    console.log('cancelOrder error: ', e);\n  }\n\n  try {\n    const response = await wsClient.batchSubmitOrders('linear', [\n      {\n        symbol: 'BTCUSDT',\n        orderType: 'Limit',\n        qty: '0.001',\n        side: 'Buy',\n        price: '50000',\n      },\n      {\n        symbol: 'BTCUSDT',\n        orderType: 'Limit',\n        qty: '0.001',\n        side: 'Buy',\n        price: '60000',\n      },\n      {\n        symbol: 'BTCUSDT',\n        orderType: 'Limit',\n        qty: '0.001',\n        side: 'Buy',\n        price: '70000',\n      },\n    ]);\n    console.log('batchSubmitOrders response: ', response);\n  } catch (e) {\n    console.log('batchSubmitOrders error: ', e);\n  }\n\n  try {\n    const response = await wsClient.batchAmendOrder('linear', [\n      {\n        symbol: 'BTCUSDT',\n        orderId: '2473ee58',\n        price: '80000',\n      },\n      {\n        symbol: 'BTCUSDT',\n        orderId: 'b4b9e205-793c-4777-8112-0bf3c2d26b6e',\n        price: '80000',\n      },\n    ]);\n    console.log('batchAmendOrder response: ', response);\n  } catch (e) {\n    console.log('batchAmendOrder error: ', e);\n  }\n\n  try {\n    const response = await wsClient.batchCancelOrder('linear', [\n      {\n        symbol: 'BTCUSDT',\n        orderId: '2473ee58',\n      },\n      {\n        symbol: 'BTCUSDT',\n        orderId: 'b4b9e205-793c-4777-8112-0bf3c2d26b6e',\n      },\n    ]);\n    console.log('batchCancelOrder response: ', response);\n  } catch (e) {\n    console.log('batchCancelOrder error: ', e);\n  }\n}\n\nmain();\n",
                  "metadata": {}
                },
                {
                  "type": "file",
                  "name": "ws-api-raw-events.ts",
                  "path": "examples/Bybit/Websocket/WS-API/ws-api-raw-events.ts",
                  "code": "import { DefaultLogger, WebsocketClient, WS_KEY_MAP } from 'bybit-api';\n\nconst logger = {\n  ...DefaultLogger,\n  // For a more detailed view of the WebsocketClient, enable the `trace` level by uncommenting the below line:\n  // trace: (...params) => console.log('trace', ...params),\n};\n\nconst key = process.env.API_KEY;\nconst secret = process.env.API_SECRET;\n\nconst wsClient = new WebsocketClient(\n  {\n    key: key,\n    secret: secret,\n    // testnet: true, // Whether to use the testnet environment: https://testnet.bybit.com/app/user/api-management\n    // demoTrading: false, // note: As of Jan 2025, demo trading does NOT support the WS API\n  },\n  logger, // Optional: inject a custom logger\n);\n\n/**\n * General event handlers for monitoring the WebsocketClient\n */\nwsClient.on('update', (data) => {\n  console.log('raw message received ', JSON.stringify(data));\n});\nwsClient.on('open', (data) => {\n  console.log('ws connected', data.wsKey);\n});\nwsClient.on('reconnect', ({ wsKey }) => {\n  console.log('ws automatically reconnecting.... ', wsKey);\n});\nwsClient.on('reconnected', (data) => {\n  console.log('ws has reconnected ', data?.wsKey);\n});\nwsClient.on('authenticated', (data) => {\n  console.log('ws has authenticated ', data?.wsKey);\n});\n\nasync function main() {\n  /**\n   *\n   * This SDK's WebSocket API integration is event-driven at its core. You can treat the sentWSAPIRquest(...) method as\n   * a fire-and-forget method, to submit commands (create/amend/cancel order) via a WebSocket Connection.\n   *\n   * Replies to commands will show in the `response` event from the WebsocketClient's EventEmitter. Exceptions, however,\n   * will show in the `error` event from the WebsocketClient's EventEmitter.\n   *\n   * - Fire-and-forget a command.\n   * - Handle command results in the `response` event handler asynchronously as desired.\n   * - Handle any exceptions in a catch block.\n   *\n   * This is a more \"raw\" workflow in how WebSockets behave. For a more convenient & REST-like approach, using the\n   * promise-driven interface is recommended. See the `ws-api-raw-promises.ts` and `ws-api-client.ts` examples for a\n   * demonstration you can compare.\n   *\n   * Note: even without using promises, you should still tie on a .catch handler to each sendWSAPIRequest call, to prevent\n   * any unnecessary \"unhandled promise rejection\" exceptions.\n   *\n   */\n\n  // To make it easier to watch, wait a few seconds before sending the amend order\n  const AMEND_AFTER_SECONDS = 3;\n\n  // Then wait a few more before sending the cancel order\n  const CANCEL_AFTER_SECONDS = 5;\n\n  // Exceptions including rejected commands will show here (as well as the catch handler used below)\n  wsClient.on('exception', (data) => {\n    console.error('ws exception: ', data);\n  });\n\n  // Replies to commands will show here\n  wsClient.on('response', (data) => {\n    console.log('received reply to command: ', JSON.stringify(data, null, 2));\n  });\n\n  /**\n   *\n   * If you haven't connected yet, the WebsocketClient will automatically connect and authenticate you as soon as you send\n   * your first command. That connection will then be reused for every command you send, unless the connection drops - then\n   * it will automatically be replaced with a healthy connection.\n   *\n   * This \"not connected yet\" scenario can add an initial delay to your first command. If you want to prepare a connection\n   * in advance, you can ask the WebsocketClient to prepare it before you start submitting commands. This is optional.\n   *\n   * Repeated note: even without using promises, you should still tie on a .catch handler to each sendWSAPIRequest call, to prevent\n   * any unnecessary \"unhandled promise rejection\" exceptions.\n   *\n   */\n\n  // Optional, see above. Can be used to prepare a connection before sending commands\n  await wsClient.connectWSAPI();\n\n  console.log('Step 1: Create an order');\n\n  // Fire and forget the create.order command\n  // Even without using promises, you should still \"catch\" exceptions (although no need to await anything you send)\n  wsClient\n    .sendWSAPIRequest(WS_KEY_MAP.v5PrivateTrade, 'order.create', {\n      symbol: 'BTCUSDT',\n      side: 'Buy',\n      orderType: 'Limit',\n      price: '50000',\n      qty: '1',\n      category: 'linear',\n    })\n    .catch((e) => console.error('Step 1: Order submit exception: ', e));\n\n  console.log('Step 1: Create order sent...');\n\n  //\n  setTimeout(() => {\n    console.log('Step 2: Amend an order');\n\n    // Fire and forget the order.amend command\n    // For simplicity, the orderId is hardcoded here (and will probably not work)\n    wsClient\n      .sendWSAPIRequest(WS_KEY_MAP.v5PrivateTrade, 'order.amend', {\n        symbol: 'BTCUSDT',\n        category: 'linear',\n        orderId: '1234567',\n        price: '55000',\n      })\n      .catch((e) => console.error('Step 2: Amend order exception: ', e));\n\n    console.log('Step 2: Amend order sent...');\n  }, AMEND_AFTER_SECONDS * 1000);\n\n  //\n  setTimeout(() => {\n    console.log('Step 3: Cancel an order');\n\n    // Fire and forget the order.cancel command\n    // For simplicity, the orderId is hardcoded here (and will probably not work)\n    wsClient\n      .sendWSAPIRequest(WS_KEY_MAP.v5PrivateTrade, 'order.cancel', {\n        category: 'linear',\n        symbol: 'BTCUSDT',\n        orderId: '1234567',\n      })\n      .catch((e) => console.error('Step 3: Cancel order exception: ', e));\n\n    console.log('Step 3: Cancel order sent...');\n  }, CANCEL_AFTER_SECONDS * 1000);\n}\n\n// Start executing the example workflow\nmain();\n",
                  "metadata": {}
                },
                {
                  "type": "file",
                  "name": "ws-api-raw-promises.ts",
                  "path": "examples/Bybit/Websocket/WS-API/ws-api-raw-promises.ts",
                  "code": "import { DefaultLogger, WebsocketClient, WS_KEY_MAP } from 'bybit-api';\n\nconst logger = {\n  ...DefaultLogger,\n  // For a more detailed view of the WebsocketClient, enable the `trace` level by uncommenting the below line:\n  // trace: (...params) => console.log('trace', ...params),\n};\n\nconst key = process.env.API_KEY;\nconst secret = process.env.API_SECRET;\n\nconst wsClient = new WebsocketClient(\n  {\n    key: key,\n    secret: secret,\n    // testnet: true, // Whether to use the testnet environment: https://testnet.bybit.com/app/user/api-management\n    // demoTrading: false, // note: As of Jan 2025, demo trading does NOT support the WS API\n  },\n  logger, // Optional: inject a custom logger\n);\n\n/**\n * General event handlers for monitoring the WebsocketClient\n */\nwsClient.on('update', (data) => {\n  console.log('raw message received ', JSON.stringify(data));\n});\nwsClient.on('open', (data) => {\n  console.log('ws connected', data.wsKey);\n});\nwsClient.on('reconnect', ({ wsKey }) => {\n  console.log('ws automatically reconnecting.... ', wsKey);\n});\nwsClient.on('reconnected', (data) => {\n  console.log('ws has reconnected ', data?.wsKey);\n});\nwsClient.on('authenticated', (data) => {\n  console.log('ws has authenticated ', data?.wsKey);\n});\nwsClient.on('exception', (data) => {\n  console.error('ws exception: ', data);\n});\n\nasync function main() {\n  /**\n   *\n   * This SDK's WebSocket API integration can connect WS API responses to the request that caused them. Each call\n   * to the `sendWSAPIRequest(...)` method returns a promise.\n   *\n   * This promise will resolve when the matching response is detected, and reject if an exception for that request\n   * is detected. This allows using Bybit's Websocket API in the same way that a REST API normally works.\n   *\n   * Send a command and immediately await the result. Handle any exceptions in a catch block.\n   *\n   * TypeScript users can benefit from smart type flowing for increased type safety & convenience:\n   * - Request parameters are fully typed, depending on the operation in the second parameter to the call. E.g.\n   * the `order.create` operation will automatically require the params to match the `OrderParamsV5` interface.\n   *\n   * - Response parameters are fully typed, depending on the operation in the second parameter. E.g the `order.create`\n   * operation will automatically map the returned value to `WSAPIResponse<OrderResultV5, \"order.create\">`.\n   *\n   */\n\n  // To make it easier to watch, wait a few seconds before sending the amend order\n  const AMEND_AFTER_SECONDS = 5;\n\n  // Then wait a few more before sending the cancel order\n  const CANCEL_AFTER_SECONDS = 10;\n\n  /**\n   *\n   * If you haven't connected yet, the WebsocketClient will automatically connect and authenticate you as soon as you send\n   * your first command. That connection will then be reused for every command you send, unless the connection drops - then\n   * it will automatically be replaced with a healthy connection.\n   *\n   * This \"not connected yet\" scenario can add an initial delay to your first command. If you want to prepare a connection\n   * in advance, you can ask the WebsocketClient to prepare it before you start submitting commands. This is optional.\n   *\n   */\n\n  // Optional, see above. Can be used to prepare a connection before sending commands\n  await wsClient.connectWSAPI();\n\n  /**\n   * Create a new order\n   */\n\n  let orderId: string | undefined;\n\n  try {\n    console.log('Step 1: Create an order');\n\n    // The type for `wsAPISubmitOrderResult` is automatically resolved to `WSAPIResponse<OrderResultV5, \"order.create\">`\n    const wsAPISubmitOrderResult = await wsClient.sendWSAPIRequest(\n      WS_KEY_MAP.v5PrivateTrade,\n      'order.create',\n      {\n        symbol: 'BTCUSDT',\n        side: 'Buy',\n        orderType: 'Limit',\n        price: '50000',\n        qty: '1',\n        category: 'linear',\n      },\n    );\n\n    // Save the orderId for the next call\n    orderId = wsAPISubmitOrderResult.data.orderId;\n\n    console.log(\n      `Step 1: Order result (order ID: \"${orderId}\"): `,\n      wsAPISubmitOrderResult,\n    );\n  } catch (e) {\n    console.error('Step 1: Order submit exception: ', e);\n    return;\n  }\n\n  setTimeout(async () => {\n    try {\n      console.log('Step 2: Amend an order');\n\n      // The type for `wsAPIAmendOrderResult` is automatically resolved to `WSAPIResponse<OrderResultV5, \"order.amend\">`\n      const wsAPIAmendOrderResult = await wsClient.sendWSAPIRequest(\n        WS_KEY_MAP.v5PrivateTrade,\n        'order.amend',\n        {\n          symbol: 'BTCUSDT',\n          category: 'linear',\n          orderId,\n          price: '55000',\n        },\n      );\n\n      // Save the orderId for the next call\n      orderId = wsAPIAmendOrderResult.data.orderId;\n\n      console.log(\n        `Step 2: Amend result (order ID: \"${orderId}\"): `,\n        wsAPIAmendOrderResult,\n      );\n    } catch (e) {\n      console.error('Step 2: Amend order exception: ', e);\n      return;\n    }\n  }, AMEND_AFTER_SECONDS * 1000);\n\n  setTimeout(async () => {\n    try {\n      console.log('Step 3: Cancel an order');\n\n      // The type for `wsAPICancelOrderResult` is automatically resolved to `WSAPIResponse<OrderResultV5, \"order.cancel\">`\n      const wsAPICancelOrderResult = await wsClient.sendWSAPIRequest(\n        WS_KEY_MAP.v5PrivateTrade,\n        'order.cancel',\n        {\n          category: 'linear',\n          symbol: 'BTCUSDT',\n          orderId,\n        },\n      );\n\n      console.log('Step 3: Cancel result:', wsAPICancelOrderResult);\n    } catch (e) {\n      console.error('Step 3: Cancel order exception: ', e);\n    }\n\n    process.exit(-1);\n  }, CANCEL_AFTER_SECONDS * 1000);\n}\n\n// Start executing the example workflow\nmain();\n",
                  "metadata": {}
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "type": "folder",
      "name": "Coinbase",
      "path": "examples/Coinbase",
      "children": [
        {
          "type": "folder",
          "name": "AdvancedTrade",
          "path": "examples/Coinbase/AdvancedTrade",
          "children": [
            {
              "type": "folder",
              "name": "Private",
              "path": "examples/Coinbase/AdvancedTrade/Private",
              "children": [
                {
                  "type": "file",
                  "name": "closePosition.ts",
                  "path": "examples/Coinbase/AdvancedTrade/Private/closePosition.ts",
                  "code": "import { CBAdvancedTradeClient } from 'coinbase-api';\n\n// initialise the client\n/**\n *\n * You can add both ED25519 and ECDSA keys, client will recognize both types of keys\n *\n * ECDSA:\n *\n * {\n *   apiKey: 'organizations/your_org_id/apiKeys/your_api_key_id',\n *   apiSecret:\n *     '-----BEGIN EC PRIVATE KEY-----\\nMHcCAQEEIPT/TTZPxw0kDGvpuCENJp9A4/2INAt9/QKKfyidTWM8oAoGCCqGSM49\\nAwEHoUQDQgAEd+cnxrKl536ly5eYBi+8dvXt1MJXYRo+/v38h9HrFKVGBRndU9DY\\npV357xIfqeJEzb/MBuk3EW8cG9RTrYBwjg==\\n-----END EC PRIVATE KEY-----\\n',\n * }\n *\n * ED25519:\n * {\n *   apiKey: 'your-api-key-id',\n *   apiSecret: 'yourExampleApiSecretEd25519Version==',\n * }\n *\n *\n */\nconst client = new CBAdvancedTradeClient({\n  apiKey: process.env.API_KEY_NAME || 'insert_api_key_here',\n  apiSecret: process.env.API_PRIVATE_KEY || 'insert_api_secret_here',\n});\n\n// this function is suggested to used with spot market orders\n// If you want to close futures, it is recommended to use submitOrder() with the opposite side of the current position\n\n/* Closing Futures Positions - Exchange docs\nWhen a contract expires, we automatically close your open position at the exchange settlement price.\nYou can also close your position before the contract expires\n(for example, you may want to close your position if youve reached your profit target,\nyou want to prevent further losses, or you need to satisfy a margin requirement).\n\nThere are two ways to close your futures positions:\n(1) Close your position with this endpoint, or\n(2) Create a separate trade to take the opposite position in the same futures contract you are currently holding in your account.\nFor example, to close an open long position in the BTC 23 Feb 24 contract, place an order to sell the same number of BTC 23 Feb 24 contracts.\nIf you were short to begin with, go long the same number of contracts to close your position.\n\nMore info on https://docs.cdp.coinbase.com/advanced-trade/reference/retailbrokerageapi_closeposition#closing-futures-positions */\n\nasync function closePosition() {\n  try {\n    // close position\n    const closePosition = await client.closePosition({\n      product_id: 'BTC-USD',\n      size: '0.1',\n      client_order_id: client.generateNewOrderId(),\n    });\n    console.log('Result: ', closePosition);\n  } catch (e) {\n    console.error('Send new order error: ', e);\n  }\n\n  //\n}\n\nclosePosition();\n",
                  "metadata": {}
                },
                {
                  "type": "file",
                  "name": "getAccounts.ts",
                  "path": "examples/Coinbase/AdvancedTrade/Private/getAccounts.ts",
                  "code": "import { CBAdvancedTradeClient } from 'coinbase-api';\n\n// initialise the client\n/**\n *\n * You can add both ED25519 and ECDSA keys, client will recognize both types of keys\n *\n * ECDSA:\n *\n * {\n *   apiKey: 'organizations/your_org_id/apiKeys/your_api_key_id',\n *   apiSecret:\n *     '-----BEGIN EC PRIVATE KEY-----\\nMHcCAQEEIPT/TTZPxw0kDGvpuCENJp9A4/2INAt9/QKKfyidTWM8oAoGCCqGSM49\\nAwEHoUQDQgAEd+cnxrKl536ly5eYBi+8dvXt1MJXYRo+/v38h9HrFKVGBRndU9DY\\npV357xIfqeJEzb/MBuk3EW8cG9RTrYBwjg==\\n-----END EC PRIVATE KEY-----\\n',\n * }\n *\n * ED25519:\n * {\n *   apiKey: 'your-api-key-id',\n *   apiSecret: 'yourExampleApiSecretEd25519Version==',\n * }\n *\n *\n */\nconst client = new CBAdvancedTradeClient({\n  apiKey: process.env.API_KEY_NAME || 'insert_api_key_here',\n  apiSecret: process.env.API_PRIVATE_KEY || 'insert_api_secret_here',\n});\n\nasync function getAccounts() {\n  try {\n    // Get all accounts\n    const accounts = await client.getAccounts({ limit: 10 });\n    console.log('Accounts: ', accounts);\n\n    // Get specific account details\n    if (accounts.accounts.length > 0) {\n      const accountId = accounts.accounts[0].uuid;\n      const accountDetails = await client.getAccount({ account_id: accountId });\n      console.log('Account Details: ', accountDetails);\n    }\n  } catch (e) {\n    console.error('Get accounts error: ', e);\n  }\n}\n\ngetAccounts();\n",
                  "metadata": {}
                },
                {
                  "type": "file",
                  "name": "getOrders.ts",
                  "path": "examples/Coinbase/AdvancedTrade/Private/getOrders.ts",
                  "code": "import { CBAdvancedTradeClient } from 'coinbase-api';\n\n// initialise the client\n/**\n *\n * You can add both ED25519 and ECDSA keys, client will recognize both types of keys\n *\n * ECDSA:\n *\n * {\n *   apiKey: 'organizations/your_org_id/apiKeys/your_api_key_id',\n *   apiSecret:\n *     '-----BEGIN EC PRIVATE KEY-----\\nMHcCAQEEIPT/TTZPxw0kDGvpuCENJp9A4/2INAt9/QKKfyidTWM8oAoGCCqGSM49\\nAwEHoUQDQgAEd+cnxrKl536ly5eYBi+8dvXt1MJXYRo+/v38h9HrFKVGBRndU9DY\\npV357xIfqeJEzb/MBuk3EW8cG9RTrYBwjg==\\n-----END EC PRIVATE KEY-----\\n',\n * }\n *\n * ED25519:\n * {\n *   apiKey: 'your-api-key-id',\n *   apiSecret: 'yourExampleApiSecretEd25519Version==',\n * }\n *\n *\n */\nconst client = new CBAdvancedTradeClient({\n  apiKey: process.env.API_KEY_NAME || 'insert_api_key_here',\n  apiSecret: process.env.API_PRIVATE_KEY || 'insert_api_secret_here',\n});\n\nasync function getOrders() {\n  try {\n    // Get all orders\n    const orders = await client.getOrders({ limit: 5 });\n    console.log('Orders: ', orders);\n\n    // Get order details\n    if (orders.orders.length > 0) {\n      const orderId = orders.orders[0].order_id;\n      const orderDetails = await client.getOrder({ order_id: orderId });\n      console.log('Order Details: ', orderDetails);\n    }\n  } catch (e) {\n    console.error('Error: ', e);\n  }\n}\n\ngetOrders();\n",
                  "metadata": {}
                },
                {
                  "type": "file",
                  "name": "submitOrderPerps.ts",
                  "path": "examples/Coinbase/AdvancedTrade/Private/submitOrderPerps.ts",
                  "code": "import { CBAdvancedTradeClient } from 'coinbase-api';\n\n// initialise the client\n/**\n *\n * You can add both ED25519 and ECDSA keys, client will recognize both types of keys\n *\n * ECDSA:\n *\n * {\n *   apiKey: 'organizations/your_org_id/apiKeys/your_api_key_id',\n *   apiSecret:\n *     '-----BEGIN EC PRIVATE KEY-----\\nMHcCAQEEIPT/TTZPxw0kDGvpuCENJp9A4/2INAt9/QKKfyidTWM8oAoGCCqGSM49\\nAwEHoUQDQgAEd+cnxrKl536ly5eYBi+8dvXt1MJXYRo+/v38h9HrFKVGBRndU9DY\\npV357xIfqeJEzb/MBuk3EW8cG9RTrYBwjg==\\n-----END EC PRIVATE KEY-----\\n',\n * }\n *\n * ED25519:\n * {\n *   apiKey: 'your-api-key-id',\n *   apiSecret: 'yourExampleApiSecretEd25519Version==',\n * }\n *\n *\n */\nconst client = new CBAdvancedTradeClient({\n  apiKey: process.env.API_KEY_NAME || 'insert_api_key_here',\n  apiSecret: process.env.API_PRIVATE_KEY || 'insert_api_secret_here',\n});\n\nasync function submitOrder() {\n  try {\n    // submit market futures order\n    const newOrder = await client.submitOrder({\n      product_id: 'BTC-USDT',\n      order_configuration: { market_market_ioc: { base_size: '0.001' } },\n      side: 'SELL',\n      client_order_id: client.generateNewOrderId(),\n    });\n    console.log('Result: ', newOrder);\n  } catch (e) {\n    console.error('Send new order error: ', e);\n  }\n\n  //\n}\n\nasync function submitLimitOrder() {\n  try {\n    // Submit limit futures order\n    const limitOrder = await client.submitOrder({\n      product_id: 'BTC-USDT',\n      order_configuration: {\n        limit_limit_gtc: {\n          base_size: '0.001',\n          limit_price: '50000.00',\n        },\n      },\n      side: 'BUY',\n      client_order_id: client.generateNewOrderId(),\n    });\n    console.log('Limit Order Result: ', limitOrder);\n  } catch (e) {\n    console.error('Submit limit order error: ', e);\n  }\n}\n\nsubmitLimitOrder();\n\nsubmitOrder();\n",
                  "metadata": {}
                },
                {
                  "type": "file",
                  "name": "submitOrderSpot.ts",
                  "path": "examples/Coinbase/AdvancedTrade/Private/submitOrderSpot.ts",
                  "code": "import { CBAdvancedTradeClient } from 'coinbase-api';\n\n// initialise the client\n/**\n *\n * You can add both ED25519 and ECDSA keys, client will recognize both types of keys\n *\n * ECDSA:\n *\n * {\n *   apiKey: 'organizations/your_org_id/apiKeys/your_api_key_id',\n *   apiSecret:\n *     '-----BEGIN EC PRIVATE KEY-----\\nMHcCAQEEIPT/TTZPxw0kDGvpuCENJp9A4/2INAt9/QKKfyidTWM8oAoGCCqGSM49\\nAwEHoUQDQgAEd+cnxrKl536ly5eYBi+8dvXt1MJXYRo+/v38h9HrFKVGBRndU9DY\\npV357xIfqeJEzb/MBuk3EW8cG9RTrYBwjg==\\n-----END EC PRIVATE KEY-----\\n',\n * }\n *\n * ED25519:\n * {\n *   apiKey: 'your-api-key-id',\n *   apiSecret: 'yourExampleApiSecretEd25519Version==',\n * }\n *\n *\n */\nconst client = new CBAdvancedTradeClient({\n  apiKey: process.env.API_KEY_NAME || 'insert_api_key_here',\n  apiSecret: process.env.API_PRIVATE_KEY || 'insert_api_secret_here',\n});\n\nasync function submitOrder() {\n  try {\n    // submit market spot order\n    const newOrder = await client.submitOrder({\n      product_id: 'BTC-USDT',\n      order_configuration: { market_market_ioc: { base_size: '0.001' } },\n      side: 'SELL',\n      client_order_id: client.generateNewOrderId(),\n    });\n    console.log('Result: ', newOrder);\n  } catch (e) {\n    console.error('Send new order error: ', e);\n  }\n\n  //\n}\n\nasync function submitLimitOrder() {\n  try {\n    // Submit limit spot order\n    const limitOrder = await client.submitOrder({\n      product_id: 'BTC-USDT',\n      order_configuration: {\n        limit_limit_gtc: {\n          base_size: '0.001',\n          limit_price: '50000.00',\n        },\n      },\n      side: 'BUY',\n      client_order_id: client.generateNewOrderId(),\n    });\n    console.log('Limit Order Result: ', limitOrder);\n  } catch (e) {\n    console.error('Submit limit order error: ', e);\n  }\n}\n\nsubmitLimitOrder();\n\nsubmitOrder();\n",
                  "metadata": {}
                }
              ]
            },
            {
              "type": "folder",
              "name": "Public",
              "path": "examples/Coinbase/AdvancedTrade/Public",
              "children": [
                {
                  "type": "file",
                  "name": "advanced-public-rest-all.ts",
                  "path": "examples/Coinbase/AdvancedTrade/Public/advanced-public-rest-all.ts",
                  "code": "import { CBAdvancedTradeClient } from 'coinbase-api';\n\n// you can initialise public client without api keys as public calls do not require auth\nconst client = new CBAdvancedTradeClient({});\n\nasync function publicCalls() {\n  try {\n    // Get server time\n    const serverTime = await client.getServerTime();\n    console.log('Server Time: ', serverTime);\n\n    // Get public product book\n    const productBook = await client.getPublicProductBook({\n      product_id: 'BTC-USD',\n      limit: 10,\n    });\n    console.log('Public Product Book: ', productBook);\n\n    // List all public products\n    const publicProducts = await client.getPublicProducts();\n    console.log('Public Products: ', publicProducts);\n\n    // Get single public product\n    const publicProduct = await client.getPublicProduct({\n      product_id: 'BTC-USD',\n    });\n    console.log('Public Product: ', publicProduct);\n\n    // Get public product candles\n    const productCandles = await client.getPublicProductCandles({\n      product_id: 'BTC-USD',\n      granularity: 'ONE_MINUTE',\n      start: '1725976550',\n      end: '1725977550',\n    });\n    console.log('Public Product Candles: ', productCandles);\n\n    // Get public market trades\n    const marketTrades = await client.getPublicMarketTrades({\n      product_id: 'BTC-USD',\n      limit: 10,\n    });\n    console.log('Public Market Trades: ', marketTrades);\n  } catch (e) {\n    console.error('Error: ', e);\n  }\n}\n\npublicCalls();\n",
                  "metadata": {}
                }
              ]
            },
            {
              "type": "folder",
              "name": "WebSockets",
              "path": "examples/Coinbase/AdvancedTrade/WebSockets",
              "children": [
                {
                  "type": "file",
                  "name": "privateWs.ts",
                  "path": "examples/Coinbase/AdvancedTrade/WebSockets/privateWs.ts",
                  "code": "import {\n  // DefaultLogger,\n  WebsocketClient,\n  // WS_KEY_MAP,\n  WsTopicRequest,\n} from 'coinbase-api';\n\nasync function start() {\n  // key name & private key, as returned by coinbase when creating your API keys.\n  // Note: the below example is a dummy key and won't actually work\n\n  // Optional: fully customise the logging experience by injecting a custom logger\n  // const logger: typeof DefaultLogger = {\n  //   ...DefaultLogger,\n  //   trace: (...params) => {\n  //     if (\n  //       [\n  //         'Sending ping',\n  //         'Sending upstream ws message: ',\n  //         'Received pong, clearing pong timer',\n  //         'Received ping, sending pong frame',\n  //       ].includes(params[0])\n  //     ) {\n  //       return;\n  //     }\n  //     console.log('trace', params);\n  //   },\n  // };\n\n  const client = new WebsocketClient(\n    {\n      // Either pass the full JSON object that can be downloaded when creating your API keys\n      // cdpApiKey: advancedTradeCdpAPIKey,\n\n      // initialise the client\n      /**\n       *\n       * You can add both ED25519 and ECDSA keys, client will recognize both types of keys\n       *\n       * ECDSA:\n       *\n       * {\n       *   apiKey: 'organizations/your_org_id/apiKeys/your_api_key_id',\n       *   apiSecret:\n       *     '-----BEGIN EC PRIVATE KEY-----\\nMHcCAQEEIPT/TTZPxw0kDGvpuCENJp9A4/2INAt9/QKKfyidTWM8oAoGCCqGSM49\\nAwEHoUQDQgAEd+cnxrKl536ly5eYBi+8dvXt1MJXYRo+/v38h9HrFKVGBRndU9DY\\npV357xIfqeJEzb/MBuk3EW8cG9RTrYBwjg==\\n-----END EC PRIVATE KEY-----\\n',\n       * }\n       *\n       * ED25519:\n       * {\n       *   apiKey: 'your-api-key-id',\n       *   apiSecret: 'yourExampleApiSecretEd25519Version==',\n       * }\n       *\n       *\n       */\n      apiKey: process.env.API_KEY_NAME || 'insert_api_key_here',\n      apiSecret: process.env.API_PRIVATE_KEY || 'insert_api_secret_here',\n    },\n    // logger,\n  );\n\n  client.on('open', (data) => {\n    console.log('open: ', data?.wsKey);\n  });\n\n  // Data received\n  client.on('update', (data) => {\n    console.info(new Date(), 'data received: ', JSON.stringify(data));\n  });\n\n  // Something happened, attempting to reconenct\n  client.on('reconnect', (data) => {\n    console.log('reconnect: ', data);\n  });\n\n  // Reconnect successful\n  client.on('reconnected', (data) => {\n    console.log('reconnected: ', data);\n  });\n\n  // Connection closed. If unexpected, expect reconnect -> reconnected.\n  client.on('close', (data) => {\n    console.error('close: ', data);\n  });\n\n  // Reply to a request, e.g. \"subscribe\"/\"unsubscribe\"/\"authenticate\"\n  client.on('response', (data) => {\n    console.info('response: ', JSON.stringify(data, null, 2));\n    // throw new Error('res?');\n  });\n\n  client.on('exception', (data) => {\n    console.error('exception: ', data);\n  });\n\n  try {\n    /**\n     * Use the client subscribe(topic, market) pattern to subscribe to any websocket topic.\n     *\n     * You can subscribe to topics one at a time or many one one request.\n     *\n     * Topics can be sent as simple strings, if no parameters are required.\n     *\n     * Any subscribe requests on the \"advTradeUserData\" market are automatically authenticated with the available credentials\n     */\n    // client.subscribe('heartbeats', 'advTradeUserData');\n    client.subscribe('futures_balance_summary', 'advTradeUserData');\n    // This is the same as above, but uses WS_KEY_MAP as an enum (do this if you're not sure what value to put)\n    // client.subscribe('futures_balance_summary', WS_KEY_MAP.advTradeUserData);\n\n    // Subscribe to the user feed for the advanced trade websocket\n    client.subscribe('user', 'advTradeUserData');\n\n    // /**\n    //  * Or, as an array of simple strings.\n    //  *\n    //  * Any requests sent to the \"advTradeUserData\" wsKey are\n    //  * automatically authenticated, if API keys are avaiable:\n    //  */\n    // client.subscribe(\n    //   ['futures_balance_summary', 'user'],\n    //   'advTradeUserData',\n    // );\n\n    /**\n     * Or send a more structured object with parameters, e.g. if parameters are required\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const tickerSubscribeRequest: WsTopicRequest = {\n      topic: 'futures_balance_summary',\n      /**\n       * Anything in the payload will be merged into the subscribe \"request\",\n       * allowing you to send misc parameters supported by the exchange (such as `product_ids: string[]`)\n       */\n      payload: {\n        // In this case, the \"futures_balance_summary\" channel doesn't support any parameters\n        // product_ids: ['ETH-USD', 'BTC-USD'],\n      },\n    };\n    client.subscribe(tickerSubscribeRequest, 'advTradeUserData');\n  } catch (e) {\n    console.error('Subscribe exception: ', e);\n  }\n}\n\nstart();\n",
                  "metadata": {}
                },
                {
                  "type": "file",
                  "name": "publicWs.ts",
                  "path": "examples/Coinbase/AdvancedTrade/WebSockets/publicWs.ts",
                  "code": "import {\n  // DefaultLogger,\n  WebsocketClient,\n  WsTopicRequest,\n} from 'coinbase-api';\n\nasync function start() {\n  // Optional: fully customise the logging experience by injecting a custom logger\n  // const logger: typeof DefaultLogger = {\n  //   ...DefaultLogger,\n  //   trace: (...params) => {\n  //     if (\n  //       [\n  //         'Sending ping',\n  //         'Sending upstream ws message: ',\n  //         'Received pong, clearing pong timer',\n  //         'Received ping, sending pong frame',\n  //       ].includes(params[0])\n  //     ) {\n  //       return;\n  //     }\n  //     console.log('trace', params);\n  //   },\n  // };\n  // const client = new WebsocketClient({}, logger);\n\n  const client = new WebsocketClient();\n\n  client.on('open', (data) => {\n    console.log('open: ', data?.wsKey);\n  });\n\n  // Data received\n  client.on('update', (data) => {\n    console.info(new Date(), 'data received: ', JSON.stringify(data));\n  });\n\n  // Something happened, attempting to reconenct\n  client.on('reconnect', (data) => {\n    console.log('reconnect: ', data);\n  });\n\n  // Reconnect successful\n  client.on('reconnected', (data) => {\n    console.log('reconnected: ', data);\n  });\n\n  // Connection closed. If unexpected, expect reconnect -> reconnected.\n  client.on('close', (data) => {\n    console.error('close: ', data);\n  });\n\n  // Reply to a request, e.g. \"subscribe\"/\"unsubscribe\"/\"authenticate\"\n  client.on('response', (data) => {\n    console.info('response: ', JSON.stringify(data, null, 2));\n    // throw new Error('res?');\n  });\n\n  client.on('exception', (data) => {\n    console.error('exception: ', data);\n  });\n\n  try {\n    /**\n     * Use the client subscribe(topic, market) pattern to subscribe to any websocket topic.\n     *\n     * You can subscribe to topics one at a time or many one one request.\n     *\n     * Topics can be sent as simple strings, if no parameters are required:\n     */\n    // client.subscribe('heartbeats', 'advTradeMarketData');\n    // client.subscribe('futures_balance_summary', 'advTradeUserData');\n\n    // /**\n    //  * Or, as an array of simple strings.\n    //  *\n    //  * Any requests sent to the \"advTradeUserData\" wsKey are\n    //  * automatically authenticated, if API keys are avaiable:\n    //  */\n    // client.subscribe(\n    //   ['heartbeats', 'futures_balance_summary'],\n    //   'advTradeUserData',\n    // );\n\n    /**\n     * Or send a more structured object with parameters, e.g. if parameters are required\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const tickerSubscribeRequest: WsTopicRequest = {\n      topic: 'ticker',\n      /**\n       * Anything in the payload will be merged into the subscribe \"request\",\n       * allowing you to send misc parameters supported by the exchange (such as `product_ids: string[]`)\n       */\n      payload: {\n        product_ids: ['ETH-USD', 'BTC-USD'],\n      },\n    };\n    client.subscribe(tickerSubscribeRequest, 'advTradeMarketData');\n\n    /**\n     * Subscribe to the \"status\" topic for a few symbols\n     */\n    client.subscribe(\n      {\n        topic: 'status',\n        payload: {\n          product_ids: ['ETH-USD', 'BTC-USD'],\n        },\n      },\n      'advTradeMarketData',\n    );\n\n    /**\n     * To subscribe to more product IDs for the same topic, just send an additional request:\n     */\n    client.subscribe(\n      {\n        topic: 'status',\n        payload: {\n          product_ids: ['XRP-USD'],\n        },\n      },\n      'advTradeMarketData',\n    );\n\n    // /**\n    //  * Or, send an array of structured objects with parameters, if you wanted to send multiple in one request\n    //  */\n    // // client.subscribe([level2SubscribeRequest, anotherRequest, etc], 'advTradeMarketData');\n\n    /**\n     * Other adv trade public websocket topics:\n     */\n    client.subscribe(\n      [\n        {\n          topic: 'heartbeats',\n        },\n        {\n          topic: 'candles',\n          payload: {\n            product_ids: ['ETH-USD'],\n          },\n        },\n        {\n          topic: 'market_trades',\n          payload: {\n            product_ids: ['ETH-USD', 'BTC-USD'],\n          },\n        },\n        {\n          topic: 'status',\n          payload: {\n            product_ids: ['ETH-USD', 'BTC-USD'],\n          },\n        },\n        {\n          topic: 'ticker',\n          payload: {\n            product_ids: ['ETH-USD', 'BTC-USD'],\n          },\n        },\n        {\n          topic: 'ticker_batch',\n          payload: {\n            product_ids: ['ETH-USD', 'BTC-USD'],\n          },\n        },\n        {\n          topic: 'level2',\n          payload: {\n            product_ids: ['ETH-USD', 'BTC-USD'],\n          },\n        },\n      ],\n      'advTradeMarketData',\n    );\n  } catch (e) {\n    console.error('Subscribe exception: ', e);\n  }\n}\n\nstart();\n",
                  "metadata": {}
                }
              ]
            }
          ]
        },
        {
          "type": "folder",
          "name": "CoinbaseApp",
          "path": "examples/Coinbase/CoinbaseApp",
          "children": [
            {
              "type": "folder",
              "name": "Private",
              "path": "examples/Coinbase/CoinbaseApp/Private",
              "children": [
                {
                  "type": "file",
                  "name": "cb-app-private.ts",
                  "path": "examples/Coinbase/CoinbaseApp/Private/cb-app-private.ts",
                  "code": "import { CBAppClient } from 'coinbase-api';\n\n// initialise the client\n/**\n *\n * You can add both ED25519 and ECDSA keys, client will recognize both types of keys\n *\n * ECDSA:\n *\n * {\n *   apiKey: 'organizations/your_org_id/apiKeys/your_api_key_id',\n *   apiSecret:\n *     '-----BEGIN EC PRIVATE KEY-----\\nMHcCAQEEIPT/TTZPxw0kDGvpuCENJp9A4/2INAt9/QKKfyidTWM8oAoGCCqGSM49\\nAwEHoUQDQgAEd+cnxrKl536ly5eYBi+8dvXt1MJXYRo+/v38h9HrFKVGBRndU9DY\\npV357xIfqeJEzb/MBuk3EW8cG9RTrYBwjg==\\n-----END EC PRIVATE KEY-----\\n',\n * }\n *\n * ED25519:\n * {\n *   apiKey: 'your-api-key-id',\n *   apiSecret: 'yourExampleApiSecretEd25519Version==',\n * }\n *\n *\n */\nconst client = new CBAppClient({\n  apiKey: process.env.API_KEY_NAME || 'insert_api_key_here',\n  apiSecret: process.env.API_PRIVATE_KEY || 'insert_api_secret_here',\n});\n\nasync function main() {\n  try {\n    // Deposit funds to your fiat account\n    const depositResult = await client.depositFunds({\n      account_id: 'your_fiat_account_id',\n      amount: '100.00',\n      currency: 'USD',\n      payment_method: 'your_payment_method_id',\n    });\n    console.log('Deposit Result: ', depositResult);\n\n    // Withdraw funds from fiat account\n    const withdrawResult = await client.withdrawFunds({\n      account_id: 'your_fiat_account_id',\n      amount: '50.00',\n      currency: 'USD',\n      payment_method: 'your_payment_method_id',\n    });\n    console.log('Withdraw Result: ', withdrawResult);\n\n    // Send money to another user\n    const sendMoneyResult = await client.sendMoney({\n      account_id: 'your_crypto_account_id',\n      type: 'send',\n      to: 'recipient_address_or_email',\n      amount: '0.01',\n      currency: 'BTC',\n    });\n    console.log('Send Money Result: ', sendMoneyResult);\n\n    // Transfer money between your own accounts\n    const transferMoneyResult = await client.transferMoney({\n      account_id: 'your_source_account_id',\n      type: 'transfer',\n      to: 'your_destination_account_id',\n      amount: '0.01',\n      currency: 'BTC',\n    });\n    console.log('Transfer Money Result: ', transferMoneyResult);\n  } catch (e) {\n    console.error('Error: ', e);\n  }\n}\n\nmain();\n",
                  "metadata": {}
                },
                {
                  "type": "file",
                  "name": "depositFunds.ts",
                  "path": "examples/Coinbase/CoinbaseApp/Private/depositFunds.ts",
                  "code": "import { CBAppClient } from 'coinbase-api';\n\n// initialise the client\n/**\n *\n * You can add both ED25519 and ECDSA keys, client will recognize both types of keys\n *\n * ECDSA:\n *\n * {\n *   apiKey: 'organizations/your_org_id/apiKeys/your_api_key_id',\n *   apiSecret:\n *     '-----BEGIN EC PRIVATE KEY-----\\nMHcCAQEEIPT/TTZPxw0kDGvpuCENJp9A4/2INAt9/QKKfyidTWM8oAoGCCqGSM49\\nAwEHoUQDQgAEd+cnxrKl536ly5eYBi+8dvXt1MJXYRo+/v38h9HrFKVGBRndU9DY\\npV357xIfqeJEzb/MBuk3EW8cG9RTrYBwjg==\\n-----END EC PRIVATE KEY-----\\n',\n * }\n *\n * ED25519:\n * {\n *   apiKey: 'your-api-key-id',\n *   apiSecret: 'yourExampleApiSecretEd25519Version==',\n * }\n *\n *\n */\nconst client = new CBAppClient({\n  apiKey: process.env.API_KEY_NAME || 'insert_api_key_here',\n  apiSecret: process.env.API_PRIVATE_KEY || 'insert_api_secret_here',\n});\n\nasync function depositFunds() {\n  try {\n    // Deposit funds to your fiat account\n    const depositResult = await client.depositFunds({\n      account_id: 'your_fiat_account_id',\n      amount: '100.00',\n      currency: 'USD',\n      payment_method: 'your_payment_method_id',\n    });\n    console.log('Deposit Result: ', depositResult);\n  } catch (e) {\n    console.error('Deposit funds error: ', e);\n  }\n}\n\ndepositFunds();\n",
                  "metadata": {}
                },
                {
                  "type": "file",
                  "name": "sendMoney.ts",
                  "path": "examples/Coinbase/CoinbaseApp/Private/sendMoney.ts",
                  "code": "import { CBAppClient } from 'coinbase-api';\n\n// initialise the client\n/**\n *\n * You can add both ED25519 and ECDSA keys, client will recognize both types of keys\n *\n * ECDSA:\n *\n * {\n *   apiKey: 'organizations/your_org_id/apiKeys/your_api_key_id',\n *   apiSecret:\n *     '-----BEGIN EC PRIVATE KEY-----\\nMHcCAQEEIPT/TTZPxw0kDGvpuCENJp9A4/2INAt9/QKKfyidTWM8oAoGCCqGSM49\\nAwEHoUQDQgAEd+cnxrKl536ly5eYBi+8dvXt1MJXYRo+/v38h9HrFKVGBRndU9DY\\npV357xIfqeJEzb/MBuk3EW8cG9RTrYBwjg==\\n-----END EC PRIVATE KEY-----\\n',\n * }\n *\n * ED25519:\n * {\n *   apiKey: 'your-api-key-id',\n *   apiSecret: 'yourExampleApiSecretEd25519Version==',\n * }\n *\n *\n */\nconst client = new CBAppClient({\n  apiKey: process.env.API_KEY_NAME || 'insert_api_key_here',\n  apiSecret: process.env.API_PRIVATE_KEY || 'insert_api_secret_here',\n});\n\nasync function sendMoney() {\n  try {\n    // Send money to another user\n    const sendMoneyResult = await client.sendMoney({\n      account_id: 'your_crypto_account_id',\n      type: 'send',\n      to: 'recipient_address_or_email',\n      amount: '0.01',\n      currency: 'BTC',\n    });\n    console.log('Send Money Result: ', sendMoneyResult);\n  } catch (e) {\n    console.error('Send money error: ', e);\n  }\n}\n\nsendMoney();\n",
                  "metadata": {}
                },
                {
                  "type": "file",
                  "name": "transferMoney.ts",
                  "path": "examples/Coinbase/CoinbaseApp/Private/transferMoney.ts",
                  "code": "import { CBAppClient } from 'coinbase-api';\n\n// initialise the client\n/**\n *\n * You can add both ED25519 and ECDSA keys, client will recognize both types of keys\n *\n * ECDSA:\n *\n * {\n *   apiKey: 'organizations/your_org_id/apiKeys/your_api_key_id',\n *   apiSecret:\n *     '-----BEGIN EC PRIVATE KEY-----\\nMHcCAQEEIPT/TTZPxw0kDGvpuCENJp9A4/2INAt9/QKKfyidTWM8oAoGCCqGSM49\\nAwEHoUQDQgAEd+cnxrKl536ly5eYBi+8dvXt1MJXYRo+/v38h9HrFKVGBRndU9DY\\npV357xIfqeJEzb/MBuk3EW8cG9RTrYBwjg==\\n-----END EC PRIVATE KEY-----\\n',\n * }\n *\n * ED25519:\n * {\n *   apiKey: 'your-api-key-id',\n *   apiSecret: 'yourExampleApiSecretEd25519Version==',\n * }\n *\n *\n */\nconst client = new CBAppClient({\n  apiKey: process.env.API_KEY_NAME || 'insert_api_key_here',\n  apiSecret: process.env.API_PRIVATE_KEY || 'insert_api_secret_here',\n});\n\nasync function transferMoney() {\n  try {\n    // Transfer money between your own accounts\n    const transferMoneyResult = await client.transferMoney({\n      account_id: 'your_source_account_id',\n      type: 'transfer',\n      to: 'your_destination_account_id',\n      amount: '0.01',\n      currency: 'BTC',\n    });\n    console.log('Transfer Money Result: ', transferMoneyResult);\n  } catch (e) {\n    console.error('Transfer money error: ', e);\n  }\n}\n\ntransferMoney();\n",
                  "metadata": {}
                },
                {
                  "type": "file",
                  "name": "withdrawFunds.ts",
                  "path": "examples/Coinbase/CoinbaseApp/Private/withdrawFunds.ts",
                  "code": "import { CBAppClient } from 'coinbase-api';\n\n// initialise the client\n/**\n *\n * You can add both ED25519 and ECDSA keys, client will recognize both types of keys\n *\n * ECDSA:\n *\n * {\n *   apiKey: 'organizations/your_org_id/apiKeys/your_api_key_id',\n *   apiSecret:\n *     '-----BEGIN EC PRIVATE KEY-----\\nMHcCAQEEIPT/TTZPxw0kDGvpuCENJp9A4/2INAt9/QKKfyidTWM8oAoGCCqGSM49\\nAwEHoUQDQgAEd+cnxrKl536ly5eYBi+8dvXt1MJXYRo+/v38h9HrFKVGBRndU9DY\\npV357xIfqeJEzb/MBuk3EW8cG9RTrYBwjg==\\n-----END EC PRIVATE KEY-----\\n',\n * }\n *\n * ED25519:\n * {\n *   apiKey: 'your-api-key-id',\n *   apiSecret: 'yourExampleApiSecretEd25519Version==',\n * }\n *\n *\n */\nconst client = new CBAppClient({\n  apiKey: process.env.API_KEY_NAME || 'insert_api_key_here',\n  apiSecret: process.env.API_PRIVATE_KEY || 'insert_api_secret_here',\n});\n\nasync function withdrawFunds() {\n  try {\n    // Withdraw funds from your fiat account\n    const withdrawResult = await client.withdrawFunds({\n      account_id: 'your_fiat_account_id',\n      amount: '50.00',\n      currency: 'USD',\n      payment_method: 'your_payment_method_id',\n    });\n    console.log('Withdraw Result: ', withdrawResult);\n  } catch (e) {\n    console.error('Withdraw funds error: ', e);\n  }\n}\n\nwithdrawFunds();\n",
                  "metadata": {}
                }
              ]
            },
            {
              "type": "folder",
              "name": "Public",
              "path": "examples/Coinbase/CoinbaseApp/Public",
              "children": [
                {
                  "type": "file",
                  "name": "cbapp-public-rest-all.ts",
                  "path": "examples/Coinbase/CoinbaseApp/Public/cbapp-public-rest-all.ts",
                  "code": "import { CBAppClient } from 'coinbase-api';\n\n// Initialize the client, you can pass in api keys here if you have them but they are not required for public endpoints\nconst client = new CBAppClient();\n\nasync function publicCalls() {\n  try {\n    // Get fiat currencies\n    const fiatCurrencies = await client.getFiatCurrencies();\n    console.log('Fiat Currencies: ', fiatCurrencies);\n\n    // Get cryptocurrencies\n    const cryptocurrencies = await client.getCryptocurrencies();\n    console.log('Cryptocurrencies: ', cryptocurrencies);\n\n    // Get exchange rates\n    const exchangeRates = await client.getExchangeRates({ currency: 'USD' });\n    console.log('Exchange Rates: ', exchangeRates);\n\n    // Get buy price\n    const buyPrice = await client.getBuyPrice({ currencyPair: 'BTC-USD' });\n    console.log('Buy Price: ', buyPrice);\n\n    // Get sell price\n    const sellPrice = await client.getSellPrice({ currencyPair: 'BTC-USD' });\n    console.log('Sell Price: ', sellPrice);\n\n    // Get spot price\n    const spotPrice = await client.getSpotPrice({ currencyPair: 'BTC-USD' });\n    console.log('Spot Price: ', spotPrice);\n\n    // Get current time\n    const currentTime = await client.getCurrentTime();\n    console.log('Current Time: ', currentTime);\n  } catch (e) {\n    console.error('Error: ', e);\n  }\n}\n\npublicCalls();\n",
                  "metadata": {}
                }
              ]
            }
          ]
        },
        {
          "type": "folder",
          "name": "Institutional",
          "path": "examples/Coinbase/Institutional",
          "children": [
            {
              "type": "folder",
              "name": "CBExchange",
              "path": "examples/Coinbase/Institutional/CBExchange",
              "children": [
                {
                  "type": "folder",
                  "name": "Rest",
                  "path": "examples/Coinbase/Institutional/CBExchange/Rest",
                  "children": [
                    {
                      "type": "file",
                      "name": "cb-exchange-private.ts",
                      "path": "examples/Coinbase/Institutional/CBExchange/Rest/cb-exchange-private.ts",
                      "code": "import { CBExchangeClient } from 'coinbase-api';\n\n// Initialize the client, you can pass in api keys here if you have them but they are not required for public endpoints\nconst client = new CBExchangeClient({\n  apiKey: 'yourAPIKeyHere',\n  apiSecret: 'yourAPISecretHere',\n  //This is the passphrase you provided when creating this API key. NOT your account password.\n  apiPassphrase: 'yourAPIPassPhraseHere',\n\n  // Optional, connect to sandbox instead: https://public-sandbox.exchange.coinbase.com/apikeys\n  // useSandbox: true,\n});\n\nasync function privateExchangeCalls() {\n  try {\n    const orders = await client.getOrders();\n    console.log('Orders: ', orders);\n\n    const order = await client.getOrder({\n      order_id: '0c892cb3-2824-4662-8be3-99c8e879f606',\n      market_type: 'market',\n    });\n    console.log('Order: ', order);\n\n    const cancelOrderResult = await client.cancelOrder({\n      order_id: '0c892cb3-2824-4662-8be3-99c8e879f606',\n      product_id: 'BTC-GBP',\n    });\n    console.log('cancelOrder result: ', cancelOrderResult);\n  } catch (e) {\n    console.error('Error: ', e);\n  }\n}\n\nprivateExchangeCalls();\n",
                      "metadata": {}
                    },
                    {
                      "type": "file",
                      "name": "cb-exchange-public.ts",
                      "path": "examples/Coinbase/Institutional/CBExchange/Rest/cb-exchange-public.ts",
                      "code": "import { CBExchangeClient } from 'coinbase-api';\n\n// Initialize the client, you can pass in api keys here if you have them but they are not required for public endpoints\nconst client = new CBExchangeClient();\n\nasync function publicExchangeCalls() {\n  try {\n    // Get all known currencies\n    const currencies = await client.getCurrencies();\n    console.log('Currencies: ', currencies);\n\n    // Get a single currency by id\n    const currency = await client.getCurrency('BTC');\n    console.log('Currency (BTC): ', currency);\n\n    // Get all known trading pairs\n    const tradingPairs = await client.getAllTradingPairs();\n    console.log('Trading Pairs: ', tradingPairs);\n\n    // Get all product volume\n    const productVolume = await client.getAllProductVolume();\n    console.log('Product Volume: ', productVolume);\n\n    // Get all wrapped assets\n    const wrappedAssets = await client.getAllWrappedAssets();\n    console.log('Wrapped Assets: ', wrappedAssets);\n  } catch (e) {\n    console.error('Error: ', e);\n  }\n}\n\npublicExchangeCalls();\n",
                      "metadata": {}
                    }
                  ]
                },
                {
                  "type": "folder",
                  "name": "WebSockets",
                  "path": "examples/Coinbase/Institutional/CBExchange/WebSockets",
                  "children": [
                    {
                      "type": "file",
                      "name": "privateWs.ts",
                      "path": "examples/Coinbase/Institutional/CBExchange/WebSockets/privateWs.ts",
                      "code": "import { WebsocketClient } from 'coinbase-api';\n\nasync function start() {\n  const client = new WebsocketClient(\n    {\n      apiKey: 'yourAPIKeyHere',\n      apiSecret: 'yourAPISecretHere',\n      //This is the passphrase you provided when creating this API key. NOT your account password.\n      apiPassphrase: 'yourAPIPassPhraseHere',\n      // Optional, connect to sandbox instead: https://public-sandbox.exchange.coinbase.com/apikeys\n      // useSandbox: true,\n    },\n    // logger,\n  );\n\n  client.on('open', (data) => {\n    console.log('open: ', data?.wsKey);\n  });\n\n  // Data received\n  client.on('update', (data) => {\n    console.info(new Date(), 'data received: ', JSON.stringify(data));\n  });\n\n  // Something happened, attempting to reconenct\n  client.on('reconnect', (data) => {\n    console.log('reconnect: ', data);\n  });\n\n  // Reconnect successful\n  client.on('reconnected', (data) => {\n    console.log('reconnected: ', data);\n  });\n\n  // Connection closed. If unexpected, expect reconnect -> reconnected.\n  client.on('close', (data) => {\n    console.error('close: ', data);\n  });\n\n  // Reply to a request, e.g. \"subscribe\"/\"unsubscribe\"/\"authenticate\"\n  client.on('response', (data) => {\n    console.info('response: ', JSON.stringify(data, null, 2));\n  });\n\n  client.on('exception', (data) => {\n    console.error('exception: ', data);\n  });\n\n  try {\n    /**\n     * Use the client subscribe(topic, market) pattern to subscribe to any websocket topic.\n     * - You can subscribe to topics one at a time or many one one request.\n     * - Topics can be sent as simple strings, if no parameters are required.\n     * - If parameters are required, pass them in the \"payload\" property - they will be merged into the subscription request automatically\n     * - Any subscribe requests on the \"exchangeDirectMarketData\" market are automatically authenticated with the available credentials\n     */\n    client.subscribe(\n      {\n        topic: 'full',\n        payload: {\n          product_ids: ['BTC-USD'],\n        },\n      },\n      'exchangeDirectMarketData',\n    );\n\n    client.subscribe(\n      {\n        topic: 'balance',\n        payload: {\n          account_ids: [\n            'd50ec984-77a8-460a-b958-66f114b0de9b',\n            'd50ec984-77a8-460a-b958-66f114b0de9a',\n          ],\n        },\n      },\n      'exchangeDirectMarketData',\n    );\n\n    /**\n     * Other examples for some of the authenticated Coinbase Exchange \"direct market data\" channels:\n     */\n    client.subscribe(\n      [\n        // https://docs.cdp.coinbase.com/exchange/docs/websocket-channels#full-channel\n        {\n          topic: 'full',\n          payload: {\n            product_ids: ['BTC-USD'],\n          },\n        },\n        // https://docs.cdp.coinbase.com/exchange/docs/websocket-channels#user-channel\n        {\n          topic: 'user',\n          payload: {\n            product_ids: ['BTC-USD'],\n          },\n        },\n        // https://docs.cdp.coinbase.com/exchange/docs/websocket-channels#level2-channel\n        {\n          topic: 'level2',\n          payload: {\n            product_ids: ['BTC-USD'],\n          },\n        },\n        // https://docs.cdp.coinbase.com/exchange/docs/websocket-channels#balance-channel\n        {\n          topic: 'balance',\n          payload: {\n            account_ids: [\n              'd50ec984-77a8-460a-b958-66f114b0de9b',\n              'd50ec984-77a8-460a-b958-66f114b0de9a',\n            ],\n          },\n        },\n      ],\n      'exchangeDirectMarketData',\n    );\n  } catch (e) {\n    console.error('Subscribe exception: ', e);\n  }\n}\n\nstart();\n",
                      "metadata": {}
                    },
                    {
                      "type": "file",
                      "name": "publicWs.ts",
                      "path": "examples/Coinbase/Institutional/CBExchange/WebSockets/publicWs.ts",
                      "code": "import { WebsocketClient } from 'coinbase-api';\n\nasync function start() {\n  /**\n   * All websockets are available via the unified WebsocketClient.\n   *\n   * Below are examples specific to websockets in this product group.\n   */\n  const client = new WebsocketClient();\n\n  client.on('open', (data) => {\n    console.log('open: ', data?.wsKey);\n  });\n\n  // Data received\n  client.on('update', (data) => {\n    console.info(new Date(), 'data received: ', JSON.stringify(data));\n  });\n\n  // Something happened, attempting to reconenct\n  client.on('reconnect', (data) => {\n    console.log('reconnect: ', data);\n  });\n\n  // Reconnect successful\n  client.on('reconnected', (data) => {\n    console.log('reconnected: ', data);\n  });\n\n  // Connection closed. If unexpected, expect reconnect -> reconnected.\n  client.on('close', (data) => {\n    console.error('close: ', data);\n  });\n\n  // Reply to a request, e.g. \"subscribe\"/\"unsubscribe\"/\"authenticate\"\n  client.on('response', (data) => {\n    console.info('response: ', JSON.stringify(data, null, 2));\n    // throw new Error('res?');\n  });\n\n  client.on('exception', (data) => {\n    console.error('exception: ', data);\n  });\n\n  try {\n    /**\n     * Use the client subscribe(topic, market) pattern to subscribe to any websocket topic.\n     *\n     * - You can subscribe to topics one at a time or many one one request.\n     * - Topics can be sent as simple strings, if no parameters are required.\n     * - Coinbase Market Data is the traditional feed which is available without authentication.\n     * - To use this feed, use 'exchangeMarketData' as the wsKey for each subscription command:\n     */\n    // client.subscribe('status', 'exchangeMarketData');\n\n    /**\n     * Or send a more structured object with parameters, e.g. if parameters are required\n     */\n    // const tickerSubscribeRequest: WsTopicRequest = {\n    //   topic: 'ticker',\n    //   /**\n    //    * Anything in the payload will be merged into the subscribe \"request\",\n    //    * allowing you to send misc parameters supported by the exchange (such as `product_ids: string[]`)\n    //    */\n    //   payload: {\n    //     product_ids: ['ETH-USD', 'ETH-EUR'],\n    //   },\n    // };\n    // client.subscribe(tickerSubscribeRequest, 'exchangeMarketData');\n\n    /**\n     * Subscribe to the \"heartbeat\" topic for a few symbols\n     */\n    // client.subscribe(\n    //   {\n    //     topic: 'heartbeat',\n    //     payload: {\n    //       product_ids: ['ETH-USD', 'BTC-USD'],\n    //     },\n    //   },\n    //   'exchangeMarketData',\n    // );\n\n    // client.subscribe(\n    //   {\n    //     topic: 'level2',\n    //     payload: {\n    //       product_ids: ['ETH-USD', 'BTC-USD'],\n    //     },\n    //   },\n    //   'exchangeMarketData',\n    // );\n\n    // /**\n    //  * Or, send an array of structured objects with parameters, if you wanted to send multiple in one request\n    //  */\n    // // client.subscribe([level2SubscribeRequest, anotherRequest, etc], 'advTradeMarketData');\n\n    /**\n     * Other Coinbase Exchange public websocket topics:\n     */\n    client.subscribe(\n      [\n        // https://docs.cdp.coinbase.com/exchange/docs/websocket-channels#heartbeat-channel\n        {\n          topic: 'heartbeat',\n          payload: {\n            product_ids: ['ETH-EUR'],\n          },\n        },\n        // https://docs.cdp.coinbase.com/exchange/docs/websocket-channels#status-channel\n        'status',\n        // https://docs.cdp.coinbase.com/exchange/docs/websocket-channels#auction-channel\n        {\n          topic: 'auctionfeed',\n          payload: {\n            product_ids: ['LTC-USD'],\n          },\n        },\n        // https://docs.cdp.coinbase.com/exchange/docs/websocket-channels#matches-channel\n        {\n          topic: 'matches',\n          payload: {\n            product_ids: ['BTC-USD'],\n          },\n        },\n        // https://docs.cdp.coinbase.com/exchange/docs/websocket-channels#rfq-matches-channel\n        {\n          topic: 'rfq_matches',\n          payload: {\n            // Optional:\n            // product_ids: ['ETH-USD', 'BTC-USD'],\n          },\n        },\n        // https://docs.cdp.coinbase.com/exchange/docs/websocket-channels#ticker-channel\n        {\n          topic: 'ticker',\n          payload: {\n            product_ids: ['ETH-USD', 'BTC-USD'],\n          },\n        },\n        // https://docs.cdp.coinbase.com/exchange/docs/websocket-channels#ticker-batch-channel\n        {\n          topic: 'ticker_batch',\n          payload: {\n            product_ids: ['ETH-USD', 'BTC-USD'],\n          },\n        },\n        // https://docs.cdp.coinbase.com/exchange/docs/websocket-channels#level2-batch-channel\n        {\n          topic: 'level2_batch',\n          payload: {\n            product_ids: ['ETH-USD', 'BTC-USD'],\n          },\n        },\n      ],\n      'exchangeMarketData',\n    );\n  } catch (e) {\n    console.error('Subscribe exception: ', e);\n  }\n}\n\nstart();\n",
                      "metadata": {}
                    }
                  ]
                }
              ]
            },
            {
              "type": "folder",
              "name": "CBInternationalExchange",
              "path": "examples/Coinbase/Institutional/CBInternationalExchange",
              "children": [
                {
                  "type": "file",
                  "name": "cb-intx-public.ts",
                  "path": "examples/Coinbase/Institutional/CBInternationalExchange/cb-intx-public.ts",
                  "code": "import { CBInternationalClient } from 'coinbase-api';\n\n/**\n * import { CBInternationalClient } from 'coinbase-api';\n * const { CBInternationalClient } = require('coinbase-api');\n */\n\n// Initialize the client, you can pass in api keys here if you have them but they are not required for public endpoints\nconst client = new CBInternationalClient();\n\nasync function publicInternationalCalls() {\n  try {\n    // List assets\n    const assets = await client.getAssets();\n    console.log('Assets: ', assets);\n\n    // Get asset details\n    const assetDetails = await client.getAssetDetails({ asset: 'BTC' });\n    console.log('Asset Details (BTC): ', assetDetails);\n\n    // Get supported networks per asset\n    const supportedNetworks = await client.getSupportedNetworksPerAsset({\n      asset: 'BTC',\n    });\n    console.log('Supported Networks (BTC): ', supportedNetworks);\n\n    // List instruments\n    const instruments = await client.getInstruments();\n    console.log('Instruments: ', instruments);\n\n    // Get instrument details\n    const instrumentDetails = await client.getInstrumentDetails({\n      instrument: 'BTC-PERP',\n    });\n    console.log('Instrument Details (BTC-PERP): ', instrumentDetails);\n\n    // Get quote per instrument\n    const quote = await client.getQuotePerInstrument({\n      instrument: 'BTC-PERP',\n    });\n    console.log('Quote (BTC-PERP): ', quote);\n\n    // Get daily trading volumes\n    const dailyVolumes = await client.getDailyTradingVolumes({\n      instruments: 'BTC-PERP',\n    });\n    console.log('Daily Trading Volumes (BTC-PERP): ', dailyVolumes);\n\n    // Get aggregated candles data per instrument\n    const candlesData = await client.getAggregatedCandlesData({\n      instrument: 'BTC-PERP',\n      granularity: 'ONE_HOUR',\n      start: '2023-01-01T00:00:00Z',\n      end: '2023-01-02T00:00:00Z',\n    });\n    console.log('Aggregated Candles Data (BTC-PERP): ', candlesData);\n\n    // Get historical funding rates\n    const fundingRates = await client.getHistoricalFundingRates({\n      instrument: 'BTC-PERP',\n    });\n    console.log('Historical Funding Rates (BTC-PERP): ', fundingRates);\n\n    // List position offsets\n    const positionOffsets = await client.getPositionOffsets();\n    console.log('Position Offsets: ', positionOffsets);\n  } catch (e) {\n    console.error('Error: ', e);\n  }\n}\n\npublicInternationalCalls();\n",
                  "metadata": {}
                },
                {
                  "type": "file",
                  "name": "cb-intx-ws.ts",
                  "path": "examples/Coinbase/Institutional/CBInternationalExchange/cb-intx-ws.ts",
                  "code": "import 'dotenv/config';\n\nimport { WebsocketClient, WsTopicRequest } from 'coinbase-api';\n\n/**\n * import { WebsocketClient, WsTopicRequest } from 'coinbase-api';\n * const { WebsocketClient, WsTopicRequest } = require('coinbase-api');\n */\n\nconst client = new WebsocketClient(\n  {\n    apiKey: process.env.CB_INTX_API_KEY!,\n    apiSecret: process.env.CB_INTX_API_SECRET!,\n    apiPassphrase: process.env.CB_INTX_API_PASSPHRASE!,\n  },\n  // logger,\n);\n\nclient.on('open', (data) => {\n  console.log('open: ', data?.wsKey);\n});\n\n// Data received\nclient.on('update', (data) => {\n  console.info(new Date(), 'data received: ', JSON.stringify(data));\n});\n\n// Something happened, attempting to reconenct\nclient.on('reconnect', (data) => {\n  console.log('reconnect: ', data);\n});\n\n// Reconnect successful\nclient.on('reconnected', (data) => {\n  console.log('reconnected: ', data);\n});\n\n// Connection closed. If unexpected, expect reconnect -> reconnected.\nclient.on('close', (data) => {\n  console.error('close: ', data);\n});\n\n// Reply to a request, e.g. \"subscribe\"/\"unsubscribe\"/\"authenticate\"\nclient.on('response', (data) => {\n  console.info('response: ', JSON.stringify(data, null, 2));\n});\n\nclient.on('exception', (data) => {\n  console.error('exception: ', data);\n});\n\nconst OrderbookSubscribeRequest: WsTopicRequest = {\n  topic: 'LEVEL1', // ws topic\n  /**\n   * Anything in the payload will be merged into the subscribe \"request\",\n   * allowing you to send misc parameters supported by the exchange (such as `product_ids: string[]`)\n   */\n  payload: {\n    product_ids: ['BTC-PERP'],\n  },\n};\nclient.subscribe(OrderbookSubscribeRequest, 'internationalMarketData');\n",
                  "metadata": {}
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "type": "folder",
      "name": "Gate",
      "path": "examples/Gate",
      "children": [
        {
          "type": "folder",
          "name": "Rest",
          "path": "examples/Gate/Rest",
          "children": [
            {
              "type": "folder",
              "name": "futures",
              "path": "examples/Gate/Rest/futures",
              "children": [
                {
                  "type": "file",
                  "name": "futures-balance-trade.ts",
                  "path": "examples/Gate/Rest/futures/futures-balance-trade.ts",
                  "code": "/**\n * This example demonstrates a simple commented workflow of:\n * - initialising the RestClient and WebsocketClient for Gate.io exchange\n * - connecting to an accounts private websockets (to receive updates asynchronously)\n * - checking if connection is successful\n * - fetching available futures balance\n * - placing an order using 50% of the available balance\n **/\nimport { RestClient, WebsocketClient } from 'gateio-api';\n\n// Define the account object with API key and secret\nconst account = {\n  // Replace 'yourApiHere' with your actual API key or use environment variables\n  key: process.env.API_KEY || 'yourApiHere',\n  // Replace 'yourSecretHere' with your actual API secret or use environment variables\n  secret: process.env.API_SECRET || 'yourSecretHere',\n};\n\n// Initialize the RestClient with the API credentials\nconst gateRestClient = new RestClient({\n  apiKey: account.key,\n  apiSecret: account.secret,\n});\n\n// initialise websocket client - if you want only public data, you can initialise the client without the apiKey and apiSecret, just WebsocketClient()\nconst gateWSClient = new WebsocketClient({\n  apiKey: account.key,\n  apiSecret: account.secret,\n});\n\n// Data received\ngateWSClient.on('update', (data) => {\n  console.info('data received: ', JSON.stringify(data));\n});\n\nasync function subscribePrivateWs() {\n  try {\n    // Enter your user ID here\n    const myUserID = '20011';\n\n    //sub to balances updates\n    const userBalances = {\n      topic: 'futures.balances',\n      payload: [myUserID],\n    };\n\n    //sub to trades updates\n    const userTrades = {\n      topic: 'futures.usertrades',\n      payload: [myUserID, '!all'],\n    };\n\n    /**\n     * Either send one topic (with params) at a time\n     */\n    // client.subscribe({\n    //   topic: 'futures.usertrades',\n    //   payload: [myUserID, '!all'],\n    // }, 'perpFuturesUSDTV4');\n\n    /**\n     * Or send multiple topics in a batch (grouped by ws connection (WsKey))\n     * You can also use strings for topics that don't have any parameters, even if you mix multiple requests into one function call:\n     */\n    gateWSClient.subscribe([userBalances, userTrades], 'perpFuturesUSDTV4');\n\n    return true;\n  } catch (e) {\n    console.error('Req error: ', e);\n    throw e;\n  }\n}\n\nasync function main() {\n  try {\n    await subscribePrivateWs();\n    console.log('Subscribed to privateWs topics!');\n\n    // Get futures account balance via REST\n    const balances = await gateRestClient.getFuturesAccount({ settle: 'usdt' });\n\n    // total usdt balance\n    // const usdtBalance = Number(balances.total);\n\n    // available usdt balance\n    const availableBalance = Number(balances.available);\n\n    // submit market order with 50% of the balance\n    const orderAmount = availableBalance * 0.5;\n\n    // Submit a market order with 50% of the balance\n    const marketOrder = await gateRestClient.submitFuturesOrder({\n      settle: 'usdt', // Specify the settlement currency\n      contract: 'BTC_USDT', // Specify the contract\n      size: orderAmount, // Order size: positive for long, negative for short, in USDT\n      price: '0', // Market order, so price is set to '0'\n      tif: 'ioc', // Time in force: 'ioc' (Immediate Or Cancel)\n    });\n\n    console.log('Order submitted:', marketOrder);\n  } catch (e) {\n    console.error(e);\n    throw e;\n  }\n}\n\nmain();\n\n// for more detailed ws connection, you can use a lot more listeners like below:\n\ngateWSClient.on('open', (data) => {\n  console.log('connected ', data?.wsKey);\n});\n\n// Something happened, attempting to reconnect\ngateWSClient.on('reconnect', (data) => {\n  console.log('reconnect: ', data);\n});\n\n// Reconnect successful\ngateWSClient.on('reconnected', (data) => {\n  console.log('reconnected: ', data);\n});\n\n// Connection closed. If unexpected, expect reconnect -> reconnected.\ngateWSClient.on('close', (data) => {\n  console.error('close: ', data);\n});\n\n// Reply to a request, e.g. \"subscribe\"/\"unsubscribe\"/\"authenticate\"\ngateWSClient.on('response', (data) => {\n  console.info('server reply: ', JSON.stringify(data), '\\n');\n});\n\ngateWSClient.on('exception', (data) => {\n  console.error('exception: ', data);\n});\n\ngateWSClient.on('authenticated', (data) => {\n  console.error('authenticated: ', data);\n});\n",
                  "metadata": {}
                },
                {
                  "type": "file",
                  "name": "getBalances.ts",
                  "path": "examples/Gate/Rest/futures/getBalances.ts",
                  "code": "import { RestClient } from 'gateio-api';\n\n// Define the account object with API key and secret\nconst account = {\n  key: process.env.API_KEY || 'yourApiHere', // Replace 'yourApiHere' with your actual API key\n  secret: process.env.API_SECRET || 'yourSecretHere', // Replace 'yourSecretHere' with your actual API secret\n};\n\n// Initialize the RestClient with the API credentials\nconst gateRestClient = new RestClient({\n  apiKey: account.key,\n  apiSecret: account.secret,\n});\n\nasync function getFuturesBalances() {\n  try {\n    console.log('Using API keys:', account);\n\n    // Fetch the futures account balance for USDT settlement\n    const result = await gateRestClient.getFuturesAccount({ settle: 'usdt' });\n\n    console.log('Response: ', result); // Log the response to the console\n  } catch (e) {\n    console.error('Error in execution: ', e); // Log any errors that occur\n  }\n}\n\n// Execute the function to get futures balances\ngetFuturesBalances();\n",
                  "metadata": {}
                },
                {
                  "type": "file",
                  "name": "getOrders.ts",
                  "path": "examples/Gate/Rest/futures/getOrders.ts",
                  "code": "import { RestClient } from 'gateio-api';\n\n// Define the account object with API key and secret\nconst account = {\n  key: process.env.API_KEY || 'yourApiHere', // Replace 'yourApiHere' with your actual API key or use environment variables\n  secret: process.env.API_SECRET || 'yourSecretHere', // Replace 'yourSecretHere' with your actual API secret or use environment variables\n};\n\n// Initialize the RestClient with the API credentials\nconst gateRestClient = new RestClient({\n  apiKey: account.key,\n  apiSecret: account.secret,\n});\n\nasync function getFuturesOrders() {\n  try {\n    console.log('Using API keys:', account);\n\n    // Fetch open futures orders with USDT settlement\n    const openOrders = await gateRestClient.getFuturesOrders({\n      settle: 'usdt', // Specify the settlement currency\n      status: 'open', // Specify the status of the orders to fetch\n    });\n    console.log('openOrders: ', openOrders); // Log the response to the console\n\n    // Fetch finished futures orders with USDT settlement\n    const finishedOrders = await gateRestClient.getFuturesOrders({\n      settle: 'usdt', // Specify the settlement currency\n      status: 'finished', // Specify the status of the orders to fetch\n    });\n    console.log('finishedOrders: ', finishedOrders); // Log the response to the console\n  } catch (e) {\n    console.error('Error in execution: ', e); // Log any errors that occur\n  }\n}\n\n// Execute the function to get futures orders\ngetFuturesOrders();\n",
                  "metadata": {}
                },
                {
                  "type": "file",
                  "name": "getTickers.ts",
                  "path": "examples/Gate/Rest/futures/getTickers.ts",
                  "code": "import { RestClient } from 'gateio-api';\n\n// Define the account object with API key and secret\nconst account = {\n  key: process.env.API_KEY || 'yourApiHere', // Replace 'yourApiHere' with your actual API key\n  secret: process.env.API_SECRET || 'yourSecretHere', // Replace 'yourSecretHere' with your actual API secret\n};\n\n// Initialize the RestClient with the API credentials\nconst gateRestClient = new RestClient({\n  apiKey: account.key,\n  apiSecret: account.secret,\n});\n\nasync function getFuturesTicker() {\n  try {\n    console.log('Using API keys:', account);\n\n    // Fetch all futures tickers with USDT settlement\n    const allTickers = await gateRestClient.getFuturesTickers({\n      settle: 'usdt', // Specify the settlement currency\n    });\n    console.log('allTickers: ', allTickers); // Log the response to the console\n\n    // Fetch a specific futures ticker with USDT settlement\n    const ticker = await gateRestClient.getFuturesTickers({\n      settle: 'usdt', // Specify the settlement currency\n      contract: 'BTC_USDT', // Specify the contract\n    });\n    console.log('ticker: ', ticker); // Log the response to the console\n  } catch (e) {\n    console.error('Error in execution: ', e); // Log any errors that occur\n  }\n}\n\n// Execute the function to get futures tickers\ngetFuturesTicker();\n",
                  "metadata": {}
                },
                {
                  "type": "file",
                  "name": "submitLimitOrder.ts",
                  "path": "examples/Gate/Rest/futures/submitLimitOrder.ts",
                  "code": "import { RestClient } from 'gateio-api';\n\n// Define the account object with API key and secret\nconst account = {\n  key: process.env.API_KEY || 'yourApiHere', // Replace 'yourApiHere' with your actual API key\n  secret: process.env.API_SECRET || 'yourSecretHere', // Replace 'yourSecretHere' with your actual API secret\n};\n\n// Initialize the RestClient with the API credentials\nconst gateRestClient = new RestClient({\n  apiKey: account.key,\n  apiSecret: account.secret,\n});\n\nasync function submitFuturesOrder() {\n  try {\n    console.log('Using API keys:', account);\n\n    // Submit a limit order for futures trading\n    const result = await gateRestClient.submitFuturesOrder({\n      settle: 'usdt', // Specify the settlement currency\n      contract: 'BTC_USDT', // Specify the contract\n      size: 10, // Order size: positive for long, negative for short\n      price: '45000', // Limit price for the order\n      tif: 'gtc', // Time in force: 'gtc' (Good Till Cancelled)\n    });\n\n    console.log('Response: ', result); // Log the response to the console\n  } catch (e) {\n    console.error('Error in execution: ', e); // Log any errors that occur\n  }\n}\n\n// Execute the function to submit a futures order\nsubmitFuturesOrder();\n",
                  "metadata": {}
                },
                {
                  "type": "file",
                  "name": "submitMarketOrder.ts",
                  "path": "examples/Gate/Rest/futures/submitMarketOrder.ts",
                  "code": "import { RestClient } from 'gateio-api';\n\n// Define the account object with API key and secret\nconst account = {\n  key: process.env.API_KEY || 'yourApiHere', // Replace 'yourApiHere' with your actual API key\n  secret: process.env.API_SECRET || 'yourSecretHere', // Replace 'yourSecretHere' with your actual API secret\n};\n\n// Initialize the RestClient with the API credentials\nconst gateRestClient = new RestClient({\n  apiKey: account.key,\n  apiSecret: account.secret,\n});\n\nasync function submitFuturesOrder() {\n  try {\n    console.log('Using API keys:', account);\n\n    // Submit a market order for futures trading\n    const result = await gateRestClient.submitFuturesOrder({\n      settle: 'usdt', // Specify the settlement currency\n      contract: 'BTC_USDT', // Specify the contract\n      size: 20, // Order size: positive for long, negative for short\n      price: '0', // Market order, so price is set to '0'\n      tif: 'ioc', // Time in force: 'ioc' (Immediate Or Cancel)\n    });\n\n    console.log('Response: ', result); // Log the response to the console\n  } catch (e) {\n    console.error('Error in execution: ', e); // Log any errors that occur\n  }\n}\n\n// Execute the function to submit a futures order\nsubmitFuturesOrder();\n",
                  "metadata": {}
                },
                {
                  "type": "file",
                  "name": "testnet.ts",
                  "path": "examples/Gate/Rest/futures/testnet.ts",
                  "code": "import { RestClient } from 'gateio-api';\n\n// Define the account object with API key and secret\nconst account = {\n  key: process.env.API_KEY || 'yourApiHere', // Replace 'yourApiHere' with your actual API key\n  secret: process.env.API_SECRET || 'yourSecretHere', // Replace 'yourSecretHere' with your actual API secret\n};\n\n// Initialize the RestClient with the API credentials\nconst gateRestClient = new RestClient({\n  apiKey: account.key,\n  apiSecret: account.secret,\n  /**\n   * To use a different base URL, use the baseUrl key. The SDK uses the live environment by default:\n   * baseUrlKey: 'live',\n   *'https://api.gateio.ws/api/v4'\n   * But you can force it to use any of the available environments. Examples below.\n   */\n\n  /*\n   * Futures TestNet trading:\n   * 'https://fx-api-testnet.gateio.ws/api/v4'\n   */\n  baseUrlKey: 'futuresTestnet',\n\n  /**\n   * Futures live trading alternative (futures only):\n   * 'https://fx-api.gateio.ws/api/v4'\n   */\n  // baseUrlKey: 'futuresLiveAlternative'\n});\n\nasync function submitFuturesOrder() {\n  try {\n    console.log('Using API keys:', account);\n\n    // Submit a market order for futures trading\n    const result = await gateRestClient.submitFuturesOrder({\n      settle: 'usdt', // Specify the settlement currency\n      contract: 'BTC_USDT', // Specify the contract\n      size: 20, // Order size: positive for long, negative for short\n      price: '0', // Market order, so price is set to '0'\n      tif: 'ioc', // Time in force: 'ioc' (Immediate Or Cancel)\n    });\n\n    console.log('Response: ', result); // Log the response to the console\n  } catch (e) {\n    console.error('Error in execution: ', e); // Log any errors that occur\n  }\n}\n\n// Execute the function to submit a futures order\nsubmitFuturesOrder();\n",
                  "metadata": {}
                }
              ]
            },
            {
              "type": "folder",
              "name": "spot",
              "path": "examples/Gate/Rest/spot",
              "children": [
                {
                  "type": "file",
                  "name": "getBalances.ts",
                  "path": "examples/Gate/Rest/spot/getBalances.ts",
                  "code": "import { RestClient } from 'gateio-api';\n\n// Define the account object with API key and secret\nconst account = {\n  key: process.env.API_KEY || 'yourApiHere', // Replace 'yourApiHere' with your actual API key\n  secret: process.env.API_SECRET || 'yourSecretHere', // Replace 'yourSecretHere' with your actual API secret\n};\n\n// Initialize the RestClient with the API credentials\nconst gateRestClient = new RestClient({\n  apiKey: account.key,\n  apiSecret: account.secret,\n});\n\nasync function getSpotBalances() {\n  try {\n    console.log('Using API keys:', account);\n\n    // Fetch the spot account balances\n    const balances = await gateRestClient.getSpotAccounts();\n    console.log('Response: ', balances); // Log the response to the console\n  } catch (e) {\n    console.error('Error in execution: ', e); // Log any errors that occur\n  }\n}\n\n// Execute the function to get spot balances\ngetSpotBalances();\n",
                  "metadata": {}
                },
                {
                  "type": "file",
                  "name": "getCandles.ts",
                  "path": "examples/Gate/Rest/spot/getCandles.ts",
                  "code": "import { RestClient } from 'gateio-api';\n\n// Define the account object with API key and secret\nconst account = {\n  key: process.env.API_KEY || 'yourApiHere', // Replace 'yourApiHere' with your actual API key\n  secret: process.env.API_SECRET || 'yourSecretHere', // Replace 'yourSecretHere' with your actual API secret\n};\n\n// Initialize the RestClient with the API credentials\nconst gateRestClient = new RestClient({\n  apiKey: account.key,\n  apiSecret: account.secret,\n});\n\nasync function getSpotCandles() {\n  try {\n    console.log('Using API keys:', account);\n\n    // Fetch the spot account balances\n    const balances = await gateRestClient.getSpotCandles({\n      currency_pair: 'BTC_USDT',\n      interval: '1m',\n    });\n    console.log('Response: ', balances); // Log the response to the console\n  } catch (e) {\n    console.error('Error in execution: ', e); // Log any errors that occur\n  }\n}\n\n// Execute the function to get spot balances\ngetSpotCandles();\n",
                  "metadata": {}
                },
                {
                  "type": "file",
                  "name": "getOrders.ts",
                  "path": "examples/Gate/Rest/spot/getOrders.ts",
                  "code": "import { RestClient } from 'gateio-api';\n\n// Define the account object with API key and secret\nconst account = {\n  key: process.env.API_KEY || 'yourApiHere', // Replace 'yourApiHere' with your actual API key\n  secret: process.env.API_SECRET || 'yourSecretHere', // Replace 'yourSecretHere' with your actual API secret\n};\n\n// Initialize the RestClient with the API credentials\nconst gateRestClient = new RestClient({\n  apiKey: account.key,\n  apiSecret: account.secret,\n});\n\nasync function getSpotOrders() {\n  try {\n    console.log('Using API keys:', account);\n\n    // Fetch open spot orders for the BTC_USDT currency pair\n    const openOrders = await gateRestClient.getSpotOrders({\n      currency_pair: 'BTC_USDT', // Specify the currency pair\n      status: 'open', // Specify the status of the orders to fetch\n    });\n    console.log('openOrders: ', openOrders); // Log the response to the console\n\n    // Fetch finished spot orders for the BTC_USDT currency pair\n    const finishedOrders = await gateRestClient.getSpotOrders({\n      currency_pair: 'BTC_USDT', // Specify the currency pair\n      status: 'finished', // Specify the status of the orders to fetch\n    });\n    console.log('finishedOrders: ', finishedOrders); // Log the response to the console\n  } catch (e) {\n    console.error('Error in execution: ', e); // Log any errors that occur\n  }\n}\n\n// Execute the function to get spot orders\ngetSpotOrders();\n",
                  "metadata": {}
                },
                {
                  "type": "file",
                  "name": "getTickers.ts",
                  "path": "examples/Gate/Rest/spot/getTickers.ts",
                  "code": "import { RestClient } from 'gateio-api';\n\n// Define the account object with API key and secret\nconst account = {\n  key: process.env.API_KEY || 'yourApiHere', // Replace 'yourApiHere' with your actual API key\n  secret: process.env.API_SECRET || 'yourSecretHere', // Replace 'yourSecretHere' with your actual API secret\n};\n\n// Initialize the RestClient with the API credentials\nconst gateRestClient = new RestClient({\n  apiKey: account.key,\n  apiSecret: account.secret,\n});\n\nasync function getSpotTicker() {\n  try {\n    console.log('Using API keys:', account);\n\n    // Fetch the ticker for a specific currency pair (BTC_USDT)\n    const ticker = await gateRestClient.getSpotTicker({\n      currency_pair: 'BTC_USDT', // Specify the currency pair\n    });\n    console.log('Response: ', ticker); // Log the response to the console\n\n    // Fetch all tickers\n    const allTickers = await gateRestClient.getSpotTicker();\n    console.log('Response: ', allTickers); // Log the response to the console\n  } catch (e) {\n    console.error('Error in execution: ', e); // Log any errors that occur\n  }\n}\n\n// Execute the function to get spot tickers\ngetSpotTicker();\n",
                  "metadata": {}
                },
                {
                  "type": "file",
                  "name": "submitLimitOrder.ts",
                  "path": "examples/Gate/Rest/spot/submitLimitOrder.ts",
                  "code": "import { RestClient } from 'gateio-api';\n\n// Define the account object with API key and secret\nconst account = {\n  key: process.env.API_KEY || 'yourApiHere', // Replace 'yourApiHere' with your actual API key\n  secret: process.env.API_SECRET || 'yourSecretHere', // Replace 'yourSecretHere' with your actual API secret\n};\n\n// Initialize the RestClient with the API credentials\nconst gateRestClient = new RestClient({\n  apiKey: account.key,\n  apiSecret: account.secret,\n});\n\nasync function submitSpotOrder() {\n  try {\n    console.log('Using API keys:', account);\n\n    // Submit a limit order for spot trading\n    const result = await gateRestClient.submitSpotOrder({\n      currency_pair: 'BTC_USDT', // Specify the currency pair\n      side: 'buy', // Specify the order side: 'buy' or 'sell'\n      type: 'limit', // Specify the order type: 'limit'\n      amount: '0.001', // Specify the amount to buy\n      price: '45000', // Specify the limit price\n      time_in_force: 'gtc', // Time in force: 'gtc' (Good Till Cancelled)\n    });\n\n    console.log('Response: ', result); // Log the response to the console\n  } catch (e) {\n    console.error('Error in execution: ', e); // Log any errors that occur\n  }\n}\n\n// Execute the function to submit a spot order\nsubmitSpotOrder();\n",
                  "metadata": {}
                },
                {
                  "type": "file",
                  "name": "submitMarketOrder.ts",
                  "path": "examples/Gate/Rest/spot/submitMarketOrder.ts",
                  "code": "import { RestClient } from 'gateio-api';\n\n// Define the account object with API key and secret\nconst account = {\n  key: process.env.API_KEY || 'yourApiHere', // Replace 'yourApiHere' with your actual API key\n  secret: process.env.API_SECRET || 'yourSecretHere', // Replace 'yourSecretHere' with your actual API secret\n};\n\n// Initialize the RestClient with the API credentials\nconst gateRestClient = new RestClient({\n  apiKey: 'yourkeyhere',\n  apiSecret: 'yoursecrethere',\n});\n\nasync function submitSpotOrder() {\n  try {\n    console.log('Using API keys:', account);\n\n    // Submit a market order for spot trading\n    const result = await gateRestClient.submitSpotOrder({\n      currency_pair: 'BTC_USDT', // Specify the currency pair\n      side: 'buy', // Specify the order side: 'buy' or 'sell'\n      type: 'market', // Specify the order type: 'market'\n      amount: '10', // Specify the amount to buy\n      time_in_force: 'ioc', // Time in force: 'ioc' (Immediate Or Cancel)\n    });\n\n    console.log('Response: ', result); // Log the response to the console\n  } catch (e) {\n    console.error('Error in execution: ', e); // Log any errors that occur\n  }\n}\n\n// Execute the function to submit a spot order\nsubmitSpotOrder();\n",
                  "metadata": {}
                }
              ]
            }
          ]
        },
        {
          "type": "folder",
          "name": "Websocket",
          "path": "examples/Gate/Websocket",
          "children": [
            {
              "type": "folder",
              "name": "WS-API",
              "path": "examples/Gate/Websocket/WS-API",
              "children": [
                {
                  "type": "file",
                  "name": "ws-api-client.ts",
                  "path": "examples/Gate/Websocket/WS-API/ws-api-client.ts",
                  "code": "import { WebsocketAPIClient, WS_KEY_MAP } from 'gateio-api';\n\nconst account = {\n  key: process.env.API_KEY || 'insert_key_here',\n  secret: process.env.API_SECRET || 'insert_secret_here',\n};\n\nasync function start() {\n  const client = new WebsocketAPIClient({\n    apiKey: account.key,\n    apiSecret: account.secret,\n    reauthWSAPIOnReconnect: true,\n  });\n\n  try {\n    /**\n     * Optional: authenticate in advance. This will prepare and authenticate a connection.\n     * Useful to save time for the first request but completely optional. It will also happen automatically when you make your first request.\n     */\n    // console.log(new Date(), 'Authenticating in advance...');\n    // await client.getWSClient().connectWSAPI('spotV4');\n    // console.log(new Date(), 'Authenticating in advance...OK!');\n\n    /* ============ SPOT TRADING EXAMPLES ============ */\n\n    // SPOT ORDER PLACE - Submit a new spot order\n    const newOrder = await client.submitNewSpotOrder({\n      text: 't-my-custom-id',\n      currency_pair: 'BTC_USDT',\n      type: 'limit',\n      account: 'spot',\n      side: 'buy',\n      amount: '1',\n      price: '10000',\n    });\n    console.log(new Date(), 'Result of the order:', newOrder.data);\n\n    // SPOT ORDER CANCEL - Cancel a specific spot order\n    const cancelOrder = await client.cancelSpotOrder({\n      order_id: '1700664330',\n      currency_pair: 'BTC_USDT',\n      account: 'spot',\n    });\n    console.log(new Date(), 'Cancel order result:', cancelOrder.data);\n\n    // SPOT ORDER CANCEL BY IDS - Cancel orders by ID list\n    const cancelOrdersByIds = await client.cancelSpotOrderById([\n      {\n        currency_pair: 'BTC_USDT',\n        id: '1700664343',\n        account: 'spot',\n      },\n    ]);\n    console.log(\n      new Date(),\n      'Cancel orders by IDs result:',\n      cancelOrdersByIds.data,\n    );\n\n    // SPOT ORDER CANCEL BY CURRENCY PAIR - Cancel all orders for a currency pair\n    const cancelOrdersByCurrencyPair = await client.cancelSpotOrderForSymbol({\n      currency_pair: 'BTC_USDT',\n      side: 'buy',\n      account: 'spot',\n    });\n    console.log(\n      new Date(),\n      'Cancel orders by currency pair result:',\n      cancelOrdersByCurrencyPair.data,\n    );\n\n    // SPOT ORDER AMEND - Update an existing spot order\n    const amendOrder = await client.updateSpotOrder({\n      order_id: '1700664330',\n      currency_pair: 'BTC_USDT',\n      price: '12000',\n      amount: '0.002',\n      amend_text: 'price-update',\n    });\n    console.log(new Date(), 'Amend order result:', amendOrder.data);\n\n    // SPOT ORDER STATUS - Get status of a specific spot order\n    const orderStatus = await client.getSpotOrderStatus({\n      order_id: '1700664330',\n      currency_pair: 'BTC_USDT',\n      account: 'spot',\n    });\n    console.log(new Date(), 'Order status result:', orderStatus.data);\n\n    // SPOT ORDER LIST - Get list of spot orders\n    const getOrders = await client.getSpotOrders({\n      currency_pair: 'BTC_USDT',\n      status: 'open',\n      page: 1,\n      limit: 10,\n      account: 'spot',\n      side: 'buy',\n    });\n    console.log(new Date(), 'Result of the orders:', getOrders.data);\n\n    /* ============ FUTURES TRADING EXAMPLES ============ */\n\n    /**\n     * Gate has different websocket groups depending on the futures product.\n     *\n     * This affects which connection your command is sent to, so make sure to pass one matching your request. Look at WS_KEY_MAP (or the examples below) for details on the available product groups.\n     */\n    const FUTURES_CONNECTION_GROUP_WS_KEY = WS_KEY_MAP.perpFuturesUSDTV4;\n\n    /**\n     * Also optional, as for spot. Keep in mind the first parameter (wsKey) might vary depending on which WS URL is needed.\n     */\n\n    // console.log(new Date(), 'Authenticating in advance...');\n    // await client.getWSClient().connectWSAPI(futuresConnectionGroup);\n    // await client.getWSClient().connectWSAPI('perpFuturesUSDTV4');\n    // await client.getWSClient().connectWSAPI('perpFuturesBTCV4');\n    // await client.getWSClient().connectWSAPI('deliveryFuturesUSDTV4');\n    // await client.getWSClient().connectWSAPI('perpFuturesBTCV4');\n    // console.log(new Date(), 'Authenticating in advance...OK!');\n\n    // FUTURES ORDER PLACE - Submit a new futures order\n    const newFuturesOrder = await client.submitNewFuturesOrder(\n      {\n        contract: 'BTC_USDT',\n        size: 10,\n        price: '31503.28',\n        tif: 'gtc',\n        text: 't-my-custom-id',\n        iceberg: 0,\n        close: false,\n        reduce_only: false,\n        auto_size: undefined,\n        stp_act: 'cn',\n      },\n      FUTURES_CONNECTION_GROUP_WS_KEY,\n    );\n    console.log(new Date(), 'New futures order result:', newFuturesOrder.data);\n\n    // FUTURES ORDER BATCH PLACE - Submit multiple futures orders\n    const batchFuturesOrders = await client.submitNewFuturesBatchOrder(\n      [\n        {\n          contract: 'BTC_USDT',\n          size: 10,\n          price: '31403.18',\n          tif: 'gtc',\n          text: 't-my-custom-id-1',\n        },\n        {\n          contract: 'ETH_USDT',\n          size: 20,\n          price: '2500.50',\n          tif: 'gtc',\n          text: 't-my-custom-id-2',\n        },\n      ],\n      FUTURES_CONNECTION_GROUP_WS_KEY,\n    );\n    console.log(\n      new Date(),\n      'Batch futures orders result:',\n      batchFuturesOrders.data,\n    );\n\n    // FUTURES ORDER CANCEL - Cancel a specific futures order\n    const cancelFuturesOrder = await client.cancelFuturesOrder(\n      {\n        order_id: '74046514',\n      },\n      FUTURES_CONNECTION_GROUP_WS_KEY,\n    );\n    console.log(\n      new Date(),\n      'Cancel futures order result:',\n      cancelFuturesOrder.data,\n    );\n\n    // FUTURES ORDER CANCEL BY IDS - Cancel futures orders by ID list\n    const cancelFuturesOrdersByIds = await client.cancelFuturesOrderById(\n      ['1694883366', '123'],\n      FUTURES_CONNECTION_GROUP_WS_KEY,\n    );\n    console.log(\n      new Date(),\n      'Cancel futures orders by IDs result:',\n      cancelFuturesOrdersByIds.data,\n    );\n\n    // FUTURES ORDER CANCEL ALL - Cancel all open futures orders\n    const cancelAllFuturesOrders = await client.cancelFuturesAllOpenOrders(\n      {\n        contract: 'BTC_USDT',\n        side: 'bid',\n      },\n      FUTURES_CONNECTION_GROUP_WS_KEY,\n    );\n    console.log(\n      new Date(),\n      'Cancel all futures orders result:',\n      cancelAllFuturesOrders.data,\n    );\n\n    // FUTURES ORDER AMEND - Update an existing futures order\n    const amendFuturesOrder = await client.updateFuturesOrder(\n      {\n        order_id: '74046543',\n        price: '31303.18',\n        size: 15,\n        amend_text: 'price-and-size-update',\n      },\n      FUTURES_CONNECTION_GROUP_WS_KEY,\n    );\n    console.log(\n      new Date(),\n      'Amend futures order result:',\n      amendFuturesOrder.data,\n    );\n\n    // FUTURES ORDER LIST - Get list of futures orders\n    const getFuturesOrders = await client.getFuturesOrders(\n      {\n        contract: 'BTC_USDT',\n        status: 'open',\n        limit: 10,\n        offset: 0,\n        last_id: undefined,\n        count_total: 0,\n      },\n      FUTURES_CONNECTION_GROUP_WS_KEY,\n    );\n    console.log(\n      new Date(),\n      'Futures orders list result:',\n      getFuturesOrders.data,\n    );\n\n    // FUTURES ORDER STATUS - Get status of a specific futures order\n    const futuresOrderStatus = await client.getFuturesOrderStatus(\n      {\n        order_id: '74046543',\n      },\n      FUTURES_CONNECTION_GROUP_WS_KEY,\n    );\n    console.log(\n      new Date(),\n      'Futures order status result:',\n      futuresOrderStatus.data,\n    );\n  } catch (e) {\n    console.error(new Date(), 'Error:', e);\n  }\n}\n\nstart();\n",
                  "metadata": {}
                },
                {
                  "type": "file",
                  "name": "ws-private-perp-futures-wsapi.ts",
                  "path": "examples/Gate/Websocket/WS-API/ws-private-perp-futures-wsapi.ts",
                  "code": "/* eslint-disable @typescript-eslint/no-unused-vars */\n\nimport { LogParams, WebsocketClient } from 'gateio-api';\n\nconst account = {\n  key: process.env.API_KEY || 'apiKeyHere',\n  secret: process.env.API_SECRET || 'apiSecretHere',\n};\n\n// Define a custom logger object to handle logging at different levels\nconst customLogger = {\n  // Trace level logging: used for detailed debugging information\n  trace: (...params: LogParams): void => {\n    // Uncomment the line below to enable trace logging\n    // console.log(new Date(), 'trace', ...params);\n  },\n  // Info level logging: used for general informational messages\n  info: (...params: LogParams): void => {\n    console.log(new Date(), 'info', ...params);\n  },\n  // Error level logging: used for error messages\n  error: (...params: LogParams): void => {\n    console.error(new Date(), 'error', ...params);\n  },\n};\n\nasync function start() {\n  const client = new WebsocketClient(\n    {\n      apiKey: account.key,\n      apiSecret: account.secret,\n      reauthWSAPIOnReconnect: true,\n    },\n    customLogger,\n  );\n\n  client.on('open', (data) => {\n    console.log(new Date(), 'ws connected ', data?.wsKey);\n  });\n\n  // See comments below about event-driven vs promise-driven. Not needed if using the promise-driven approach\n  // client.on('update', (data) => {\n  //   // console.info(new Date(), 'ws data received: ', JSON.stringify(data));\n  //   console.info(new Date(), 'ws data received: ', JSON.stringify(data, null, 2));\n  // });\n\n  // Something happened, attempting to reconnect\n  client.on('reconnect', (data) => {\n    console.log(new Date(), 'ws reconnect: ', data);\n  });\n\n  // Reconnect successful\n  client.on('reconnected', (data) => {\n    console.log(new Date(), 'ws reconnected: ', data);\n  });\n\n  // Connection closed. If unexpected, expect reconnect -> reconnected.\n  client.on('close', (data) => {\n    console.error(new Date(), 'ws close: ', data);\n  });\n\n  // Reply to a request, e.g. \"subscribe\"/\"unsubscribe\"/\"authenticate\"\n  // See comments below about event-driven vs promise-driven. Not needed if using the promise-driven approach\n  // client.on('response', (data) => {\n  //   console.info(\n  //     new Date(),\n  //     'ws server reply ',\n  //     JSON.stringify(data, null, 2),\n  //     '\\n',\n  //   );\n  // });\n\n  client.on('exception', (data) => {\n    console.error(new Date(), 'ws exception: ', data);\n  });\n\n  // Optional, listen to this event if you prefer the event-driven approach.\n  // See below comments on event-driven vs promise-driven.\n  // client.on('authenticated', (data) => {\n  //   console.error(new Date(), 'ws authenticated: ', data);\n  // });\n\n  try {\n    /**\n     * All WebSocket API (WS API) messaging should be done via the sendWSAPIRequest method.\n     *\n     * You have two ways to handle responses on the WS API. You can either:\n     * - event-driven: process async `response` and `update` events from the websocket client, OR\n     * - promise-driven: await every call to `client.sendWSAPIRequest`, this can behave similar to using a REST API (successful responses resolve, exceptions reject).\n     */\n\n    /**\n     * To authenticate, send an empty request to \"futures.login\". The SDK will handle all the parameters.\n     *\n     * Optional - you can inject rich types to set the response type\n     *    const loginResult = await client.sendWSAPIRequest<WSAPIResponse<WSAPILoginResponse>>('perpFuturesUSDTV4', 'futures.login');\n     */\n    console.log(new Date(), 'try authenticate');\n    const loginResult = await client.sendWSAPIRequest(\n      'perpFuturesUSDTV4',\n      'futures.login',\n    );\n\n    client.sendWSAPIRequest('perpFuturesUSDTV4', 'futures.login');\n    console.log(new Date(), 'authenticated!', loginResult);\n\n    /**\n     * For other channels, the 3rd parameter should have any parameters for the request (the payload).\n     *\n     * Note that internal parameters such as \"signature\" etc are all handled automatically by the SDK.\n     *\n     */\n\n    /**\n     * Submit futures order\n     */\n\n    console.log(new Date(), 'Sending futures order:');\n    const submitOrder = await client.sendWSAPIRequest(\n      'perpFuturesUSDTV4',\n      'futures.order_place',\n      {\n        contract: 'BTC_USDT',\n        size: 20, // positive for long, negative for short\n        price: '0',\n        tif: 'ioc',\n      },\n    );\n\n    console.log(new Date(), 'Result: ', submitOrder);\n\n    /**\n     * Submit batch futures order\n     */\n\n    console.log(new Date(), 'Sending batch futures order!');\n    const submitBatchOrder = await client.sendWSAPIRequest(\n      'perpFuturesUSDTV4',\n      'futures.order_batch_place',\n      [\n        {\n          contract: 'ETH_USDT',\n          size: 10, // positive for long, negative for short\n          price: '0',\n          tif: 'ioc',\n        },\n        {\n          contract: 'BTC_USDT',\n          size: 10, // positive for long, negative for short\n          price: '0',\n          tif: 'ioc',\n        },\n      ],\n    );\n\n    console.log(new Date(), 'Result: ', submitBatchOrder);\n\n    /**\n     * Cancel futures order\n     */\n    console.log(new Date(), 'Cancelling futures order!');\n    const cancelOrder = await client.sendWSAPIRequest(\n      'perpFuturesUSDTV4',\n      'futures.order_cancel',\n      { order_id: 'orderIDHere' },\n    );\n\n    console.log(new Date(), 'Result: ', cancelOrder);\n\n    /**\n     * Cancel all futures orders\n     */\n    console.log(new Date(), 'Cancelling all futures orders!');\n    const cancelAllOrders = await client.sendWSAPIRequest(\n      'perpFuturesUSDTV4',\n      'futures.order_cancel_cp',\n      { contract: 'BTC_USDT' },\n    );\n\n    console.log(new Date(), 'Result: ', cancelAllOrders);\n\n    /**\n     * Update/Amend Futures order\n     */\n    console.log(new Date(), 'Updating futures order!');\n    const updateOrder = await client.sendWSAPIRequest(\n      'perpFuturesUSDTV4',\n      'futures.order_amend',\n      {\n        order_id: 'orderIdHere',\n        price: '31303.180000',\n      },\n    );\n\n    console.log(new Date(), 'Result: ', updateOrder);\n\n    /**\n     * Get orders list\n     */\n\n    console.log(new Date(), 'Getting futures orders!');\n    const getList = await client.sendWSAPIRequest(\n      'perpFuturesUSDTV4',\n      'futures.order_list',\n      {\n        status: 'open',\n        contract: 'BTC_USDT',\n      },\n    );\n\n    console.log(new Date(), 'Result: ', getList);\n\n    /**\n     * Get order status\n     */\n\n    console.log(new Date(), 'Getting order status!');\n    const getStatus = await client.sendWSAPIRequest(\n      'perpFuturesUSDTV4',\n      'futures.order_status',\n      {\n        order_id: '74046543',\n      },\n    );\n\n    console.log(new Date(), 'Result: ', getStatus);\n  } catch (e) {\n    console.error('WS API Error: ', e);\n  }\n}\n\nstart();\n",
                  "metadata": {}
                },
                {
                  "type": "file",
                  "name": "ws-private-spot-wsapi.ts",
                  "path": "examples/Gate/Websocket/WS-API/ws-private-spot-wsapi.ts",
                  "code": "/* eslint-disable @typescript-eslint/no-unused-vars */\n\nimport { LogParams, WebsocketClient } from 'gateio-api';\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst account = {\n  key: process.env.API_KEY || 'apiKeyHere',\n  secret: process.env.API_SECRET || 'apiSecretHere',\n};\n\n// Define a custom logger object to handle logging at different levels\nconst customLogger = {\n  // Trace level logging: used for detailed debugging information\n  trace: (...params: LogParams): void => {\n    // Uncomment the line below to enable trace logging\n    // console.log(new Date(), 'trace', ...params);\n  },\n  // Info level logging: used for general informational messages\n  info: (...params: LogParams): void => {\n    console.log(new Date(), 'info', ...params);\n  },\n  // Error level logging: used for error messages\n  error: (...params: LogParams): void => {\n    console.error(new Date(), 'error', ...params);\n  },\n};\n\nasync function start() {\n  const client = new WebsocketClient(\n    {\n      apiKey: account.key,\n      apiSecret: account.secret,\n      reauthWSAPIOnReconnect: true,\n    },\n    customLogger,\n  );\n\n  client.on('open', (data) => {\n    console.log(new Date(), 'ws connected ', data?.wsKey);\n  });\n\n  // See comments below about event-driven vs promise-driven. Not needed if using the promise-driven approach\n  // client.on('update', (data) => {\n  //   // console.info(new Date(), 'ws data received: ', JSON.stringify(data));\n  //   console.info(new Date(), 'ws data received: ', JSON.stringify(data, null, 2));\n  // });\n\n  // Something happened, attempting to reconnect\n  client.on('reconnect', (data) => {\n    console.log(new Date(), 'ws reconnect: ', data);\n  });\n\n  // Reconnect successful\n  client.on('reconnected', (data) => {\n    console.log(new Date(), 'ws reconnected: ', data);\n  });\n\n  // Connection closed. If unexpected, expect reconnect -> reconnected.\n  client.on('close', (data) => {\n    console.error(new Date(), 'ws close: ', data);\n  });\n\n  // Reply to a request, e.g. \"subscribe\"/\"unsubscribe\"/\"authenticate\"\n  // See comments below about event-driven vs promise-driven. Not needed if using the promise-driven approach\n  // client.on('response', (data) => {\n  //   console.info(\n  //     new Date(),\n  //     'ws server reply ',\n  //     JSON.stringify(data, null, 2),\n  //     '\\n',\n  //   );\n  // });\n\n  client.on('exception', (data) => {\n    console.error(new Date(), 'ws exception: ', data);\n  });\n\n  // Optional, listen to this event if you prefer the event-driven approach.\n  // See below comments on event-driven vs promise-driven.\n  // client.on('authenticated', (data) => {\n  //   console.error(new Date(), 'ws authenticated: ', data);\n  // });\n\n  try {\n    /**\n     * All WebSocket API (WS API) messaging should be done via the sendWSAPIRequest method.\n     *\n     * You have two ways to handle responses on the WS API. You can either:\n     * - event-driven: process async `response` and `update` events from the websocket client, OR\n     * - promise-driven: await every call to `client.sendWSAPIRequest`, this can behave similar to using a REST API (successful responses resolve, exceptions reject).\n     */\n\n    /**\n     * No need to authenticate first - the SDK will automatically authenticate for you when you send your first request.\n     *\n     * Unless you want to prepare the connection before your first request, to speed up your first request.\n     */\n    console.log(new Date(), 'try authenticate');\n    await client.connectWSAPI('spotV4');\n    console.log(new Date(), 'authenticated!');\n\n    /**\n     * For other channels, the 3rd parameter should have any parameters for the request (the payload that goes in req_param in the docs).\n     *\n     * See WsAPIRequestsTopicMap for a topic->parameter map.\n     *\n     * Note that internal parameters such as \"signature\" etc are all handled automatically by the SDK.\n     */\n\n    /**\n     * Submit spot order\n     */\n\n    console.log(new Date(), 'Submitting spot order!');\n    const newOrder = await client.sendWSAPIRequest(\n      'spotV4',\n      'spot.order_place',\n      {\n        text: 't-my-custom-id',\n        currency_pair: 'BTC_USDT',\n        type: 'limit',\n        account: 'spot',\n        side: 'buy',\n        amount: '0.001',\n        price: '45000',\n      },\n    );\n\n    console.log(new Date(), 'Result:', newOrder);\n\n    /**\n     * Cancel spot order\n     */\n\n    console.log(new Date(), 'Cancelling spot order!');\n    const cancelOrder = await client.sendWSAPIRequest(\n      'spotV4',\n      'spot.order_cancel',\n      {\n        order_id: 'yourOrderIdHere1',\n        currency_pair: 'BTC_USDT',\n      },\n    );\n\n    console.log(new Date(), 'Result:', cancelOrder);\n\n    /**\n     * Batch cancel spot order\n     */\n\n    console.log(new Date(), 'Cancelling spot orders!');\n    const cancelOrders = await client.sendWSAPIRequest(\n      'spotV4',\n      'spot.order_cancel_ids',\n      [\n        {\n          id: 'yourOrderIdHere1',\n          currency_pair: 'BTC_USDT',\n        },\n        {\n          id: 'yourOrderIdHere2',\n          currency_pair: 'ETH_USDT',\n        },\n      ],\n    );\n\n    console.log(new Date(), 'Result:', cancelOrders);\n\n    /**\n     * Amend/Update spot order\n     */\n\n    console.log(new Date(), 'Updating spot order!');\n    const updateOrder = await client.sendWSAPIRequest(\n      'spotV4',\n      'spot.order_amend',\n      {\n        order_id: 'yourIdHere',\n        currency_pair: 'BTC_USDT',\n        price: '50000',\n      },\n    );\n\n    console.log(new Date(), 'Result:', updateOrder);\n\n    /**\n     * Get spot order status\n     */\n\n    console.log(new Date(), 'Getting order status');\n    const orderStatus = await client.sendWSAPIRequest(\n      'spotV4',\n      'spot.order_status',\n      {\n        order_id: '600995435390',\n        currency_pair: 'BTC_USDT',\n      },\n    );\n\n    console.log(new Date(), 'orderStatus result!', orderStatus);\n\n    /**\n     * If you don't want to use await (and prefer the async event emitter), make sure to still include a catch block.\n     *\n     * The response will come async via the event emitter in the WS Client.\n     */\n\n    // client\n    //   .sendWSAPIRequest('spotV4', 'spot.order_status', {\n    //     order_id: '600995435390',\n    //     currency_pair: 'BTC_USDT',\n    //   })\n    //   .catch((e) => {\n    //     console.error(`exception ws api call, get spot order status: `, e);\n    //   });\n  } catch (e) {\n    console.error('WS API Error: ', e);\n  }\n}\n\nstart();\n",
                  "metadata": {}
                }
              ]
            },
            {
              "type": "file",
              "name": "ws-private-perp-futures.ts",
              "path": "examples/Gate/Websocket/ws-private-perp-futures.ts",
              "code": "/* eslint-disable @typescript-eslint/no-unused-vars */\nimport { LogParams, WebsocketClient, WsTopicRequest } from 'gateio-api';\n\nconst account = {\n  key: process.env.API_KEY || 'apiKeyHere',\n  secret: process.env.API_SECRET || 'apiSecretHere',\n};\n\n// Define a custom logger object to handle logging at different levels\nconst customLogger = {\n  // Trace level logging: used for detailed debugging information\n  trace: (...params: LogParams): void => {\n    // Uncomment the line below to enable trace logging\n    // console.log(new Date(), 'trace', ...params);\n  },\n  // Info level logging: used for general informational messages\n  info: (...params: LogParams): void => {\n    console.log(new Date(), 'info', ...params);\n  },\n  // Error level logging: used for error messages\n  error: (...params: LogParams): void => {\n    console.error(new Date(), 'error', ...params);\n  },\n};\n\nasync function start() {\n  const client = new WebsocketClient(\n    {\n      apiKey: account.key,\n      apiSecret: account.secret,\n    },\n    customLogger,\n  );\n\n  // console.log('auth with: ', account);\n  client.on('open', (data) => {\n    console.log('connected ', data?.wsKey);\n  });\n\n  // Data received\n  client.on('update', (data) => {\n    console.info('data received: ', JSON.stringify(data));\n  });\n\n  // Something happened, attempting to reconnect\n  client.on('reconnect', (data) => {\n    console.log('reconnect: ', data);\n  });\n\n  // Reconnect successful\n  client.on('reconnected', (data) => {\n    console.log('reconnected: ', data);\n  });\n\n  // Connection closed. If unexpected, expect reconnect -> reconnected.\n  client.on('close', (data) => {\n    console.error('close: ', data);\n  });\n\n  // Reply to a request, e.g. \"subscribe\"/\"unsubscribe\"/\"authenticate\"\n  client.on('response', (data) => {\n    console.info('server reply: ', JSON.stringify(data), '\\n');\n  });\n\n  client.on('exception', (data) => {\n    console.error('exception: ', data);\n  });\n\n  client.on('authenticated', (data) => {\n    console.error('authenticated: ', data);\n  });\n\n  try {\n    // TODO: many private topics use your user ID\n    const myUserID = '20011';\n\n    const userBalances: WsTopicRequest = {\n      topic: 'futures.balances',\n      payload: [myUserID],\n    };\n\n    const userTrades: WsTopicRequest = {\n      topic: 'futures.usertrades',\n      payload: [myUserID, '!all'],\n    };\n\n    const userLiquidates: WsTopicRequest = {\n      topic: 'futures.liquidates',\n      payload: [myUserID, '!all'],\n    };\n\n    /**\n     * Either send one topic (with params) at a time\n     */\n    // client.subscribe({\n    //   topic: 'futures.usertrades',\n    //   payload: [myUserID, '!all'],\n    // }, 'perpFuturesUSDTV4');\n\n    /**\n     * Or send multiple topics in a batch (grouped by ws connection (WsKey))\n     * You can also use strings for topics that don't have any parameters, even if you mix multiple requests into one function call:\n     */\n    client.subscribe(\n      [userBalances, userTrades, userLiquidates],\n      'perpFuturesUSDTV4',\n    );\n  } catch (e) {\n    console.error('Req error: ', e);\n  }\n}\n\nstart();\n",
              "metadata": {}
            },
            {
              "type": "file",
              "name": "ws-private-spot.ts",
              "path": "examples/Gate/Websocket/ws-private-spot.ts",
              "code": "/* eslint-disable @typescript-eslint/no-unused-vars */\nimport { LogParams, WebsocketClient, WsTopicRequest } from 'gateio-api';\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst account = {\n  key: process.env.API_KEY || 'apiKeyHere',\n  secret: process.env.API_SECRET || 'apiSecretHere',\n};\n\n// Define a custom logger object to handle logging at different levels\nconst customLogger = {\n  // Trace level logging: used for detailed debugging information\n  trace: (...params: LogParams): void => {\n    // Uncomment the line below to enable trace logging\n    // console.log(new Date(), 'trace', ...params);\n  },\n  // Info level logging: used for general informational messages\n  info: (...params: LogParams): void => {\n    console.log(new Date(), 'info', ...params);\n  },\n  // Error level logging: used for error messages\n  error: (...params: LogParams): void => {\n    console.error(new Date(), 'error', ...params);\n  },\n};\n\nasync function start() {\n  const client = new WebsocketClient(\n    {\n      apiKey: account.key,\n      apiSecret: account.secret,\n    },\n    customLogger,\n  );\n\n  // console.log('auth with: ', account);\n  client.on('open', (data) => {\n    console.log('connected ', data?.wsKey);\n  });\n\n  // Data received\n  client.on('update', (data) => {\n    console.info('data received: ', JSON.stringify(data));\n  });\n\n  // Something happened, attempting to reconnect\n  client.on('reconnect', (data) => {\n    console.log('reconnect: ', data);\n  });\n\n  // Reconnect successful\n  client.on('reconnected', (data) => {\n    console.log('reconnected: ', data);\n  });\n\n  // Connection closed. If unexpected, expect reconnect -> reconnected.\n  client.on('close', (data) => {\n    console.error('close: ', data);\n  });\n\n  // Reply to a request, e.g. \"subscribe\"/\"unsubscribe\"/\"authenticate\"\n  client.on('response', (data) => {\n    console.info('server reply: ', JSON.stringify(data), '\\n');\n  });\n\n  client.on('exception', (data) => {\n    console.error('exception: ', data);\n  });\n\n  client.on('authenticated', (data) => {\n    console.error('authenticated: ', data);\n  });\n\n  try {\n    // client.subscribe(topics, 'spotV4');\n\n    const topicWithoutParamsAsString = 'spot.balances';\n\n    // This has the same effect as above, it's just a different way of messaging which topic this is for\n    // const topicWithoutParamsAsObject: WsTopicRequest = {\n    //   topic: 'spot.balances',\n    // };\n\n    const userOrders: WsTopicRequest = {\n      topic: 'spot.orders',\n      payload: ['BTC_USDT', 'ETH_USDT', 'MATIC_USDT'],\n    };\n\n    const userTrades: WsTopicRequest = {\n      topic: 'spot.usertrades',\n      payload: ['BTC_USDT', 'ETH_USDT', 'MATIC_USDT'],\n    };\n\n    const userPriceOrders: WsTopicRequest = {\n      topic: 'spot.priceorders',\n      payload: ['!all'],\n    };\n\n    /**\n     * Either send one topic (with optional params) at a time\n     */\n    // client.subscribe(topicWithoutParamsAsObject, 'spotV4');\n\n    /**\n     * Or send multiple topics in a batch (grouped by ws connection (WsKey))\n     * You can also use strings for topics that don't have any parameters, even if you mix multiple requests into one function call:\n     */\n    client.subscribe(\n      [topicWithoutParamsAsString, userOrders, userTrades, userPriceOrders],\n      'spotV4',\n    );\n\n    /**\n     * You can also subscribe in separate function calls as you wish.\n     *\n     * Any duplicate requests should get filtered out (e.g. here we subscribed to \"spot.balances\" twice, but the WS client will filter this out)\n     */\n    client.subscribe(\n      [\n        'spot.balances',\n        'spot.margin_balances',\n        'spot.funding_balances',\n        'spot.cross_balances',\n      ],\n      'spotV4',\n    );\n  } catch (e) {\n    console.error('Req error: ', e);\n  }\n}\n\nstart();\n",
              "metadata": {}
            },
            {
              "type": "file",
              "name": "ws-public.ts",
              "path": "examples/Gate/Websocket/ws-public.ts",
              "code": "// eslint-disable-next-line @typescript-eslint/no-unused-vars\nimport { WebsocketClient, WsTopicRequest } from 'gateio-api';\n\n// const customLogger = {\n//   // eslint-disable-next-line @typescript-eslint/no-unused-vars\n//   trace: (...params: LogParams): void => {\n//     console.log('trace', ...params);\n//   },\n//   info: (...params: LogParams): void => {\n//     console.log('info', ...params);\n//   },\n//   error: (...params: LogParams): void => {\n//     console.error('error', ...params);\n//   },\n// };\n\nasync function start() {\n  const client = new WebsocketClient();\n\n  // Optional, inject a custom logger\n  // const client = new WebsocketClient({}, customLogger);\n\n  client.on('open', (data) => {\n    console.log('connected ', data?.wsKey);\n  });\n\n  // Data received\n  client.on('update', (data) => {\n    console.info('data received: ', JSON.stringify(data));\n  });\n\n  // Something happened, attempting to reconnect\n  client.on('reconnect', (data) => {\n    console.log('reconnect: ', data);\n  });\n\n  // Reconnect successful\n  client.on('reconnected', (data) => {\n    console.log('reconnected: ', data);\n  });\n\n  // Connection closed. If unexpected, expect reconnect -> reconnected.\n  client.on('close', (data) => {\n    console.error('close: ', data);\n  });\n\n  // Reply to a request, e.g. \"subscribe\"/\"unsubscribe\"/\"authenticate\"\n  client.on('response', (data) => {\n    console.info('server reply: ', JSON.stringify(data), '\\n');\n  });\n\n  client.on('exception', (data) => {\n    console.error('exception: ', data);\n  });\n\n  client.on('authenticated', (data) => {\n    console.error('authenticated: ', data);\n  });\n\n  try {\n    const tickersRequestWithParams: WsTopicRequest = {\n      topic: 'spot.tickers',\n      payload: ['BTC_USDT', 'ETH_USDT', 'MATIC_USDT'],\n    };\n\n    const rawTradesRequestWithParams: WsTopicRequest = {\n      topic: 'spot.trades',\n      payload: ['BTC_USDT', 'ETH_USDT', 'MATIC_USDT'],\n    };\n\n    // const topicWithoutParamsAsString = 'spot.balances';\n\n    // This has the same effect as above, it's just a different way of messaging which topic this is for\n    // const topicWithoutParamsAsObject: WsTopicRequest = {\n    //   topic: 'spot.balances',\n    // };\n\n    /**\n     * Either send one topic (with optional params) at a time\n     */\n    // client.subscribe(tickersRequestWithParams, 'spotV4');\n\n    /**\n     * Or send multiple topics in a batch (grouped by ws connection (WsKey))\n     */\n    client.subscribe(\n      [tickersRequestWithParams, rawTradesRequestWithParams],\n      'spotV4',\n    );\n\n    // /**\n    //  * You can also use strings for topics that don't have any parameters, even if you mix multiple requests into one function call:\n    //  */\n    // client.subscribe(\n    //   [tickersRequestWithParams, rawTradesRequestWithParams, topicWithoutParamsAsString],\n    //   'spotV4',\n    // );\n  } catch (e) {\n    console.error('Req error: ', e);\n  }\n}\n\nstart();\n",
              "metadata": {}
            }
          ]
        }
      ]
    },
    {
      "type": "folder",
      "name": "Kraken",
      "path": "examples/Kraken",
      "children": [
        {
          "type": "folder",
          "name": "Derivatives",
          "path": "examples/Kraken/Derivatives",
          "children": [
            {
              "type": "folder",
              "name": "Private",
              "path": "examples/Kraken/Derivatives/Private",
              "children": [
                {
                  "type": "file",
                  "name": "account.ts",
                  "path": "examples/Kraken/Derivatives/Private/account.ts",
                  "code": "/* eslint-disable @typescript-eslint/no-unused-vars */\nimport { DerivativesClient } from '@siebly/kraken-api';\n\n// This example shows how to call Kraken API endpoint with either node.js,\n// javascript (js) or typescript (ts) with the npm module \"@siebly/kraken-api\" for Kraken exchange\n// for FUTURES ACCOUNT INFORMATION\n\n// initialise the client\n/**\n *\n * Kraken Futures API uses API Key and API Secret\n *\n * Example:\n * {\n *   apiKey: 'your-api-key',\n *   apiSecret: 'your-api-secret',\n * }\n *\n * API Key Permissions Required:\n * - Read access for account information\n * - Withdrawal permissions for transfers\n *\n */\nconst client = new DerivativesClient({\n  apiKey: process.env.API_FUTURES_KEY || 'insertApiKeyHere',\n  apiSecret: process.env.API_FUTURES_SECRET || 'insertApiSecretHere',\n});\n\nasync function getWallets() {\n  try {\n    // Get all wallets (cash and margin accounts)\n    const wallets = await client.getAccounts();\n    console.log('Wallets: ', JSON.stringify(wallets, null, 2));\n\n    // Response includes:\n    // - cash: Cash account with balances\n    // - flex: Multi-collateral wallet with margin info\n    // - Available margin, portfolio value, PnL\n    // - Initial/maintenance margin requirements\n    // For each margin account:\n    //   - balances, auxiliary (pv, pnl, af, funding)\n    //   - marginRequirements (im, mm, lt, tt)\n    //   - triggerEstimates\n  } catch (e) {\n    console.error('Get wallets error: ', e);\n  }\n}\n\nasync function getOpenPositions() {\n  try {\n    // Get all open Futures positions\n    const openPositions = await client.getOpenPositions();\n    console.log('Open Positions: ', JSON.stringify(openPositions, null, 2));\n\n    // Response includes for each position:\n    // - symbol: Futures symbol\n    // - side: long or short\n    // - size: Position size\n    // - price: Average entry price\n    // - fillTime: When position was opened\n    // - unrealizedFunding: Unrealized funding\n  } catch (e) {\n    console.error('Get open positions error: ', e);\n  }\n}\n\nasync function getFills() {\n  try {\n    // Get filled orders history (last 100)\n    const fills = await client.getFills();\n    console.log('Fills: ', JSON.stringify(fills, null, 2));\n\n    // Response includes for each fill:\n    // - fill_id: Unique fill identifier\n    // - order_id: Associated order ID\n    // - symbol: Futures symbol\n    // - side: buy or sell\n    // - size: Fill size\n    // - price: Fill price\n    // - fillTime: Execution time\n    // - fillType: maker, taker, liquidation, etc.\n  } catch (e) {\n    console.error('Get fills error: ', e);\n  }\n}\n\nasync function getFillsBeforeTime() {\n  try {\n    // Get fills before specific time\n    const fillsBeforeTime = await client.getFills({\n      lastFillTime: new Date(Date.now() - 86400000).toISOString(), // 24h ago\n    });\n    console.log('Fills (24h ago): ', JSON.stringify(fillsBeforeTime, null, 2));\n\n    // Returns 100 fills before specified time\n  } catch (e) {\n    console.error('Get fills before time error: ', e);\n  }\n}\n\nasync function initiateWalletTransfer() {\n  try {\n    // Transfer between margin accounts or to/from cash account\n    const transfer = await client.submitWalletTransfer({\n      fromAccount: 'flex',\n      toAccount: 'fi_xbtusd',\n      unit: 'BTC',\n      amount: 1,\n    });\n    console.log('Transfer Result: ', JSON.stringify(transfer, null, 2));\n\n    // Transfers funds between accounts instantly\n  } catch (e) {\n    console.error('Initiate wallet transfer error: ', e);\n  }\n}\n\nasync function initiateWithdrawalToSpot() {\n  try {\n    // Withdraw from Futures to Spot wallet\n    const withdrawal = await client.submitTransferToSpot({\n      currency: 'USDT',\n      amount: '100',\n      sourceWallet: 'cash', // Default is cash wallet\n    });\n    console.log('Withdrawal Result: ', JSON.stringify(withdrawal, null, 2));\n\n    // Response includes:\n    // - uid: Withdrawal reference ID\n  } catch (e) {\n    console.error('Initiate withdrawal to spot error: ', e);\n  }\n}\n\nasync function getOrderEvents() {\n  try {\n    // Get order history events\n    const orderEvents = await client.getOrderEvents({\n      count: 50,\n      sort: 'desc', // desc = newest first\n      opened: true, // Include opened orders\n      closed: true, // Include closed orders\n    });\n    console.log('Order Events: ', JSON.stringify(orderEvents, null, 2));\n\n    // Response includes:\n    // - elements: Array of order events\n    // - Order placed, cancelled, rejected, executed events\n    // - continuationToken: For pagination\n  } catch (e) {\n    console.error('Get order events error: ', e);\n  }\n}\n\nasync function getOrderEventsBySymbol() {\n  try {\n    // Filter order events by symbol\n    const orderEventsBySymbol = await client.getOrderEvents({\n      tradeable: 'PF_ETHUSD',\n      count: 50,\n    });\n    console.log(\n      'Order Events (PF_ETHUSD): ',\n      JSON.stringify(orderEventsBySymbol, null, 2),\n    );\n  } catch (e) {\n    console.error('Get order events by symbol error: ', e);\n  }\n}\n\nasync function getExecutionEvents() {\n  try {\n    // Get execution/trade history\n    const executions = await client.getExecutionEvents({\n      count: 50,\n      sort: 'desc',\n    });\n    console.log('Execution Events: ', JSON.stringify(executions, null, 2));\n\n    // Response includes for each execution:\n    // - execution: Fill details (price, quantity, timestamp)\n    // - order: Associated order details\n    // - fee: Fee paid\n    // - positionSize: Position size after execution\n  } catch (e) {\n    console.error('Get execution events error: ', e);\n  }\n}\n\nasync function getExecutionEventsBySymbol() {\n  try {\n    // Filter executions by symbol\n    const executionsBySymbol = await client.getExecutionEvents({\n      tradeable: 'PF_ETHUSD',\n      count: 50,\n    });\n    console.log(\n      'Executions (PF_ETHUSD): ',\n      JSON.stringify(executionsBySymbol, null, 2),\n    );\n  } catch (e) {\n    console.error('Get execution events by symbol error: ', e);\n  }\n}\n\nasync function getAccountLog() {\n  try {\n    // Get account log (all account activities)\n    const accountLog = await client.getAccountLog({\n      count: 50,\n      sort: 'desc',\n    });\n    console.log('Account Log: ', JSON.stringify(accountLog, null, 2));\n\n    // Log includes:\n    // - futures trade, liquidation, funding rate change\n    // - conversions, transfers, settlements\n    // - interest payments, fees\n  } catch (e) {\n    console.error('Get account log error: ', e);\n  }\n}\n\nasync function getAccountLogFiltered() {\n  try {\n    // Filter account log by info types\n    const filteredLog = await client.getAccountLog({\n      info: ['futures trade', 'transfer', 'funding rate change'],\n      count: 50,\n    });\n    console.log('Filtered Account Log: ', JSON.stringify(filteredLog, null, 2));\n  } catch (e) {\n    console.error('Get filtered account log error: ', e);\n  }\n}\n\nasync function enableFuturesSubTrading() {\n  try {\n    const enableFuturesSubTrading = await client.updateSubaccountTradingStatus({\n      subaccountUid: '6e5378ff-31ce-44e8-929f-23f822aa5673',\n      tradingEnabled: true,\n    });\n    console.log(\n      'Enable Futures Sub Trading: ',\n      JSON.stringify(enableFuturesSubTrading, null, 2),\n    );\n  } catch (e) {\n    console.error('Enable futures sub trading error: ', e);\n  }\n}\n\nasync function getSubaccountTradingStatus() {\n  try {\n    const subaccountTradingStatus = await client.getSubaccountTradingStatus({\n      subaccountUid: '6e5378ff-31ce-44e8-929f-23f822aa5673',\n    });\n    console.log(\n      'Subaccount Trading Status: ',\n      JSON.stringify(subaccountTradingStatus, null, 2),\n    );\n  } catch (e) {\n    console.error('Get subaccount trading status error: ', e);\n  }\n}\n\nasync function getSubaccounts() {\n  try {\n    const subaccounts = await client.getSubaccounts();\n    console.log('Subaccounts: ', JSON.stringify(subaccounts, null, 2));\n  } catch (e) {\n    console.error('Get subaccounts error: ', e);\n  }\n}\n// Uncomment the function you want to test:\n\n// getWallets();\n// getOpenPositions();\n// getFills();\n// getFillsBeforeTime();\n// initiateWalletTransfer();\n// initiateWithdrawalToSpot();\n// getOrderEvents();\n// getOrderEventsBySymbol();\n// getExecutionEvents();\n// getExecutionEventsBySymbol();\n// getAccountLog();\n// getAccountLogFiltered();\n// enableFuturesSubTrading();\n// getSubaccountTradingStatus();\n// getSubaccounts();\n",
                  "metadata": {}
                },
                {
                  "type": "file",
                  "name": "orderManagement.ts",
                  "path": "examples/Kraken/Derivatives/Private/orderManagement.ts",
                  "code": "/* eslint-disable @typescript-eslint/no-unused-vars */\n\nimport { DerivativesClient } from '@siebly/kraken-api';\n// This example shows how to call Kraken API endpoint with either node.js,\n// javascript (js) or typescript (ts) with the npm module \"@siebly/kraken-api\" for Kraken exchange\n// for ORDER MANAGEMENT\n\n// initialise the client\n/**\n *\n * Kraken Futures API uses API Key and API Secret\n *\n * Example:\n * {\n *   apiKey: 'your-api-key',\n *   apiSecret: 'your-api-secret',\n * }\n */\nconst client = new DerivativesClient({\n  apiKey: process.env.API_FUTURES_KEY || 'insertApiKeyHere',\n  apiSecret: process.env.API_FUTURES_SECRET || 'insertApiSecretHere',\n});\nasync function editOrder() {\n  try {\n    // Edit an existing order\n    const editResult = await client.editOrder({\n      orderId: 'a04d0f84-36d4-4499-8382-96fcfc3ce7aa', // Or use cliOrdId instead\n      limitPrice: 1100, // New limit price\n      // or add some other parameters you want to edit\n    });\n    console.log('Edit Order Result: ', JSON.stringify(editResult, null, 2));\n\n    // Response includes:\n    // - status: edited, invalidSize, invalidPrice, etc.\n    // - orderEvents: Array of order events\n  } catch (e) {\n    console.error('Edit order error: ', e);\n  }\n}\n\nasync function cancelOrder() {\n  try {\n    // Cancel a single order\n    const cancelResult = await client.cancelOrder({\n      order_id: 'a04d0f84-36d4-4499-8382-96fcfc3ce7aa', // Or use cliOrdId\n    });\n    console.log('Cancel Order Result: ', JSON.stringify(cancelResult, null, 2));\n\n    // Response status:\n    // - cancelled: Successfully cancelled\n    // - filled: Order was already filled\n    // - notFound: Order not found\n  } catch (e) {\n    console.error('Cancel order error: ', e);\n  }\n}\n\nasync function cancelAllOrders() {\n  try {\n    // Cancel all open orders\n    const cancelAllResult = await client.cancelAllOrders();\n    console.log(\n      'Cancel All Orders Result: ',\n      JSON.stringify(cancelAllResult, null, 2),\n    );\n\n    // Response includes:\n    // - status: cancelled or noOrdersToCancel\n    // - cancelledOrders: Array of cancelled order IDs\n  } catch (e) {\n    console.error('Cancel all orders error: ', e);\n  }\n}\n\nasync function cancelAllOrdersBySymbol() {\n  try {\n    // Cancel all orders for specific symbol\n    const cancelBySymbol = await client.cancelAllOrders({\n      symbol: 'PF_ETHUSD',\n    });\n    console.log(\n      'Cancel Orders by Symbol Result: ',\n      JSON.stringify(cancelBySymbol, null, 2),\n    );\n  } catch (e) {\n    console.error('Cancel orders by symbol error: ', e);\n  }\n}\n\nasync function batchOrderManagement() {\n  try {\n    // Send, edit, and cancel orders in a single batch request\n    const batchResult = await client.batchOrderManagement({\n      json: {\n        batchOrder: [\n          // Edit existing order\n          {\n            order: 'edit',\n            order_id: 'a04d1143-757a-4dba-a0a7-687303b9c62d',\n            limitPrice: 900,\n          },\n          // Cancel existing order\n          {\n            order: 'cancel',\n            order_id: 'a04d116e-fb9c-4bcf-9eaf-ea90254439b3',\n          },\n        ],\n      },\n    });\n    console.log('Batch Order Result: ', JSON.stringify(batchResult, null, 2));\n\n    // Response includes batchStatus array with results for each order\n    // - status: placed, edited, cancelled, or rejection reason\n    // - order_tag: Maps back to your request\n  } catch (e) {\n    console.error('Batch order management error: ', e);\n  }\n}\n\n// Uncomment the function you want to test:\n\n// editOrder();\n// cancelOrder();\n// cancelAllOrders();\n// cancelAllOrdersBySymbol();\n// batchOrderManagement();\n",
                  "metadata": {}
                },
                {
                  "type": "file",
                  "name": "submitOrder.ts",
                  "path": "examples/Kraken/Derivatives/Private/submitOrder.ts",
                  "code": "import { DerivativesClient } from '@siebly/kraken-api';\n/* eslint-disable @typescript-eslint/no-unused-vars */\n// This example shows how to call Kraken API endpoint with either node.js,\n// javascript (js) or typescript (ts) with the npm module \"@siebly/kraken-api\" for Kraken exchange\n// for FUTURES ORDER MANAGEMENT\n\n// initialise the client\n/**\n *\n * Kraken Futures API uses API Key and API Secret\n *\n * Example:\n * {\n *   apiKey: 'your-api-key',\n *   apiSecret: 'your-api-secret',\n * }\n *\n * API Key Permissions Required: Orders and trades - Create & modify orders\n *\n */\nconst client = new DerivativesClient({\n  apiKey: process.env.API_FUTURES_KEY || 'insertApiKeyHere',\n  apiSecret: process.env.API_FUTURES_SECRET || 'insertApiSecretHere',\n});\n\nasync function submitLimitOrder() {\n  try {\n    // Submit limit order for Futures\n    const limitOrder = await client.submitOrder({\n      orderType: 'lmt',\n      symbol: 'PF_ETHUSD', // Perpetual ETH/USD\n      side: 'buy',\n      size: 0.01, // Contract size\n      limitPrice: 1000,\n      cliOrdId: client.generateNewOrderID(),\n    });\n    console.log('Limit Order Result: ', JSON.stringify(limitOrder, null, 2));\n\n    // Response includes:\n    // - status: placed, partiallyFilled, filled, or rejection reason\n    // - order_id: Unique order identifier\n    // - orderEvents: Array of order events (PLACE, EXECUTE, etc.)\n  } catch (e) {\n    console.error('Submit limit order error: ', e);\n  }\n}\n\nasync function submitMarketOrder() {\n  try {\n    // Submit market order (IOC with 1% price protection)\n    const marketOrder = await client.submitOrder({\n      orderType: 'mkt',\n      symbol: 'PF_ETHUSD',\n      side: 'sell', // or \"buy\"\n      size: 0.01,\n    });\n    console.log('Market Order Result: ', JSON.stringify(marketOrder, null, 2));\n  } catch (e) {\n    console.error('Submit market order error: ', e);\n  }\n}\n\nasync function submitPostOnlyOrder() {\n  try {\n    // Submit post-only order (maker-only)\n    const postOrder = await client.submitOrder({\n      orderType: 'post',\n      symbol: 'PF_ETHUSD',\n      side: 'buy',\n      size: 0.01,\n      limitPrice: 1000,\n      cliOrdId: client.generateNewOrderID(),\n    });\n    console.log('Post-Only Order Result: ', JSON.stringify(postOrder, null, 2));\n  } catch (e) {\n    console.error('Submit post-only order error: ', e);\n  }\n}\n\nasync function submitReduceOnlyOrder() {\n  try {\n    // Submit reduce-only order (only closes position, won't open new)\n    const reduceOnlyOrder = await client.submitOrder({\n      orderType: 'lmt',\n      symbol: 'PF_ETHUSD',\n      side: 'sell',\n      size: 1,\n      limitPrice: 1000,\n      reduceOnly: true, // Only reduce existing position\n    });\n    console.log(\n      'Reduce-Only Order Result: ',\n      JSON.stringify(reduceOnlyOrder, null, 2),\n    );\n  } catch (e) {\n    console.error('Submit reduce-only order error: ', e);\n  }\n}\n\nasync function batchOrderSubmit() {\n  try {\n    // Send, edit, and cancel orders in a single batch request\n    const batchResult = await client.batchOrderManagement({\n      json: {\n        batchOrder: [\n          // Send new order\n          {\n            order: 'send',\n            order_tag: 'order-1', // Tag to map responses\n            orderType: 'lmt',\n            symbol: 'PF_ETHUSD',\n            side: 'buy',\n            size: 0.01,\n            limitPrice: 1000,\n            cliOrdId: client.generateNewOrderID(),\n          },\n          // Send another order\n          {\n            order: 'send',\n            order_tag: 'order-2',\n            orderType: 'lmt',\n            symbol: 'PF_ETHUSD',\n            side: 'buy',\n            size: 0.01,\n            limitPrice: 1100,\n          },\n        ],\n      },\n    });\n    console.log('Batch Order Result: ', JSON.stringify(batchResult, null, 2));\n\n    // Response includes batchStatus array with results for each order\n    // - status: placed, edited, cancelled, or rejection reason\n    // - order_tag: Maps back to your request\n  } catch (e) {\n    console.error('Batch order management error: ', e);\n  }\n}\n\n// Uncomment the function you want to test:\n\n// submitLimitOrder();\n// submitMarketOrder();\n// submitPostOnlyOrder();\n// submitReduceOnlyOrder();\n//batchOrderSubmit();\n",
                  "metadata": {}
                },
                {
                  "type": "file",
                  "name": "testnet.ts",
                  "path": "examples/Kraken/Derivatives/Private/testnet.ts",
                  "code": "import { DerivativesClient } from '@siebly/kraken-api';\n/* eslint-disable @typescript-eslint/no-unused-vars */\n// This example shows how to call Kraken API testnet (demo) endpoints with either node.js,\n// javascript (js) or typescript (ts) with the npm module \"@siebly/kraken-api\" for Kraken exchange\n\n/**\n * Kraken Derivatives has a demo environment (testnet) that you can connect to via WebSocket. All you need to do is set the `testnet` option to `true` when creating the WebsocketClient instance, as shown below.\n * Everything else behaves exactly the same way.\n *\n * Note: as of November 2025, only the DerivativesClient supports testnet connections. Kraken refer to this as the \"Demo\" environment, but it is effectively a testnet.\n * This is a place to test your API integration. It is not a good place to test strategy performance, as the liquidity and orderbook dynamics are very different to the live environment.\n *\n * Refer to the following for more information:\n * https://github.com/tiagosiebler/awesome-crypto-examples/wiki/CEX-Testnets\n */\nconst client = new DerivativesClient({\n  // https://demo-futures.kraken.com to create demo account\n  apiKey: 'testnetKeyHere',\n  apiSecret: 'testnetSecretHere',\n  testnet: true,\n});\n\nasync function getWallets() {\n  try {\n    // Get all wallets (cash and margin accounts)\n    const wallets = await client.getAccounts();\n    console.log('Wallets: ', JSON.stringify(wallets, null, 2));\n\n    // Response includes:\n    // - cash: Cash account with balances\n    // - flex: Multi-collateral wallet with margin info\n    // - Available margin, portfolio value, PnL\n    // - Initial/maintenance margin requirements\n    // For each margin account:\n    //   - balances, auxiliary (pv, pnl, af, funding)\n    //   - marginRequirements (im, mm, lt, tt)\n    //   - triggerEstimates\n  } catch (e) {\n    console.error('Get wallets error: ', e);\n  }\n}\n\nasync function getOpenPositions() {\n  try {\n    // Get all open Futures positions\n    const openPositions = await client.getOpenPositions();\n    console.log('Open Positions: ', JSON.stringify(openPositions, null, 2));\n\n    // Response includes for each position:\n    // - symbol: Futures symbol\n    // - side: long or short\n    // - size: Position size\n    // - price: Average entry price\n    // - fillTime: When position was opened\n    // - unrealizedFunding: Unrealized funding\n  } catch (e) {\n    console.error('Get open positions error: ', e);\n  }\n}\n\nasync function getFills() {\n  try {\n    // Get filled orders history (last 100)\n    const fills = await client.getFills();\n    console.log('Fills: ', JSON.stringify(fills, null, 2));\n\n    // Response includes for each fill:\n    // - fill_id: Unique fill identifier\n    // - order_id: Associated order ID\n    // - symbol: Futures symbol\n    // - side: buy or sell\n    // - size: Fill size\n    // - price: Fill price\n    // - fillTime: Execution time\n    // - fillType: maker, taker, liquidation, etc.\n  } catch (e) {\n    console.error('Get fills error: ', e);\n  }\n}\n\nasync function getFillsBeforeTime() {\n  try {\n    // Get fills before specific time\n    const fillsBeforeTime = await client.getFills({\n      lastFillTime: new Date(Date.now() - 86400000).toISOString(), // 24h ago\n    });\n    console.log('Fills (24h ago): ', JSON.stringify(fillsBeforeTime, null, 2));\n\n    // Returns 100 fills before specified time\n  } catch (e) {\n    console.error('Get fills before time error: ', e);\n  }\n}\n\nasync function initiateWalletTransfer() {\n  try {\n    // Transfer between margin accounts or to/from cash account\n    const transfer = await client.submitWalletTransfer({\n      fromAccount: 'cash', // or margin account name\n      toAccount: 'flex', // or other margin account\n      unit: 'EUR',\n      amount: 10000,\n    });\n    console.log('Transfer Result: ', JSON.stringify(transfer, null, 2));\n\n    // Transfers funds between accounts instantly\n  } catch (e) {\n    console.error('Initiate wallet transfer error: ', e);\n  }\n}\n\nasync function initiateWithdrawalToSpot() {\n  try {\n    // Withdraw from Futures to Spot wallet\n    const withdrawal = await client.submitTransferToSpot({\n      currency: 'USDT',\n      amount: '100',\n      sourceWallet: 'cash', // Default is cash wallet\n    });\n    console.log('Withdrawal Result: ', JSON.stringify(withdrawal, null, 2));\n\n    // Response includes:\n    // - uid: Withdrawal reference ID\n  } catch (e) {\n    console.error('Initiate withdrawal to spot error: ', e);\n  }\n}\n\nasync function getOrderEvents() {\n  try {\n    // Get order history events\n    const orderEvents = await client.getOrderEvents({\n      count: 50,\n      sort: 'desc', // desc = newest first\n      opened: true, // Include opened orders\n      closed: true, // Include closed orders\n    });\n    console.log('Order Events: ', JSON.stringify(orderEvents, null, 2));\n\n    // Response includes:\n    // - elements: Array of order events\n    // - Order placed, cancelled, rejected, executed events\n    // - continuationToken: For pagination\n  } catch (e) {\n    console.error('Get order events error: ', e);\n  }\n}\n\nasync function getOrderEventsBySymbol() {\n  try {\n    // Filter order events by symbol\n    const orderEventsBySymbol = await client.getOrderEvents({\n      tradeable: 'PF_ETHUSD',\n      count: 50,\n    });\n    console.log(\n      'Order Events (PF_ETHUSD): ',\n      JSON.stringify(orderEventsBySymbol, null, 2),\n    );\n  } catch (e) {\n    console.error('Get order events by symbol error: ', e);\n  }\n}\n\nasync function getExecutionEvents() {\n  try {\n    // Get execution/trade history\n    const executions = await client.getExecutionEvents({\n      count: 50,\n      sort: 'desc',\n    });\n    console.log('Execution Events: ', JSON.stringify(executions, null, 2));\n\n    // Response includes for each execution:\n    // - execution: Fill details (price, quantity, timestamp)\n    // - order: Associated order details\n    // - fee: Fee paid\n    // - positionSize: Position size after execution\n  } catch (e) {\n    console.error('Get execution events error: ', JSON.stringify(e, null, 2));\n  }\n}\n\nasync function getExecutionEventsBySymbol() {\n  try {\n    // Filter executions by symbol\n    const executionsBySymbol = await client.getExecutionEvents({\n      tradeable: 'PF_ETHUSD',\n      count: 50,\n    });\n    console.log(\n      'Executions (PF_ETHUSD): ',\n      JSON.stringify(executionsBySymbol, null, 2),\n    );\n  } catch (e) {\n    console.error(\n      'Get execution events by symbol error: ',\n      JSON.stringify(e, null, 2),\n    );\n  }\n}\n\nasync function getAccountLog() {\n  try {\n    // Get account log (all account activities)\n    const accountLog = await client.getAccountLog({\n      count: 50,\n      sort: 'desc',\n    });\n    console.log('Account Log: ', JSON.stringify(accountLog, null, 2));\n\n    // Log includes:\n    // - futures trade, liquidation, funding rate change\n    // - conversions, transfers, settlements\n    // - interest payments, fees\n  } catch (e) {\n    console.error('Get account log error: ', e);\n  }\n}\n\nasync function getAccountLogFiltered() {\n  try {\n    // Filter account log by info types\n    const filteredLog = await client.getAccountLog({\n      info: ['futures trade', 'transfer', 'funding rate change'],\n      count: 50,\n    });\n    console.log('Filtered Account Log: ', JSON.stringify(filteredLog, null, 2));\n  } catch (e) {\n    console.error('Get filtered account log error: ', e);\n  }\n}\n\n// Uncomment the function you want to test:\n\ngetWallets();\ngetOpenPositions();\ngetFills();\ngetFillsBeforeTime();\n// initiateWalletTransfer();\n// initiateWithdrawalToSpot();\ngetOrderEvents();\ngetOrderEventsBySymbol();\ngetExecutionEvents();\ngetExecutionEventsBySymbol();\ngetAccountLog();\ngetAccountLogFiltered();\n",
                  "metadata": {}
                }
              ]
            },
            {
              "type": "folder",
              "name": "Public",
              "path": "examples/Kraken/Derivatives/Public",
              "children": [
                {
                  "type": "file",
                  "name": "marketData.ts",
                  "path": "examples/Kraken/Derivatives/Public/marketData.ts",
                  "code": "import { DerivativesClient } from '@siebly/kraken-api';\n\n// This example shows how to call Kraken API endpoint with either node.js,\n// javascript (js) or typescript (ts) with the npm module \"@siebly/kraken-api\" for Kraken exchange\n// for FUTURES PUBLIC MARKET DATA that requires no authentication\n\n/* eslint-disable @typescript-eslint/no-unused-vars */\n\n// you can initialise public client without api keys as public calls do not require auth\nconst client = new DerivativesClient();\n\nasync function getAllTickers() {\n  try {\n    // Get all tickers (all Futures contracts and indices)\n    const allTickers = await client.getTickers();\n    console.log('All Tickers: ', JSON.stringify(allTickers, null, 2));\n\n    // Response includes for each ticker:\n    // - symbol: Market symbol (e.g., PF_BTCUSD)\n    // - last: Last fill price\n    // - markPrice: Current mark price for margining\n    // - bid/ask: Best bid/ask prices\n    // - vol24h: 24h volume\n    // - openInterest: Current open interest\n    // - fundingRate: Current funding rate (perpetuals only)\n  } catch (e) {\n    console.error('Get all tickers error: ', e);\n  }\n}\n\nasync function getTickerBySymbol() {\n  try {\n    // Get ticker for specific Futures symbol\n    const ticker = await client.getTicker({\n      symbol: 'PF_ETHUSD', // Perpetual BTC/USD\n    });\n    console.log('Ticker: ', JSON.stringify(ticker, null, 2));\n  } catch (e) {\n    console.error('Get ticker by symbol error: ', e);\n  }\n}\n\nasync function getOrderBook() {\n  try {\n    // Get order book for specific Futures contract\n    const orderBook = await client.getOrderbook({\n      symbol: 'PF_ETHUSD',\n    });\n    console.log('Order Book: ', JSON.stringify(orderBook, null, 2));\n\n    // Response includes:\n    // - bids: Array of [price, size] sorted descending by price\n    // - asks: Array of [price, size] sorted ascending by price\n  } catch (e) {\n    console.error('Get order book error: ', e);\n  }\n}\n\nasync function getTradeHistory() {\n  try {\n    // Get recent trade history (last 100 trades)\n    const tradeHistory = await client.getPublicExecutionEvents({\n      tradeable: 'PF_ETHUSD',\n    });\n    console.log('Trade History: ', JSON.stringify(tradeHistory, null, 2));\n\n    // Response includes:\n    // - price: Fill price\n    // - side: Taker side (buy/sell)\n    // - size: Fill size\n    // - time: Trade timestamp\n    // - type: Trade type (fill, liquidation, assignment, etc.)\n  } catch (e) {\n    console.error('Get trade history error: ', e);\n  }\n}\n\nasync function getTradeHistoryWithTime() {\n  try {\n    // Get trades before specific time (last 100 trades before specified time)\n    const tradeHistoryTime = await client.getPublicExecutionEvents({\n      tradeable: 'PF_ETHUSD',\n      before: Date.now() - 3600000, // 1 hour ago\n    });\n    console.log(\n      'Trade History (1h ago): ',\n      JSON.stringify(tradeHistoryTime, null, 2),\n    );\n\n    // Returns up to 100 trades prior to before time (max 7 days back)\n  } catch (e) {\n    console.error('Get trade history with time error: ', e);\n  }\n}\n\nasync function getInstruments() {\n  try {\n    // Get all available Futures instruments\n    const instruments = await client.getInstruments();\n    console.log('Instruments: ', JSON.stringify(instruments, null, 2));\n\n    // Response includes for each instrument:\n    // - symbol: Market symbol\n    // - type: Instrument type (flexible_futures, futures_inverse, etc.)\n    // - underlying: Underlying asset\n    // - tickSize: Minimum price increment\n    // - contractSize: Contract size\n    // - tradeable: Whether instrument is tradeable\n  } catch (e) {\n    console.error('Get instruments error: ', e);\n  }\n}\n\nasync function getFeeSchedules() {\n  try {\n    // Get fee schedules for Futures trading\n    const feeSchedules = await client.getFeeSchedules();\n    console.log('Fee Schedules: ', JSON.stringify(feeSchedules, null, 2));\n\n    // Response includes maker and taker fees by tier\n  } catch (e) {\n    console.error('Get fee schedules error: ', e);\n  }\n}\n\nasync function getPublicExecutionEvents() {\n  try {\n    const publicExecutionEvents = await client.getPublicExecutionEvents({\n      tradeable: 'PF_ETHUSD',\n    });\n    console.log(\n      'Public Execution Events: ',\n      JSON.stringify(publicExecutionEvents, null, 2),\n    );\n  } catch (e) {\n    console.error('Get public execution events error: ', e);\n  }\n}\n\nasync function getPublicOrderEvents() {\n  try {\n    const publicOrderEvents = await client.getPublicOrderEvents({\n      tradeable: 'PF_ETHUSD',\n    });\n    console.log(\n      'Public Order Events: ',\n      JSON.stringify(publicOrderEvents, null, 2),\n    );\n  } catch (e) {\n    console.error('Get public order events error: ', e);\n  }\n}\n\nasync function getPublicMarkPriceEvents() {\n  try {\n    const publicMarkPriceEvents = await client.getPublicMarkPriceEvents({\n      tradeable: 'PF_ETHUSD',\n    });\n    console.log(\n      'Public Mark Price Events: ',\n      JSON.stringify(publicMarkPriceEvents, null, 2),\n    );\n  } catch (e) {\n    console.error('Get public mark price events error: ', e);\n  }\n}\n\nasync function getCandles() {\n  try {\n    // Get OHLC candles for Futures\n    const candles = await client.getCandles({\n      tickType: 'trade', // spot, mark, or trade\n      symbol: 'PF_ETHUSD',\n      resolution: '1h', // 1m, 5m, 15m, 30m, 1h, 4h, 12h, 1d, 1w\n    });\n    console.log('Candles: ', JSON.stringify(candles, null, 2));\n\n    // Response includes:\n    // - candles: Array of OHLC candles\n    //   - time: Timestamp in ms\n    //   - open, high, low, close: Prices\n    //   - volume: Volume\n    // - more_candles: True if more candles available\n  } catch (e) {\n    console.error('Get candles error: ', e);\n  }\n}\n\nasync function getCandlesWithTimeRange() {\n  try {\n    // Get candles for specific time range\n    const candlesTimeRange = await client.getCandles({\n      tickType: 'trade',\n      symbol: 'PF_ETHUSD',\n      resolution: '1h',\n      from: Math.floor((Date.now() - 86400000 * 7) / 1000), // 7 days ago (epoch seconds)\n      to: Math.floor(Date.now() / 1000), // now (epoch seconds)\n    });\n    console.log(\n      'Candles (7 days): ',\n      JSON.stringify(candlesTimeRange, null, 2),\n    );\n  } catch (e) {\n    console.error('Get candles with time range error: ', e);\n  }\n}\n\nasync function getCandlesWithCount() {\n  try {\n    // Get specific number of most recent candles\n    const candlesCount = await client.getCandles({\n      tickType: 'mark', // Use mark price candles\n      symbol: 'PF_ETHUSD',\n      resolution: '5m',\n    });\n    console.log('Candles (last 100): ', JSON.stringify(candlesCount, null, 2));\n\n    // Tick types:\n    // - trade: Trade price candles\n    // - mark: Mark price candles\n    // - spot: Spot price candles\n  } catch (e) {\n    console.error('Get candles with count error: ', e);\n  }\n}\n\n// Uncomment the function you want to test:\n\n// getAllTickers();\n// getTickerBySymbol();\n// getOrderBook();\n// getTradeHistory();\n// getTradeHistoryWithTime();\n// getInstruments();\n// getFeeSchedules();\n// getPublicExecutionEvents();\n// getPublicOrderEvents();\n// getPublicMarkPriceEvents();\n// getCandles();\n// getCandlesWithTimeRange();\n// getCandlesWithCount();\n",
                  "metadata": {}
                }
              ]
            },
            {
              "type": "folder",
              "name": "WebSockets",
              "path": "examples/Kraken/Derivatives/WebSockets",
              "children": [
                {
                  "type": "file",
                  "name": "privateWs.ts",
                  "path": "examples/Kraken/Derivatives/WebSockets/privateWs.ts",
                  "code": "// eslint-disable-next-line @typescript-eslint/no-unused-vars\nimport {\n  DefaultLogger,\n  LogParams,\n  WebsocketClient,\n  WS_KEY_MAP,\n  WSDerivativesTopic,\n  WSTopicRequest,\n} from '@siebly/kraken-api';\n\nconst customLogger: DefaultLogger = {\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  trace: (...params: LogParams): void => {\n    // console.log(new Date(), '--> trace', ...params);\n  },\n  info: (...params: LogParams): void => {\n    console.log(new Date(), '--> info', ...params);\n  },\n  error: (...params: LogParams): void => {\n    console.error(new Date(), '--> error', ...params);\n  },\n};\n\nasync function start() {\n  const account = {\n    key: process.env.API_FUTURES_KEY || 'keyHere',\n    secret: process.env.API_FUTURES_SECRET || 'secretHere',\n  };\n\n  /**\n   * The WebsocketClient is the core class to manage WebSocket subscriptions. Give it the topics you want to subscribe to, and it will handle the rest:\n   * - Connection management (connect, disconnect, reconnect)\n   * - Authentication for private topics\n   * - Subscription management (subscribe, unsubscribe, resubscribe on reconnect)\n   * - Message handling (dispatch messages to appropriate handlers)\n   *\n   * All you need to do is provide the topics you want to subscribe to when calling `subscribe()`, and the client will take care of the rest.\n   *\n   * Here we create a WebsocketClient instance with API key/secret for private topic subscriptions.\n   *\n   * In terms of product groups such as Spot, Derivatives, etc., the WebsocketClient understand the product group from the WsKey you provide when subscribing. For example, using `WS_KEY_MAP.spotPrivateV2` indicates that the subscription is for Spot private topics, as shown below.\n   *\n   * Refer to WS_KEY_MAP in the source code for all available WsKey options.\n   */\n  const client = new WebsocketClient(\n    {\n      apiKey: account.key,\n      apiSecret: account.secret,\n    },\n    customLogger,\n  );\n\n  client.on('open', (data) => {\n    console.log(new Date(), 'connected ', data?.wsKey);\n  });\n\n  // Data received\n  client.on('message', (data) => {\n    console.info(new Date(), 'data received: ', JSON.stringify(data));\n  });\n\n  // Something happened, attempting to reconnect\n  client.on('reconnecting', (data) => {\n    console.log(new Date(), 'reconnect: ', data?.wsKey);\n  });\n\n  // Reconnect successful\n  client.on('reconnected', (data) => {\n    console.log(new Date(), 'reconnected: ', data?.wsKey);\n  });\n\n  // Connection closed. If unexpected, expect reconnect -> reconnected.\n  client.on('close', (data) => {\n    console.error(new Date(), 'close: ', data);\n  });\n\n  // Reply to a request, e.g. \"subscribe\"/\"unsubscribe\"/\"authenticate\"\n  client.on('response', (data) => {\n    console.info(new Date(), 'server reply: ', JSON.stringify(data), '\\n');\n  });\n\n  client.on('exception', (data) => {\n    console.error(new Date(), 'exception: ', data);\n  });\n\n  client.on('authenticated', (data) => {\n    console.error(new Date(), 'authenticated: ', data);\n  });\n\n  /**\n   * The below examples demonstrate how you can subscribe to private topics.\n   *\n   * Note: while the documentation specifies \"api_key\", \"original_challenge\" and \"signed_challenge\" as required parameters, but don't worry about that. The SDK will automatically:\n   * - Fetch the challenge using your API key,\n   * - Cache the challenge\n   * - Include the key, original challenge and signed challenge parameters for you when subscribing to private topics on the derivativesPrivateV1 WebSocket connection.\n   *\n   * You do NOT need to manually fetch or provide the \"original_challenge\" and \"signed_challenge\" tokens when subscribing to private topics.\n   *\n   * Do note that all of these include the \"derivativesPrivateV1\" WsKey reference. This tells the WebsocketClient to use the private \"wss://futures.kraken.com/ws/v1\" endpoint for these private subscription requests. It will also automatically authenticate the connection when it is established.\n   */\n\n  try {\n    /**\n     * All of the following parameters require API keys for Derivatives APIs.\n     *\n     * Note: your \"WsTopicRequest\" does not need to include \"api_key\", \"original_challenge\" and \"signed_challenge\". See above for details, or below for examples.\n     */\n\n    // Open orders: https://docs.kraken.com/api/docs/futures-api/websocket/open_orders\n    const openOrdersTopicRequest: WSTopicRequest<WSDerivativesTopic> = {\n      topic: 'open_orders',\n    };\n    client.subscribe(openOrdersTopicRequest, WS_KEY_MAP.derivativesPrivateV1);\n\n    // Note: if there are no parameters needed, you can also just request the topic by name\n    // This is the same as openOrdersTopicRequest, since openOrdersTopicRequest contains no parameters\n    // client.subscribe('open_orders', WS_KEY_MAP.derivativesPrivateV1);\n\n    // Open orders (verbose): https://docs.kraken.com/api/docs/futures-api/websocket/open_orders\n    client.subscribe('open_orders_verbose', WS_KEY_MAP.derivativesPrivateV1);\n\n    // Fills: https://docs.kraken.com/api/docs/futures-api/websocket/fills\n    const accountFillsTopicRequest: WSTopicRequest<WSDerivativesTopic> = {\n      topic: 'fills',\n      // Optionally, the product_ids field can be used to subscribe only to specific product.\n      // payload: {\n      //   product_ids: ['PF_XBTUSD'],\n      // },\n    };\n    client.subscribe(accountFillsTopicRequest, WS_KEY_MAP.derivativesPrivateV1);\n\n    // Balances: https://docs.kraken.com/api/docs/futures-api/websocket/balances\n    client.subscribe('balances', WS_KEY_MAP.derivativesPrivateV1);\n\n    // Open Position: https://docs.kraken.com/api/docs/futures-api/websocket/open_position\n    client.subscribe('open_positions', WS_KEY_MAP.derivativesPrivateV1);\n\n    // Account Log: https://docs.kraken.com/api/docs/futures-api/websocket/account_log\n    client.subscribe('account_log', WS_KEY_MAP.derivativesPrivateV1);\n\n    // Notification: https://docs.kraken.com/api/docs/futures-api/websocket/notifications\n    client.subscribe('notifications_auth', WS_KEY_MAP.derivativesPrivateV1);\n  } catch (e) {\n    console.error('Req error: ', e);\n  }\n}\n\nstart();\n",
                  "metadata": {}
                },
                {
                  "type": "file",
                  "name": "publicWs.ts",
                  "path": "examples/Kraken/Derivatives/WebSockets/publicWs.ts",
                  "code": "/* eslint-disable @typescript-eslint/no-unused-vars */\nimport {\n  DefaultLogger,\n  LogParams,\n  WebsocketClient,\n  WS_KEY_MAP,\n  WSDerivativesTopic,\n  WSTopicRequest,\n} from '@siebly/kraken-api';\n\nconst customLogger: DefaultLogger = {\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  trace: (...params: LogParams): void => {\n    // console.log(new Date(), '--> trace', ...params);\n  },\n  info: (...params: LogParams): void => {\n    console.log(new Date(), '--> info', ...params);\n  },\n  error: (...params: LogParams): void => {\n    console.error(new Date(), '--> error', ...params);\n  },\n};\n\nasync function start() {\n  /**\n   * The WebsocketClient is the core class to manage WebSocket subscriptions. Give it the topics you want to subscribe to, and it will handle the rest:\n   * - Connection management (connect, disconnect, reconnect)\n   * - Authentication for private topics\n   * - Subscription management (subscribe, unsubscribe, resubscribe on reconnect)\n   * - Message handling (dispatch messages to appropriate handlers)\n   *\n   * All you need to do is provide the topics you want to subscribe to when calling `subscribe()`, and the client will take care of the rest.\n   *\n   * Here we create a WebsocketClient instance without API key/secret, since we're only connecting to public topics.\n   *\n   * In terms of product groups such as Spot, Derivatives, etc., the WebsocketClient understand the product group from the WsKey you provide when subscribing. For example, using `WS_KEY_MAP.spotPrivateV2` indicates that the subscription is for Spot private topics, as shown below.\n   *\n   * Refer to WS_KEY_MAP in the source code for all available WsKey options.\n   */\n  const client = new WebsocketClient(\n    {\n      // apiKey: key,\n      // apiSecret: secret,\n    },\n    customLogger,\n  );\n\n  client.on('open', (data) => {\n    console.log(new Date(), 'connected ', data?.wsKey);\n  });\n\n  // Data received\n  client.on('message', (data) => {\n    console.info(new Date(), 'data received: ', JSON.stringify(data));\n  });\n\n  // Something happened, attempting to reconnect\n  client.on('reconnecting', (data) => {\n    console.log(new Date(), 'reconnect: ', data?.wsKey);\n  });\n\n  // Reconnect successful\n  client.on('reconnected', (data) => {\n    console.log(new Date(), 'reconnected: ', data?.wsKey);\n  });\n\n  // Connection closed. If unexpected, expect reconnect -> reconnected.\n  client.on('close', (data) => {\n    console.error(new Date(), 'close: ', data);\n  });\n\n  // Reply to a request, e.g. \"subscribe\"/\"unsubscribe\"/\"authenticate\"\n  client.on('response', (data) => {\n    console.info(new Date(), 'server reply: ', JSON.stringify(data), '\\n');\n  });\n\n  client.on('exception', (data) => {\n    console.error(new Date(), 'exception: ', data);\n  });\n\n  client.on('authenticated', (data) => {\n    console.error(new Date(), 'authenticated: ', data);\n  });\n\n  /**\n   * The below examples demonstrate how you can subscribe to public topics.\n   *\n   * Do note that all of these include the \"derivativesPublicV1\" WsKey reference. This tells the WebsocketClient to use the private \"wss://futures.kraken.com/ws/v1\" endpoint for these private subscription requests. It will also automatically authenticate the connection when it is established.\n   */\n\n  try {\n    // Ticker: https://docs.kraken.com/api/docs/futures-api/websocket/ticker\n    const publicTickerTopicRequest: WSTopicRequest<WSDerivativesTopic> = {\n      topic: 'ticker',\n      payload: {\n        product_ids: ['PI_XBTUSD', 'PI_ETHUSD'],\n      },\n    };\n    // client.subscribe(publicTickerTopicRequest, WS_KEY_MAP.derivativesPublicV1);\n\n    // Ticker Lite: https://docs.kraken.com/api/docs/futures-api/websocket/ticker\n    const publicTickerLiteTopicRequest: WSTopicRequest<WSDerivativesTopic> = {\n      topic: 'ticker_lite',\n      payload: {\n        product_ids: ['PI_XBTUSD', 'PI_ETHUSD'],\n      },\n    };\n    // client.subscribe(\n    //   publicTickerLiteTopicRequest,\n    //   WS_KEY_MAP.derivativesPublicV1,\n    // );\n\n    // Book: https://docs.kraken.com/api/docs/futures-api/websocket/ticker\n    const publicBookTopicRequest: WSTopicRequest<WSDerivativesTopic> = {\n      topic: 'book',\n      payload: {\n        product_ids: ['PI_XBTUSD', 'PI_ETHUSD'],\n      },\n    };\n    // client.subscribe(publicBookTopicRequest, WS_KEY_MAP.derivativesPublicV1);\n\n    // Trade: https://docs.kraken.com/api/docs/futures-api/websocket/ticker\n    const publicTradeTopicRequest: WSTopicRequest<WSDerivativesTopic> = {\n      topic: 'trade',\n      payload: {\n        product_ids: ['PI_XBTUSD', 'PI_ETHUSD'],\n      },\n    };\n    client.subscribe(publicTradeTopicRequest, WS_KEY_MAP.derivativesPublicV1);\n  } catch (e) {\n    console.error('Req error: ', e);\n  }\n}\n\nstart();\n",
                  "metadata": {}
                },
                {
                  "type": "file",
                  "name": "testnetWs.ts",
                  "path": "examples/Kraken/Derivatives/WebSockets/testnetWs.ts",
                  "code": "// eslint-disable-next-line @typescript-eslint/no-unused-vars\nimport {\n  DefaultLogger,\n  LogParams,\n  WebsocketClient,\n  WS_KEY_MAP,\n  WSDerivativesTopic,\n  WSTopicRequest,\n} from '@siebly/kraken-api';\n\nconst customLogger: DefaultLogger = {\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  trace: (...params: LogParams): void => {\n    // console.log(new Date(), '--> trace', ...params);\n  },\n  info: (...params: LogParams): void => {\n    console.log(new Date(), '--> info', ...params);\n  },\n  error: (...params: LogParams): void => {\n    console.error(new Date(), '--> error', ...params);\n  },\n};\n\nasync function start() {\n  // https://demo-futures.kraken.com to create demo account\n  const account = {\n    key: '1mVo6NgddD3os5nnGTPcEcHIncSplLED3Grz1Fnb6l/Vy0iu2TGftQ0Z',\n    secret:\n      'sCcoKlwBYojnXKTCc+sdkbvwwAieaSfU0VvDlfh2xDV3eR1ZlfpAf7p6Xt/pGL6z+m0KuHqGwQmJnnrlG4ZgNuWd',\n  };\n\n  /**\n   * Kraken Derivatives has a demo environment (testnet) that you can connect to via WebSocket. All you need to do is set the `testnet` option to `true` when creating the WebsocketClient instance, as shown below.\n   * Everything else behaves exactly the same way.\n   *\n   * Note: as of November 2025, only the DerivativesClient supports testnet connections. Kraken refer to this as the \"Demo\" environment, but it is effectively a testnet.\n   * This is a place to test your API integration. It is not a good place to test strategy performance, as the liquidity and orderbook dynamics are very different to the live environment.\n   *\n   * Refer to the following for more information:\n   * https://github.com/tiagosiebler/awesome-crypto-examples/wiki/CEX-Testnets\n   */\n  const client = new WebsocketClient(\n    {\n      apiKey: account.key,\n      apiSecret: account.secret,\n      testnet: true,\n    },\n    customLogger,\n  );\n\n  client.on('open', (data) => {\n    console.log(new Date(), 'connected ', data?.wsKey);\n  });\n\n  // Data received\n  client.on('message', (data) => {\n    console.info(new Date(), 'data received: ', JSON.stringify(data));\n  });\n\n  // Something happened, attempting to reconnect\n  client.on('reconnecting', (data) => {\n    console.log(new Date(), 'reconnect: ', data?.wsKey);\n  });\n\n  // Reconnect successful\n  client.on('reconnected', (data) => {\n    console.log(new Date(), 'reconnected: ', data?.wsKey);\n  });\n\n  // Connection closed. If unexpected, expect reconnect -> reconnected.\n  client.on('close', (data) => {\n    console.error(new Date(), 'close: ', data);\n  });\n\n  // Reply to a request, e.g. \"subscribe\"/\"unsubscribe\"/\"authenticate\"\n  client.on('response', (data) => {\n    console.info(new Date(), 'server reply: ', JSON.stringify(data), '\\n');\n  });\n\n  client.on('exception', (data) => {\n    console.error(new Date(), 'exception: ', data);\n  });\n\n  client.on('authenticated', (data) => {\n    console.error(new Date(), 'authenticated: ', data);\n  });\n\n  /**\n   * The below examples demonstrate how you can subscribe to private topics.\n   *\n   * Note: while the documentation specifies \"api_key\", \"original_challenge\" and \"signed_challenge\" as required parameters, but don't worry about that. The SDK will automatically:\n   * - Fetch the challenge using your API key,\n   * - Cache the challenge\n   * - Include the key, original challenge and signed challenge parameters for you when subscribing to private topics on the derivativesPrivateV1 WebSocket connection.\n   *\n   * You do NOT need to manually fetch or provide the \"original_challenge\" and \"signed_challenge\" tokens when subscribing to private topics.\n   *\n   * Do note that all of these include the \"derivativesPrivateV1\" WsKey reference. This tells the WebsocketClient to use the private \"wss://futures.kraken.com/ws/v1\" endpoint for these private subscription requests. It will also automatically authenticate the connection when it is established.\n   */\n\n  try {\n    /**\n     * All of the following parameters require API keys for Derivatives APIs.\n     *\n     * Note: your \"WsTopicRequest\" does not need to include \"api_key\", \"original_challenge\" and \"signed_challenge\". See above for details, or below for examples.\n     */\n\n    // Open orders: https://docs.kraken.com/api/docs/futures-api/websocket/open_orders\n    const openOrdersTopicRequest: WSTopicRequest<WSDerivativesTopic> = {\n      topic: 'open_orders',\n    };\n    client.subscribe(openOrdersTopicRequest, WS_KEY_MAP.derivativesPrivateV1);\n\n    // Note: if there are no parameters needed, you can also just request the topic by name\n    // This is the same as openOrdersTopicRequest, since openOrdersTopicRequest contains no parameters\n    // client.subscribe('open_orders', WS_KEY_MAP.derivativesPrivateV1);\n\n    // Open orders (verbose): https://docs.kraken.com/api/docs/futures-api/websocket/open_orders\n    client.subscribe('open_orders_verbose', WS_KEY_MAP.derivativesPrivateV1);\n\n    // Fills: https://docs.kraken.com/api/docs/futures-api/websocket/fills\n    const accountFillsTopicRequest: WSTopicRequest<WSDerivativesTopic> = {\n      topic: 'fills',\n      // Optionally, the product_ids field can be used to subscribe only to specific product.\n      // payload: {\n      //   product_ids: ['PF_XBTUSD'],\n      // },\n    };\n    client.subscribe(accountFillsTopicRequest, WS_KEY_MAP.derivativesPrivateV1);\n\n    // Balances: https://docs.kraken.com/api/docs/futures-api/websocket/balances\n    client.subscribe('balances', WS_KEY_MAP.derivativesPrivateV1);\n\n    // Open Position: https://docs.kraken.com/api/docs/futures-api/websocket/open_position\n    client.subscribe('open_positions', WS_KEY_MAP.derivativesPrivateV1);\n\n    // Account Log: https://docs.kraken.com/api/docs/futures-api/websocket/account_log\n    client.subscribe('account_log', WS_KEY_MAP.derivativesPrivateV1);\n\n    // Notification: https://docs.kraken.com/api/docs/futures-api/websocket/notifications\n    client.subscribe('notifications_auth', WS_KEY_MAP.derivativesPrivateV1);\n  } catch (e) {\n    console.error('Req error: ', e);\n  }\n}\n\nstart();\n",
                  "metadata": {}
                }
              ]
            }
          ]
        },
        {
          "type": "folder",
          "name": "Spot",
          "path": "examples/Kraken/Spot",
          "children": [
            {
              "type": "folder",
              "name": "Private",
              "path": "examples/Kraken/Spot/Private",
              "children": [
                {
                  "type": "file",
                  "name": "account.ts",
                  "path": "examples/Kraken/Spot/Private/account.ts",
                  "code": "/* eslint-disable @typescript-eslint/no-unused-vars */\n\nimport { SpotClient } from '@siebly/kraken-api';\n// This example shows how to call Kraken API endpoint with either node.js,\n// javascript (js) or typescript (ts) with the npm module \"@siebly/kraken-api\" for Kraken exchange\n// for ACCOUNT INFORMATION\n\n// initialise the client\n/**\n *\n * Kraken API uses API Key and Private Key (base64 encoded)\n *\n * Example:\n * {\n *   apiKey: 'your-api-key',\n *   apiSecret: 'your-base64-encoded-private-key',\n * }\n *\n * API Key Permissions Required:\n * - Funds permissions - Query\n * - Data - Query ledger entries\n *\n */\nconst client = new SpotClient({\n  apiKey: process.env.API_SPOT_KEY || 'insertApiKeyHere',\n  apiSecret: process.env.API_SPOT_SECRET || 'insertApiSecretHere',\n});\n\nasync function getAccountBalance() {\n  try {\n    // Get all cash balances (net of pending withdrawals)\n    const balances = await client.getAccountBalance();\n    console.log('Account Balances: ', JSON.stringify(balances, null, 2));\n\n    // Note: Staking/Earn assets may have these extensions:\n    // .B - balances in new yield-bearing products\n    // .F - balances earning automatically in Kraken Rewards\n    // .T - tokenized assets\n  } catch (e) {\n    console.error('Get account balance error: ', e);\n  }\n}\n\nasync function getExtendedBalance() {\n  try {\n    // Get extended balances including credits and held amounts\n    // Available balance = balance + credit - credit_used - hold_trade\n    const extendedBalances = await client.getExtendedBalance();\n    console.log(\n      'Extended Balances: ',\n      JSON.stringify(extendedBalances, null, 2),\n    );\n  } catch (e) {\n    console.error('Get extended balance error: ', e);\n  }\n}\n\nasync function getTradeBalance() {\n  try {\n    // Get trade balance summary (margin info)\n    const tradeBalance = await client.getTradeBalance();\n    console.log('Trade Balance: ', JSON.stringify(tradeBalance, null, 2));\n\n    // Response includes:\n    // - eb: equivalent balance\n    // - tb: trade balance\n    // - m: margin amount\n    // - n: unrealized P&L\n    // - e: equity\n    // - mf: free margin\n  } catch (e) {\n    console.error('Get trade balance error: ', e);\n  }\n}\n\nasync function getLedgers() {\n  try {\n    // Query specific ledger entries by ID\n    const ledgers = await client.getLedgers({\n      id: 'LUI2RA-CJFLB-EN5I4P,L2QE42-IGSZ3-WEVTLK',\n      trades: false,\n    });\n    console.log('Ledger Entries: ', JSON.stringify(ledgers, null, 2));\n\n    // Ledger entry types include:\n    // - trade, deposit, withdrawal, transfer, margin\n    // - adjustment, rollover, spend, receive, settled\n    // - credit, staking, reward, dividend, sale, conversion\n  } catch (e) {\n    console.error('Query ledgers error: ', e);\n  }\n}\n\nasync function getLedgersInfo() {\n  try {\n    // Get ledger info with filters (returns 50 most recent by default)\n    const ledgersInfo = await client.getLedgersInfo({\n      asset: 'XBT', // Filter by asset\n      type: 'deposit', // Filter by type\n    });\n    console.log('Ledgers Info: ', JSON.stringify(ledgersInfo, null, 2));\n  } catch (e) {\n    console.error('Get ledgers info error: ', e);\n  }\n}\n\nasync function getTradingVolume() {\n  try {\n    // Get 30-day USD trading volume and fee schedule\n    const tradingVolume = await client.getTradingVolume({\n      pair: 'XBTUSD,ETHUSD',\n    });\n    console.log('Trading Volume: ', JSON.stringify(tradingVolume, null, 2));\n\n    // Response includes:\n    // - currency: volume currency\n    // - volume: current trading volume\n    // - fees: fee schedule by pair\n    // - fees_maker: maker fee schedule\n  } catch (e) {\n    console.error('Get trading volume error: ', e);\n  }\n}\n\n// Uncomment the function you want to test:\n\ngetAccountBalance();\n// getExtendedBalance();\n// getTradeBalance();\n// getLedgers();\n// getLedgersInfo();\n// getTradingVolume();\n",
                  "metadata": {}
                },
                {
                  "type": "file",
                  "name": "depositWithdraw.ts",
                  "path": "examples/Kraken/Spot/Private/depositWithdraw.ts",
                  "code": "import { SpotClient } from '@siebly/kraken-api';\n\n// This example shows how to call Kraken API endpoint with either node.js,\n// javascript (js) or typescript (ts) with the npm module \"@siebly/kraken-api\" for Kraken exchange\n// for DEPOSIT AND WITHDRAWAL\n\n/* eslint-disable @typescript-eslint/no-unused-vars */\n// initialise the client\n/**\n *\n * Kraken API uses API Key and Private Key (base64 encoded)\n *\n * Example:\n * {\n *   apiKey: 'your-api-key',\n *   apiSecret: 'your-base64-encoded-private-key',\n * }\n *\n * API Key Permissions Required:\n * - Funds permissions - Query\n * - Funds permissions - Deposit\n * - Funds permissions - Withdraw\n * - Data - Query ledger entries\n *\n */\nconst client = new SpotClient({\n  apiKey: process.env.API_SPOT_KEY || 'insertApiKeyHere',\n  apiSecret: process.env.API_SPOT_SECRET || 'insertApiSecretHere',\n});\n\nasync function withdrawFunds() {\n  try {\n    // Make a withdrawal request\n    const withdrawal = await client.submitWithdrawal({\n      asset: 'XBT',\n      key: 'btc_2709', // Withdrawal key name from your account\n      amount: '0.725',\n      address: 'bc1kar0ssrr7xf3vy5l6d3lydnwkre5og2zz3f5ldq', // Optional confirmation\n    });\n    console.log('Withdrawal Result: ', JSON.stringify(withdrawal, null, 2));\n\n    // Response includes:\n    // - refid: Reference ID for the withdrawal\n  } catch (e) {\n    console.error('Withdraw funds error: ', e);\n  }\n}\n\nasync function getDepositMethods() {\n  try {\n    // Get available deposit methods for an asset\n    const depositMethods = await client.getDepositMethods({\n      asset: 'XBT',\n    });\n    console.log('Deposit Methods: ', JSON.stringify(depositMethods, null, 2));\n\n    // Response includes:\n    // - method: Name of deposit method\n    // - limit: Maximum net amount that can be deposited\n    // - fee: Fees that will be paid\n    // - address-setup-fee: Whether method has setup fee\n    // - gen-address: Whether new addresses can be generated\n    // - minimum: Minimum net amount\n  } catch (e) {\n    console.error('Get deposit methods error: ', e);\n  }\n}\n\nasync function getDepositAddresses() {\n  try {\n    // Get or generate deposit address\n    const depositAddresses = await client.getDepositAddresses({\n      asset: 'XBT',\n      method: 'Bitcoin',\n      new: false, // Set to true to generate new address\n    });\n    console.log(\n      'Deposit Addresses: ',\n      JSON.stringify(depositAddresses, null, 2),\n    );\n\n    // Response includes:\n    // - address: Deposit address\n    // - expiretm: Expiration time or 0 if not expiring\n    // - new: Whether address has ever been used\n    // - tag: Contains tags/memos for XRP, STX, XLM, EOS\n  } catch (e) {\n    console.error('Get deposit addresses error: ', e);\n  }\n}\n\nasync function generateNewDepositAddress() {\n  try {\n    // Generate a new deposit address\n    const newAddress = await client.getDepositAddresses({\n      asset: 'XBT',\n      method: 'Bitcoin',\n      new: true, // Generate new address\n    });\n    console.log('New Deposit Address: ', JSON.stringify(newAddress, null, 2));\n  } catch (e) {\n    console.error('Generate new deposit address error: ', e);\n  }\n}\n\nasync function getWithdrawalMethods() {\n  try {\n    // Get available withdrawal methods\n    const withdrawalMethods = await client.getWithdrawalMethods({\n      asset: 'XBT',\n    });\n    console.log(\n      'Withdrawal Methods: ',\n      JSON.stringify(withdrawalMethods, null, 2),\n    );\n\n    // Response includes:\n    // - asset: Name of asset being withdrawn\n    // - method: Name of withdrawal method\n    // - network: Blockchain/network name\n    // - minimum: Minimum net amount that can be withdrawn\n  } catch (e) {\n    console.error('Get withdrawal methods error: ', e);\n  }\n}\n\nasync function getWithdrawalAddresses() {\n  try {\n    // Get withdrawal addresses\n    const withdrawalAddresses = await client.getWithdrawalAddresses({\n      asset: 'XBT',\n      verified: true, // Filter by verification status\n    });\n    console.log(\n      'Withdrawal Addresses: ',\n      JSON.stringify(withdrawalAddresses, null, 2),\n    );\n\n    // Response includes:\n    // - address: Withdrawal address\n    // - asset: Asset name\n    // - method: Withdrawal method\n    // - key: Withdrawal key name\n    // - tag: Tags/memos for XRP, STX, XLM, EOS\n    // - verified: Verification status\n  } catch (e) {\n    console.error('Get withdrawal addresses error: ', e);\n  }\n}\n\nasync function getWithdrawalAddressByKey() {\n  try {\n    // Find withdrawal address by key name\n    const addressByKey = await client.getWithdrawalAddresses({\n      key: 'btc_2709', // Withdrawal key name\n    });\n    console.log(\n      'Withdrawal Address by Key: ',\n      JSON.stringify(addressByKey, null, 2),\n    );\n  } catch (e) {\n    console.error('Get withdrawal address by key error: ', e);\n  }\n}\n\nasync function getWithdrawalsStatus() {\n  try {\n    // Get status of recent withdrawals\n    const withdrawalsStatus = await client.getWithdrawalsStatus({\n      asset: 'XBT',\n      method: 'Bitcoin',\n    });\n    console.log(\n      'Withdrawals Status: ',\n      JSON.stringify(withdrawalsStatus, null, 2),\n    );\n\n    // Status values:\n    // - Initial: withdrawal just created\n    // - Pending: withdrawal pending\n    // - Settled: withdrawal settled\n    // - Success: withdrawal successful\n    // - Failure: withdrawal failed\n\n    // Status properties (if available):\n    // - cancel-pending: cancelation requested\n    // - canceled: canceled\n    // - cancel-denied: cancelation denied\n    // - return: return transaction by Kraken\n    // - onhold: on hold pending review\n  } catch (e) {\n    console.error('Get withdrawals status error: ', e);\n  }\n}\n\nasync function getWithdrawalsStatusWithPagination() {\n  try {\n    // Get withdrawals with pagination\n    const withdrawalsPaginated = await client.getWithdrawalsStatus({\n      asset: 'XBT',\n      cursor: true, // Enable pagination\n      limit: 10, // Results per page\n    });\n    console.log(\n      'Withdrawals (Paginated): ',\n      JSON.stringify(withdrawalsPaginated, null, 2),\n    );\n  } catch (e) {\n    console.error('Get paginated withdrawals error: ', e);\n  }\n}\n\nasync function getDepositsStatus() {\n  try {\n    // Get status of recent deposits\n    const depositsStatus = await client.getDepositsStatus({\n      asset: 'XBT',\n      method: 'Bitcoin',\n    });\n    console.log('Deposits Status: ', JSON.stringify(depositsStatus, null, 2));\n\n    // Similar status values as withdrawals\n  } catch (e) {\n    console.error('Get deposits status error: ', e);\n  }\n}\n\nasync function cancelWithdrawal() {\n  try {\n    // Cancel a recent withdrawal (if not yet processed)\n    const cancelResult = await client.cancelWithdrawal({\n      asset: 'XBT',\n      refid: 'AGBSO6T-UFMTTQ-I7KGS6', // Reference ID from withdrawal\n    });\n    console.log('Cancel Withdrawal: ', JSON.stringify(cancelResult, null, 2));\n\n    // Returns true if cancellation successful\n  } catch (e) {\n    console.error('Cancel withdrawal error: ', e);\n  }\n}\n\nasync function getWithdrawalInfo() {\n  try {\n    // Get withdrawal fee information before withdrawing\n    const withdrawalInfo = await client.getWithdrawalInfo({\n      asset: 'XBT',\n      key: 'btc_2709',\n      amount: '0.725',\n    });\n    console.log('Withdrawal Info: ', JSON.stringify(withdrawalInfo, null, 2));\n\n    // Response includes:\n    // - method: Withdrawal method\n    // - limit: Maximum amount that can be withdrawn\n    // - amount: Net amount to be withdrawn\n    // - fee: Withdrawal fee\n  } catch (e) {\n    console.error('Get withdrawal info error: ', e);\n  }\n}\n\nasync function transferToFutures() {\n  try {\n    const transfer = await client.submitTransferToFutures({\n      asset: 'EUR',\n      amount: '10',\n      from: 'Spot Wallet',\n      to: 'Futures Wallet',\n    });\n    console.log('Transfer to Futures: ', JSON.stringify(transfer, null, 2));\n  } catch (e) {\n    console.error('Transfer to futures error: ', e);\n  }\n}\n\nasync function transferToSubaccount() {\n  try {\n    const transfer = await client.submitSubaccountTransfer({\n      asset: 'EUR',\n      amount: '50',\n      from: 'UID', // get From API, getSubaccounts()\n      to: 'UID', // get From API, getSubaccounts()\n    });\n    console.log('Transfer to Subaccount: ', JSON.stringify(transfer, null, 2));\n  } catch (e) {\n    console.error('Transfer to subaccount error: ', e);\n  }\n}\n\n// Uncomment the function you want to test:\n\n// withdrawFunds();\n// getDepositMethods();\n// getDepositAddresses();\n// generateNewDepositAddress();\n// getWithdrawalMethods();\n// getWithdrawalAddresses();\n// getWithdrawalAddressByKey();\n// getWithdrawalsStatus();\n// getWithdrawalsStatusWithPagination();\n// getDepositsStatus();\n// cancelWithdrawal();\n// getWithdrawalInfo();\n// transferToFutures();\n// transferToSubaccount();\n",
                  "metadata": {}
                },
                {
                  "type": "file",
                  "name": "orderManagement.ts",
                  "path": "examples/Kraken/Spot/Private/orderManagement.ts",
                  "code": "import { SpotClient } from '@siebly/kraken-api';\n\n// This example shows how to call Kraken API endpoint with either node.js,\n// javascript (js) or typescript (ts) with the npm module \"@siebly/kraken-api\" for Kraken exchange\n// for ORDER MANAGEMENT\n\n/* eslint-disable @typescript-eslint/no-unused-vars */\n// initialise the client\n/**\n *\n * Kraken API uses API Key and Private Key (base64 encoded)\n *\n * Example:\n * {\n *   apiKey: 'your-api-key',\n *   apiSecret: 'your-base64-encoded-private-key',\n * }\n *\n * API Key Permissions Required:\n * - Funds permissions - Query (for balance)\n * - Orders and trades - Query open orders & trades\n * - Orders and trades - Query closed orders & trades\n *\n */\nconst client = new SpotClient({\n  apiKey: process.env.API_SPOT_KEY || 'insertApiKeyHere',\n  apiSecret: process.env.API_SPOT_SECRET || 'insertApiSecretHere',\n});\n\nasync function getTradeBalance() {\n  try {\n    // Get trade balance summary\n    const tradeBalance = await client.getTradeBalance();\n    console.log('Trade Balance: ', JSON.stringify(tradeBalance, null, 2));\n  } catch (e) {\n    console.error('Get trade balance error: ', e);\n  }\n}\n\nasync function getOpenOrders() {\n  try {\n    // Get all open orders\n    const openOrders = await client.getOpenOrders();\n    console.log('Open Orders: ', JSON.stringify(openOrders, null, 2));\n  } catch (e) {\n    console.error('Get open orders error: ', e);\n  }\n}\n\nasync function getOpenOrdersWithTrades() {\n  try {\n    // Get open orders with related trades\n    const openOrdersWithTrades = await client.getOpenOrders({\n      trades: true, // Include trades related to orders\n    });\n    console.log(\n      'Open Orders with Trades: ',\n      JSON.stringify(openOrdersWithTrades, null, 2),\n    );\n  } catch (e) {\n    console.error('Get open orders with trades error: ', e);\n  }\n}\n\nasync function getOpenOrdersByClientId() {\n  try {\n    // Get open orders filtered by client order ID\n    const ordersByClId = await client.getOpenOrders({\n      cl_ord_id: '9cc788d8-9c00-4b25-94d3-26d93603948d',\n    });\n    console.log(\n      'Open Orders by Client ID: ',\n      JSON.stringify(ordersByClId, null, 2),\n    );\n  } catch (e) {\n    console.error('Get open orders by client ID error: ', e);\n  }\n}\n\nasync function getClosedOrders() {\n  try {\n    // Get closed orders (last 50)\n    const closedOrders = await client.getClosedOrders();\n    console.log('Closed Orders: ', JSON.stringify(closedOrders, null, 2));\n  } catch (e) {\n    console.error('Get closed orders error: ', e);\n  }\n}\n\nasync function getClosedOrdersWithFilters() {\n  try {\n    // Get closed orders with filters\n    const closedOrdersFiltered = await client.getClosedOrders({\n      trades: true, // Include related trades\n      start: Math.floor(Date.now() / 1000) - 86400 * 7, // Last 7 days\n      closetime: 'close', // Filter by close time\n    });\n    console.log(\n      'Closed Orders (Last 7 days): ',\n      JSON.stringify(closedOrdersFiltered, null, 2),\n    );\n  } catch (e) {\n    console.error('Get closed orders with filters error: ', e);\n  }\n}\n\nasync function getClosedOrdersByClientId() {\n  try {\n    // Get closed orders by client order ID\n    const closedByClId = await client.getClosedOrders({\n      cl_ord_id: '9cc788d8-9c00-4b25-94d3-26d93603948d',\n      trades: true,\n    });\n    console.log(\n      'Closed Orders by Client ID: ',\n      JSON.stringify(closedByClId, null, 2),\n    );\n  } catch (e) {\n    console.error('Get closed orders by client ID error: ', e);\n  }\n}\n\nasync function getOrdersByTxId() {\n  try {\n    // Query specific orders by transaction ID\n    const ordersByTxId = await client.getOrders({\n      txid: 'OQCLML-BW3P3-BUCMWZ,OZNOZE-2DOVH-Q4DOQT',\n      trades: true,\n    });\n    console.log('Orders by TxID: ', JSON.stringify(ordersByTxId, null, 2));\n  } catch (e) {\n    console.error('Get orders by TxID error: ', e);\n  }\n}\n\n// Uncomment the function you want to test:\n\n// getTradeBalance();\n// getOpenOrders();\n// getOpenOrdersWithTrades();\n// getOpenOrdersByClientId();\n// getClosedOrders();\n// getClosedOrdersWithFilters();\n// getClosedOrdersByClientId();\n// getOrdersByTxId();\n",
                  "metadata": {}
                },
                {
                  "type": "file",
                  "name": "submitOrder.ts",
                  "path": "examples/Kraken/Spot/Private/submitOrder.ts",
                  "code": "import { SpotClient } from '@siebly/kraken-api';\n\n// This example shows how to call Kraken API endpoint with either node.js,\n// javascript (js) or typescript (ts) with the npm module \"@siebly/kraken-api\" for Kraken exchange\n// for SUBMITTING ORDERS\n\n/* eslint-disable @typescript-eslint/no-unused-vars */\n// initialise the client\n/**\n *\n * Kraken API uses API Key and Private Key (base64 encoded)\n *\n * Example:\n * {\n *   apiKey: 'your-api-key',\n *   apiSecret: 'your-base64-encoded-private-key',\n * }\n *\n * API Key Permissions Required: Orders and trades - Create & modify orders\n *\n */\nconst client = new SpotClient({\n  apiKey: process.env.API_SPOT_KEY || 'insertApiKeyHere',\n  apiSecret: process.env.API_SPOT_SECRET || 'insertApiSecretHere',\n});\n\nasync function submitMarketOrder() {\n  try {\n    // submit market spot order\n    const newOrder = await client.submitOrder({\n      ordertype: 'market',\n      type: 'buy',\n      volume: '0.01',\n      pair: 'XBTUSD',\n      cl_ord_id: client.generateNewOrderID(),\n    });\n    console.log('Market Order Result: ', newOrder);\n  } catch (e) {\n    console.error('Send market order error: ', e);\n  }\n}\n\nasync function submitLimitOrder() {\n  try {\n    // Submit limit spot order\n    const limitOrder = await client.submitOrder({\n      ordertype: 'limit',\n      type: 'buy',\n      volume: '0.0001',\n      pair: 'XBTUSD',\n      price: '10000',\n      cl_ord_id: client.generateNewOrderID(),\n    });\n    console.log('Limit Order Result: ', limitOrder);\n  } catch (e) {\n    console.error('Submit limit order error: ', e);\n  }\n}\n\nasync function submitLimitOrderWithFlags() {\n  try {\n    // Submit post-only limit order (maker-only)\n    const postOnlyOrder = await client.submitOrder({\n      ordertype: 'limit',\n      type: 'buy',\n      volume: '0.001',\n      pair: 'XBTEUR',\n      price: '1000.00',\n      oflags: 'post', // post-only flag\n      timeinforce: 'GTC', // Good-til-cancelled\n      cl_ord_id: client.generateNewOrderID(),\n    });\n    console.log('Post-Only Limit Order Result: ', postOnlyOrder);\n  } catch (e) {\n    console.error('Submit post-only order error: ', e);\n  }\n}\n\nasync function submitBatchOrders() {\n  try {\n    // Submit batch of orders (minimum 2, maximum 15)\n    // All orders must be for the same pair\n    const batchResult = await client.submitBatchOrders({\n      pair: 'XBTUSD',\n      orders: [\n        {\n          ordertype: 'limit',\n          type: 'buy',\n          volume: '0.0001',\n          price: '10000.00',\n          timeinforce: 'GTC',\n          cl_ord_id: client.generateNewOrderID(),\n        },\n        {\n          ordertype: 'limit',\n          type: 'buy',\n          volume: '0.0001',\n          price: '11111.00',\n          timeinforce: 'GTC',\n          cl_ord_id: client.generateNewOrderID(),\n        },\n        {\n          ordertype: 'limit',\n          type: 'sell',\n          volume: '0.0001',\n          price: '13000.00',\n          timeinforce: 'GTC',\n          cl_ord_id: client.generateNewOrderID(),\n        },\n      ],\n    });\n    console.log('Batch Order Result: ', JSON.stringify(batchResult, null, 2));\n  } catch (e) {\n    console.error('Submit batch orders error: ', e);\n  }\n}\n\nasync function submitBatchOrdersValidateOnly() {\n  try {\n    // Validate batch orders without submitting them\n    const validationResult = await client.submitBatchOrders({\n      pair: 'XBTUSD',\n      validate: true, // Only validate, don't submit\n      orders: [\n        {\n          ordertype: 'limit',\n          type: 'buy',\n          volume: '0.0001',\n          price: '45000.00',\n          cl_ord_id: client.generateNewOrderID(),\n        },\n        {\n          ordertype: 'limit',\n          type: 'sell',\n          volume: '0.0001',\n          price: '55000.00',\n          cl_ord_id: client.generateNewOrderID(),\n        },\n      ],\n    });\n    console.log(\n      'Validation Result: ',\n      JSON.stringify(validationResult, null, 2),\n    );\n  } catch (e) {\n    console.error('Batch validation error: ', e);\n  }\n}\n\n// Uncomment the function you want to test:\n\nsubmitMarketOrder();\n// submitLimitOrder();\n// submitLimitOrderWithFlags();\n// submitBatchOrders();\n// submitBatchOrdersValidateOnly();\n",
                  "metadata": {}
                }
              ]
            },
            {
              "type": "folder",
              "name": "Public",
              "path": "examples/Kraken/Spot/Public",
              "children": [
                {
                  "type": "file",
                  "name": "marketData.ts",
                  "path": "examples/Kraken/Spot/Public/marketData.ts",
                  "code": "import { SpotClient } from '@siebly/kraken-api';\n\n// This example shows how to call Kraken API endpoint with either node.js,\n// javascript (js) or typescript (ts) with the npm module \"@siebly/kraken-api\" for Kraken exchange\n// for PUBLIC MARKET DATA that requires no authentication\n\n// you can initialise public client without api keys as public calls do not require auth\nconst client = new SpotClient();\n\nasync function publicCalls() {\n  try {\n    // Get server time\n    const serverTime = await client.getServerTime();\n    console.log('Server Time: ', serverTime);\n\n    // Get system status\n    const systemStatus = await client.getSystemStatus();\n    console.log('System Status: ', systemStatus);\n\n    // Get asset info\n    const assetInfo = await client.getAssetInfo({\n      asset: 'XBT,ETH',\n    });\n    console.log('Asset Info: ', assetInfo);\n\n    // Get tradable asset pairs\n    const assetPairs = await client.getAssetPairs({\n      pair: 'XBTUSD,ETHUSD',\n    });\n    console.log('Asset Pairs: ', assetPairs);\n\n    // Get ticker information\n    const ticker = await client.getTicker({\n      pair: 'XBTUSD',\n    });\n    console.log('Ticker: ', ticker);\n\n    // Get order book\n    const orderBook = await client.getOrderBook({\n      pair: 'XBTUSD',\n      count: 10,\n    });\n    console.log('Order Book: ', orderBook);\n\n    // Get OHLC data (candles)\n    const candles = await client.getCandles({\n      pair: 'XBTUSD',\n      interval: 60, // 1 minute\n    });\n    console.log('OHLC Candles: ', candles);\n\n    // Get recent trades\n    const recentTrades = await client.getRecentTrades({\n      pair: 'XBTUSD',\n      count: 10,\n    });\n    console.log('Recent Trades: ', recentTrades);\n\n    // Get recent spreads\n    const recentSpreads = await client.getRecentSpreads({\n      pair: 'XBTUSD',\n    });\n    console.log('Recent Spreads: ', recentSpreads);\n  } catch (e) {\n    console.error('Error: ', e);\n  }\n}\n\npublicCalls();\n",
                  "metadata": {}
                }
              ]
            },
            {
              "type": "folder",
              "name": "WebSockets",
              "path": "examples/Kraken/Spot/WebSockets",
              "children": [
                {
                  "type": "file",
                  "name": "privateWs.ts",
                  "path": "examples/Kraken/Spot/WebSockets/privateWs.ts",
                  "code": "// eslint-disable-next-line @typescript-eslint/no-unused-vars\nimport {\n  DefaultLogger,\n  LogParams,\n  WebsocketClient,\n  WS_KEY_MAP,\n  WSSpotTopic,\n  WSTopicRequest,\n} from '@siebly/kraken-api';\n\nconst customLogger: DefaultLogger = {\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  trace: (...params: LogParams): void => {\n    // console.log('trace', ...params);\n  },\n  info: (...params: LogParams): void => {\n    console.log('info', ...params);\n  },\n  error: (...params: LogParams): void => {\n    console.error('error', ...params);\n  },\n};\n\nasync function start() {\n  const account = {\n    key: process.env.API_SPOT_KEY || 'keyHere',\n    secret: process.env.API_SPOT_SECRET || 'secretHere',\n  };\n\n  /**\n   * The WebsocketClient is the core class to manage WebSocket subscriptions. Give it the topics you want to subscribe to, and it will handle the rest:\n   * - Connection management (connect, disconnect, reconnect)\n   * - Authentication for private topics\n   * - Subscription management (subscribe, unsubscribe, resubscribe on reconnect)\n   * - Message handling (dispatch messages to appropriate handlers)\n   *\n   * All you need to do is provide the topics you want to subscribe to when calling `subscribe()`, and the client will take care of the rest.\n   *\n   * Here we create a WebsocketClient instance with API key/secret for private topic subscriptions.\n   *\n   * In terms of product groups such as Spot, Derivatives, etc., the WebsocketClient understand the product group from the WsKey you provide when subscribing. For example, using `WS_KEY_MAP.spotPrivateV2` indicates that the subscription is for Spot private topics, as shown below.\n   *\n   * Refer to WS_KEY_MAP in the source code for all available WsKey options.\n   */\n  const client = new WebsocketClient(\n    {\n      apiKey: account.key,\n      apiSecret: account.secret,\n    },\n    customLogger,\n  );\n\n  client.on('open', (data) => {\n    console.log('connected ', data?.wsKey);\n  });\n\n  // Data received\n  client.on('message', (data) => {\n    console.info('data received: ', JSON.stringify(data));\n  });\n\n  // Something happened, attempting to reconnect\n  client.on('reconnecting', (data) => {\n    console.log('reconnect: ', data);\n  });\n\n  // Reconnect successful\n  client.on('reconnected', (data) => {\n    console.log('reconnected: ', data);\n  });\n\n  // Connection closed. If unexpected, expect reconnect -> reconnected.\n  client.on('close', (data) => {\n    console.error('close: ', data);\n  });\n\n  // Reply to a request, e.g. \"subscribe\"/\"unsubscribe\"/\"authenticate\"\n  client.on('response', (data) => {\n    console.info('server reply: ', JSON.stringify(data), '\\n');\n  });\n\n  client.on('exception', (data) => {\n    console.error('exception: ', data);\n  });\n\n  client.on('authenticated', (data) => {\n    console.error('authenticated: ', data);\n  });\n\n  /**\n   * The below examples demonstrate how you can subscribe to private topics.\n   *\n   * Note: while the documentation specifies \"token\" as a required parameter, the SDK will automatically:\n   * - fetch the token using your API key/secret,\n   * - manage token caching/refreshing,\n   * - include the token in the request for you.\n   *\n   * So you do NOT need to manually fetch or provide the token when subscribing to private topics.\n   *\n   * Do note that:\n   * - Most private topics use \"spotPrivateV2\" WsKey, which connects to \"wss://ws-auth.kraken.com/v2\"\n   * - The level3 topic uses \"spotL3V2\" WsKey, which connects to \"wss://ws-l3.kraken.com/v2\" (dedicated L3 endpoint)\n   */\n\n  try {\n    // Balances, requires auth: https://docs.kraken.com/api/docs/websocket-v2/executions\n    const executionsRequestWithParams: WSTopicRequest<WSSpotTopic> = {\n      topic: 'executions',\n      payload: {\n        // below params are optional:\n        snap_trades: true, // default: false\n        snap_orders: true, // default: true\n        order_status: true, // default: true\n        // rebased: false, // default: true\n        ratecounter: true, // default: false\n        // users: 'all', // default: undefined\n        // snapshot: true, // default: false, deprecated, use 'snap_orders' or 'snap_trades' instead\n      },\n    };\n    client.subscribe(executionsRequestWithParams, WS_KEY_MAP.spotPrivateV2);\n\n    // Balances, requires auth: https://docs.kraken.com/api/docs/websocket-v2/balances\n    const balancesRequestWithParams: WSTopicRequest<WSSpotTopic> = {\n      topic: 'balances',\n      payload: {\n        // below params are optional:\n        // snapshot: true, // default: true\n        // rebased: false, // default: true\n        // users: 'all',\n      },\n    };\n    client.subscribe(balancesRequestWithParams, WS_KEY_MAP.spotPrivateV2);\n\n    // Orders Level 3, requires auth: https://docs.kraken.com/api/docs/websocket-v2/level3\n    // Note: level3 uses a dedicated endpoint (wss://ws-l3.kraken.com/v2), so use WS_KEY_MAP.spotL3V2\n    const ordersRequestWithParams: WSTopicRequest<WSSpotTopic> = {\n      // topic: 'level3',\n      topic: 'level3',\n      payload: {\n        symbol: ['ALGO/USD', 'BTC/USD'],\n        // below params are optional:\n        // depth: 10, // default: 10, Possible values: [10, 100, 1000]\n        // snapshot: true, // default: true\n      },\n    };\n\n    client.subscribe(ordersRequestWithParams, WS_KEY_MAP.spotL3V2);\n  } catch (e) {\n    console.error('Req error: ', e);\n  }\n}\n\nstart();\n",
                  "metadata": {}
                },
                {
                  "type": "file",
                  "name": "publicWs.ts",
                  "path": "examples/Kraken/Spot/WebSockets/publicWs.ts",
                  "code": "/* eslint-disable @typescript-eslint/no-unused-vars */\nimport {\n  DefaultLogger,\n  LogParams,\n  WebsocketClient,\n  WS_KEY_MAP,\n  WSTopicRequest,\n} from '@siebly/kraken-api';\n\nconst customLogger: DefaultLogger = {\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  trace: (...params: LogParams): void => {\n    // console.log('trace', ...params);\n  },\n  info: (...params: LogParams): void => {\n    console.log('info', ...params);\n  },\n  error: (...params: LogParams): void => {\n    console.error('error', ...params);\n  },\n};\n\nasync function start() {\n  /**\n   * The WebsocketClient is the core class to manage WebSocket subscriptions. Give it the topics you want to subscribe to, and it will handle the rest:\n   * - Connection management (connect, disconnect, reconnect)\n   * - Authentication for private topics\n   * - Subscription management (subscribe, unsubscribe, resubscribe on reconnect)\n   * - Message handling (dispatch messages to appropriate handlers)\n   *\n   * All you need to do is provide the topics you want to subscribe to when calling `subscribe()`, and the client will take care of the rest.\n   *\n   * Here we create a WebsocketClient instance with API key/secret for private topic subscriptions.\n   *\n   * In terms of product groups such as Spot, Derivatives, etc., the WebsocketClient understand the product group from the WsKey you provide when subscribing. For example, using `WS_KEY_MAP.spotPublicV2` indicates that the subscription is for Spot private topics, as shown below.\n   *\n   * Refer to WS_KEY_MAP in the source code for all available WsKey options.\n   */\n  const client = new WebsocketClient({}, customLogger);\n\n  // Optional, inject a custom logger\n  // const client = new WebsocketClient({}, customLogger);\n\n  client.on('open', (data) => {\n    console.log('connected ', data?.wsKey);\n  });\n\n  // Data received\n  client.on('message', (data) => {\n    console.info('data received: ', JSON.stringify(data));\n  });\n\n  // Something happened, attempting to reconnect\n  client.on('reconnecting', (data) => {\n    console.log('reconnect: ', data);\n  });\n\n  // Reconnect successful\n  client.on('reconnected', (data) => {\n    console.log('reconnected: ', data);\n  });\n\n  // Connection closed. If unexpected, expect reconnect -> reconnected.\n  client.on('close', (data) => {\n    console.error('close: ', data);\n  });\n\n  // Reply to a request, e.g. \"subscribe\"/\"unsubscribe\"/\"authenticate\"\n  client.on('response', (data) => {\n    console.info('server reply: ', JSON.stringify(data), '\\n');\n  });\n\n  client.on('exception', (data) => {\n    console.error('exception: ', data);\n  });\n\n  client.on('authenticated', (data) => {\n    console.error('authenticated: ', data);\n  });\n\n  try {\n    // Spot ticker level 1: https://docs.kraken.com/api/docs/websocket-v2/ticker\n    const tickersRequestWithParams: WSTopicRequest = {\n      topic: 'ticker',\n      payload: {\n        symbol: ['ALGO/USD', 'BTC/USD'],\n        // below params are optional:\n        // event_trigger: 'bbo', // bbo: on a change in the best-bid-offer price levels.\n        // event_trigger: 'trades', // trades: on every trade.\n        // snapshot: true, // default: true\n      },\n    };\n\n    // client.subscribe(tickersRequestWithParams, WS_KEY_MAP.spotPublicV2);\n\n    // Book level 2: https://docs.kraken.com/api/docs/websocket-v2/book\n    const bookRequestWithParams: WSTopicRequest = {\n      topic: 'book',\n      payload: {\n        symbol: ['BTC/USD', 'BTC/GBP'],\n        // below params are optional:\n        // depth: 10, // default: 10, Possible values: [10, 25, 100, 500, 1000]\n        // snapshot: true, // default: true\n      },\n    };\n\n    // client.subscribe(bookRequestWithParams, WS_KEY_MAP.spotPublicV2);\n\n    // Candles (OHLC): https://docs.kraken.com/api/docs/websocket-v2/ohlc\n    const candleOhlcRequestWithParams: WSTopicRequest = {\n      topic: 'ohlc',\n      payload: {\n        symbol: ['BTC/USD', 'BTC/GBP'],\n        interval: 1, // Possible values: [1, 5, 15, 30, 60, 240, 1440, 10080, 21600]\n\n        // below params are optional:\n        // snapshot: true, // default: true\n      },\n    };\n\n    // client.subscribe(candleOhlcRequestWithParams, WS_KEY_MAP.spotPublicV2);\n\n    // Trades: https://docs.kraken.com/api/docs/websocket-v2/trade\n    const tradesRequestWithParams: WSTopicRequest = {\n      topic: 'trade',\n      payload: {\n        symbol: ['BTC/USD', 'BTC/GBP'],\n        // below params are optional:\n        // snapshot: true, // default: true\n      },\n    };\n\n    // client.subscribe(tradesRequestWithParams, WS_KEY_MAP.spotPublicV2);\n\n    // Instruments: https://docs.kraken.com/api/docs/websocket-v2/instrument\n    const instrumentsRequestWithParams: WSTopicRequest = {\n      topic: 'instrument',\n      payload: {\n        symbol: ['BTC/USD', 'BTC/GBP'],\n        // below params are optional:\n        // If true, include xStocks in the response, otherwise include crypto spot pairs only:\n        include_tokenized_assets: true, // default: false\n        // snapshot: true, // default: true\n      },\n    };\n\n    client.subscribe(instrumentsRequestWithParams, WS_KEY_MAP.spotPublicV2);\n\n    /**\n     * Either send one topic (with optional params) at a time (as shown above in the commented-out lines)\n     */\n    client.subscribe(tickersRequestWithParams, WS_KEY_MAP.spotPublicV2);\n\n    /**\n     * Or send multiple topics in a batch (grouped by ws connection (WsKey))\n     */\n    client.subscribe(\n      [\n        tickersRequestWithParams,\n        tradesRequestWithParams,\n        instrumentsRequestWithParams,\n      ],\n      WS_KEY_MAP.spotPublicV2,\n    );\n  } catch (e) {\n    console.error('Req error: ', e);\n  }\n}\n\nstart();\n",
                  "metadata": {}
                },
                {
                  "type": "file",
                  "name": "wsAPI.RAW.ts",
                  "path": "examples/Kraken/Spot/WebSockets/wsAPI.RAW.ts",
                  "code": "// eslint-disable-next-line @typescript-eslint/no-unused-vars\nimport {\n  DefaultLogger,\n  LogParams,\n  WebsocketClient,\n  WS_KEY_MAP,\n} from '@siebly/kraken-api';\n\nconst customLogger: DefaultLogger = {\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  trace: (...params: LogParams): void => {\n    // console.log('trace', ...params);\n  },\n  info: (...params: LogParams): void => {\n    console.log('info', ...params);\n  },\n  error: (...params: LogParams): void => {\n    console.error('error', ...params);\n  },\n};\n\nasync function start() {\n  const account = {\n    key: process.env.API_SPOT_KEY || 'keyHere',\n    secret: process.env.API_SPOT_SECRET || 'secretHere',\n  };\n\n  /**\n   * The WebsocketClient is the core class to manage WebSocket subscriptions. Give it the topics you want to subscribe to, and it will handle the rest:\n   * - Connection management (connect, disconnect, reconnect)\n   * - Authentication for private topics\n   * - Subscription management (subscribe, unsubscribe, resubscribe on reconnect)\n   * - Message handling (dispatch messages to appropriate handlers)\n   *\n   * All you need to do is provide the topics you want to subscribe to when calling `subscribe()`, and the client will take care of the rest.\n   *\n   * Here we create a WebsocketClient instance with API key/secret for private topic subscriptions.\n   *\n   * In terms of product groups such as Spot, Derivatives, etc., the WebsocketClient understand the product group from the WsKey you provide when subscribing. For example, using `WS_KEY_MAP.spotPrivateV2` indicates that the subscription is for Spot private topics, as shown below.\n   *\n   * Refer to WS_KEY_MAP in the source code for all available WsKey options.\n   */\n  const client = new WebsocketClient(\n    {\n      apiKey: account.key,\n      apiSecret: account.secret,\n    },\n    customLogger,\n  );\n\n  client.on('open', (data) => {\n    console.log('connected ', data?.wsKey);\n  });\n\n  // Data received\n  client.on('message', (data) => {\n    console.info('data received: ', JSON.stringify(data));\n  });\n\n  // Something happened, attempting to reconnect\n  client.on('reconnecting', (data) => {\n    console.log('reconnect: ', data);\n  });\n\n  // Reconnect successful\n  client.on('reconnected', (data) => {\n    console.log('reconnected: ', data);\n  });\n\n  // Connection closed. If unexpected, expect reconnect -> reconnected.\n  client.on('close', (data) => {\n    console.error('close: ', data);\n  });\n\n  // Reply to a request, e.g. \"subscribe\"/\"unsubscribe\"/\"authenticate\"\n  client.on('response', (data) => {\n    console.info('server reply: ', JSON.stringify(data), '\\n');\n  });\n\n  client.on('exception', (data) => {\n    console.error('exception: ', data);\n  });\n\n  client.on('authenticated', (data) => {\n    console.error('authenticated: ', data);\n  });\n\n  /**\n   * The below examples demonstrate how you can subscribe to private topics.\n   *\n   * Note: while the documentation specifies \"token\" as a required parameter, the SDK will automatically:\n   * - fetch the token using your API key/secret,\n   * - manage token caching/refreshing,\n   * - include the token in the request for you.\n   *\n   * So you do NOT need to manually fetch or provide the token when subscribing to private topics.\n   *\n   * Do note that all of these include the \"spotPrivateV2\" WsKey reference. This tells the WebsocketClient to use the private \"wss://ws-auth.kraken.com/v2\" endpoint for these private subscription requests.\n   */\n\n  try {\n    const addOrderResponse = await client.sendWSAPIRequest(\n      WS_KEY_MAP.spotPrivateV2,\n      'add_order',\n      {\n        order_type: 'limit',\n        side: 'buy',\n        limit_price: 26500.4,\n        order_userref: 100054,\n        order_qty: 1.2,\n        symbol: 'BTC/USD',\n      },\n    );\n    console.log('addOrderResponse: ', addOrderResponse);\n\n    const addOrderConditionalResponse = await client.sendWSAPIRequest(\n      WS_KEY_MAP.spotPrivateV2,\n      'add_order',\n      {\n        order_type: 'limit',\n        side: 'buy',\n        order_qty: 1.2,\n        symbol: 'BTC/USD',\n        limit_price: 28440,\n        conditional: {\n          order_type: 'stop-loss-limit',\n          trigger_price: 28410,\n          limit_price: 28400,\n        },\n      },\n    );\n    console.log('addOrderConditionalResponse: ', addOrderConditionalResponse);\n\n    const addOrderTriggersResponse = await client.sendWSAPIRequest(\n      WS_KEY_MAP.spotPrivateV2,\n      'add_order',\n      {\n        order_type: 'stop-loss',\n        side: 'sell',\n        order_qty: 100,\n        symbol: 'MATIC/USD',\n        triggers: {\n          reference: 'last',\n          price: 10.0,\n          price_type: 'pct',\n        },\n      },\n    );\n    console.log('addOrderTriggersResponse: ', addOrderTriggersResponse);\n\n    const amendOrderResponse = await client.sendWSAPIRequest(\n      WS_KEY_MAP.spotPrivateV2,\n      'amend_order',\n      {\n        cl_ord_id: '2c6be801-1f53-4f79-a0bb-4ea1c95dfae9',\n        limit_price: 10000,\n        order_qty: 1.2,\n      },\n    );\n    console.log('amendOrderResponse: ', amendOrderResponse);\n\n    const amendOrderPostOnlyResponse = await client.sendWSAPIRequest(\n      WS_KEY_MAP.spotPrivateV2,\n      'amend_order',\n      {\n        order_id: 'OAIYAU-LGI3M-PFM5VW',\n        order_qty: 1.2,\n        limit_price: 1100.3,\n        deadline: '2025-11-19T09:53:59.050Z',\n        post_only: true,\n      },\n    );\n    console.log('amendOrderPostOnlyResponse: ', amendOrderPostOnlyResponse);\n\n    const cancelOrderResponse = await client.sendWSAPIRequest(\n      WS_KEY_MAP.spotPrivateV2,\n      'cancel_order',\n      {\n        order_id: ['OM5CRX-N2HAL-GFGWE9', 'OLUMT4-UTEGU-ZYM7E9'],\n      },\n    );\n    console.log('cancelOrderResponse: ', cancelOrderResponse);\n\n    const cancelAllResponse = await client.sendWSAPIRequest(\n      WS_KEY_MAP.spotPrivateV2,\n      'cancel_all',\n    );\n    console.log('cancelAllResponse: ', cancelAllResponse);\n\n    const cancelAllOrdersAfterResponse = await client.sendWSAPIRequest(\n      WS_KEY_MAP.spotPrivateV2,\n      'cancel_all_orders_after',\n      {\n        timeout: 100,\n      },\n    );\n    console.log('cancelAllOrdersAfterResponse: ', cancelAllOrdersAfterResponse);\n\n    const batchAddResponse = await client.sendWSAPIRequest(\n      WS_KEY_MAP.spotPrivateV2,\n      'batch_add',\n      {\n        deadline: '2025-11-19T09:53:59.050Z',\n        orders: [\n          {\n            limit_price: 1010.1,\n            order_qty: 1.2,\n            order_type: 'limit',\n            order_userref: 1,\n            side: 'buy',\n          },\n          {\n            limit_price: 1100.3,\n            order_qty: 1.2,\n            order_type: 'limit',\n            order_userref: 2,\n            side: 'sell',\n            stp_type: 'cancel_both',\n          },\n        ],\n        symbol: 'BTC/USD',\n        validate: false,\n      },\n    );\n    console.log('batchAddResponse: ', batchAddResponse);\n\n    const batchCancelResponse = await client.sendWSAPIRequest(\n      WS_KEY_MAP.spotPrivateV2,\n      'batch_cancel',\n      {\n        orders: ['OM5CRX-N2HAL-GFGWE9', 'OLUMT4-UTEGU-ZYM7E9'],\n      },\n    );\n    console.log('batchCancelResponse: ', batchCancelResponse);\n  } catch (e) {\n    console.error('Req error: ', e);\n  }\n}\n\nstart();\n",
                  "metadata": {}
                },
                {
                  "type": "file",
                  "name": "wsAPI.ts",
                  "path": "examples/Kraken/Spot/WebSockets/wsAPI.ts",
                  "code": "// eslint-disable-next-line @typescript-eslint/no-unused-vars\nimport {\n  DefaultLogger,\n  LogParams,\n  WebsocketAPIClient,\n} from '@siebly/kraken-api';\n\nconst customLogger: DefaultLogger = {\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  trace: (...params: LogParams): void => {\n    // console.log('trace', ...params);\n  },\n  info: (...params: LogParams): void => {\n    console.log('info', ...params);\n  },\n  error: (...params: LogParams): void => {\n    console.error('error', ...params);\n  },\n};\n\nasync function start() {\n  const account = {\n    key: process.env.API_SPOT_KEY || 'keyHere',\n    secret: process.env.API_SPOT_SECRET || 'secretHere',\n  };\n\n  /**\n   * The WebsocketClient is the core class to manage WebSocket subscriptions. Give it the topics you want to subscribe to, and it will handle the rest:\n   * - Connection management (connect, disconnect, reconnect)\n   * - Authentication for private topics\n   * - Subscription management (subscribe, unsubscribe, resubscribe on reconnect)\n   * - Message handling (dispatch messages to appropriate handlers)\n   *\n   * All you need to do is provide the topics you want to subscribe to when calling `subscribe()`, and the client will take care of the rest.\n   *\n   * Here we create a WebsocketClient instance with API key/secret for private topic subscriptions.\n   *\n   * In terms of product groups such as Spot, Derivatives, etc., the WebsocketClient understand the product group from the WsKey you provide when subscribing. For example, using `WS_KEY_MAP.spotPrivateV2` indicates that the subscription is for Spot private topics, as shown below.\n   *\n   * Refer to WS_KEY_MAP in the source code for all available WsKey options.\n   */\n  const client = new WebsocketAPIClient(\n    {\n      apiKey: account.key,\n      apiSecret: account.secret,\n    },\n    customLogger,\n  );\n\n  /**\n   * The below examples demonstrate how you can subscribe to private topics.\n   *\n   * Note: while the documentation specifies \"token\" as a required parameter, the SDK will automatically:\n   * - fetch the token using your API key/secret,\n   * - manage token caching/refreshing,\n   * - include the token in the request for you.\n   *\n   * So you do NOT need to manually fetch or provide the token when subscribing to private topics.\n   *\n   * Do note that all of these include the \"spotPrivateV2\" WsKey reference. This tells the WebsocketClient to use the private \"wss://ws-auth.kraken.com/v2\" endpoint for these private subscription requests.\n   */\n\n  try {\n    const addOrderResponse = await client.submitSpotOrder({\n      order_type: 'limit',\n      side: 'buy',\n      limit_price: 26500.4,\n      order_userref: 100054,\n      order_qty: 1.2,\n      symbol: 'BTC/USD',\n    });\n    console.log('addOrderResponse: ', addOrderResponse);\n\n    const addOrderConditionalResponse = await client.submitSpotOrder({\n      order_type: 'limit',\n      side: 'buy',\n      order_qty: 1.2,\n      symbol: 'BTC/USD',\n      limit_price: 28440,\n      conditional: {\n        order_type: 'stop-loss-limit',\n        trigger_price: 28410,\n        limit_price: 28400,\n      },\n    });\n    console.log('addOrderConditionalResponse: ', addOrderConditionalResponse);\n\n    const addOrderTriggersResponse = await client.submitSpotOrder({\n      order_type: 'stop-loss',\n      side: 'sell',\n      order_qty: 100,\n      symbol: 'MATIC/USD',\n      triggers: {\n        reference: 'last',\n        price: 10.0,\n        price_type: 'pct',\n      },\n    });\n    console.log('addOrderTriggersResponse: ', addOrderTriggersResponse);\n\n    const amendOrderResponse = await client.amendSpotOrder({\n      cl_ord_id: '2c6be801-1f53-4f79-a0bb-4ea1c95dfae9',\n      limit_price: 10000,\n      order_qty: 1.2,\n    });\n    console.log('amendOrderResponse: ', amendOrderResponse);\n\n    const amendOrderPostOnlyResponse = await client.amendSpotOrder({\n      order_id: 'OAIYAU-LGI3M-PFM5VW',\n      order_qty: 1.2,\n      limit_price: 1100.3,\n      deadline: '2025-11-19T09:53:59.050Z',\n      post_only: true,\n    });\n    console.log('amendOrderPostOnlyResponse: ', amendOrderPostOnlyResponse);\n\n    const cancelOrderResponse = await client.cancelSpotOrder({\n      order_id: ['OM5CRX-N2HAL-GFGWE9', 'OLUMT4-UTEGU-ZYM7E9'],\n    });\n    console.log('cancelOrderResponse: ', cancelOrderResponse);\n\n    const cancelAllResponse = await client.cancelAllSpotOrders();\n    console.log('cancelAllResponse: ', cancelAllResponse);\n\n    const cancelAllOrdersAfterResponse = await client.cancelAllSpotOrdersAfter({\n      timeout: 100,\n    });\n    console.log('cancelAllOrdersAfterResponse: ', cancelAllOrdersAfterResponse);\n\n    const batchAddResponse = await client.batchSubmitSpotOrders({\n      deadline: '2025-11-19T09:53:59.050Z',\n      orders: [\n        {\n          limit_price: 1010.1,\n          order_qty: 1.2,\n          order_type: 'limit',\n          order_userref: 1,\n          side: 'buy',\n        },\n        {\n          limit_price: 1100.3,\n          order_qty: 1.2,\n          order_type: 'limit',\n          order_userref: 2,\n          side: 'sell',\n          stp_type: 'cancel_both',\n        },\n      ],\n      symbol: 'BTC/USD',\n      validate: false,\n    });\n    console.log('batchAddResponse: ', batchAddResponse);\n\n    const batchCancelResponse = await client.batchCancelSpotOrders({\n      orders: ['OM5CRX-N2HAL-GFGWE9', 'OLUMT4-UTEGU-ZYM7E9'],\n    });\n    console.log('batchCancelResponse: ', batchCancelResponse);\n  } catch (e) {\n    console.error('Req error: ', e);\n  }\n}\n\nstart();\n",
                  "metadata": {}
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "type": "folder",
      "name": "Kucoin",
      "path": "examples/Kucoin",
      "children": [
        {
          "type": "folder",
          "name": "Auth",
          "path": "examples/Kucoin/Auth",
          "children": [
            {
              "type": "file",
              "name": "authorizationHeader.ts",
              "path": "examples/Kucoin/Auth/authorizationHeader.ts",
              "code": "import { SpotClient } from 'kucoin-api';\n\nasync function start() {\n  /**\n   * All REST clients support passing the access token. If available, sign will be skipped for the request and the access token will instead be used via an authorization header.\n   *\n   * More details: https://github.com/tiagosiebler/kucoin-api/issues/2\n   */\n  const client = new SpotClient({\n    apiAccessToken: 'accessTokenHere!',\n  });\n\n  try {\n    const result = await client.getBalances();\n\n    console.log('result ', JSON.stringify(result, null, 2));\n  } catch (e) {\n    console.error('Req error: ', e);\n  }\n\n  // If you later need to set a new access token (e.g. it expired):\n  client.setAccessToken('newAccessTokenHere');\n}\n\nstart();\n",
              "metadata": {}
            },
            {
              "type": "file",
              "name": "fasterHmacSign.ts",
              "path": "examples/Kucoin/Auth/fasterHmacSign.ts",
              "code": "import { createHmac } from 'crypto';\nimport { DefaultLogger, SpotClient, WebsocketClient } from 'kucoin-api';\n\n/**\n * Injecting a custom signMessage function.\n *\n * As of version 3.0.0 of the bitget-api Node.js/TypeScript/JavaScript\n * SDK for Bitget, the SDK uses the Web Crypto API for signing requests.\n * While it is compatible with Node and Browser environments, it is\n * slightly slower than using Node's native crypto module (only\n * available in backend Node environments).\n *\n * For latency sensitive users, you can inject the previous node crypto sign\n * method (or your own even faster implementation), if this change affects you.\n *\n * This example demonstrates how to inject a custom sign function, to achieve\n * the same peformance as seen before the Web Crypto API was introduced.\n *\n * For context on standard usage, the \"signMessage\" function is used:\n * - During every single API call\n * - After opening a new private WebSocket connection\n */\n\nconst apiKey = process.env.API_KEY_COM;\nconst apiSecret = process.env.API_SECRET_COM;\nconst apiPass = process.env.API_PASS_COM;\n\nconst restClient = new SpotClient({\n  apiKey: apiKey,\n  apiSecret: apiSecret,\n  apiPassphrase: apiPass,\n  /**\n   * Overkill in almost every case, but if you need any optimisation available,\n   * you can inject a faster sign mechanism such as node's native createHmac:\n   */\n  customSignMessageFn: async (message, secret) => {\n    return createHmac('sha256', secret).update(message).digest('hex');\n  },\n});\n\n// Optional, uncomment the \"trace\" override to log a lot more info about what the WS client is doing\nconst customLogger = {\n  ...DefaultLogger,\n  // trace: (...params) => console.log('trace', ...params),\n};\n\nconst wsClient = new WebsocketClient(\n  {\n    apiKey: apiKey,\n    apiSecret: apiSecret,\n    apiPassphrase: apiPass,\n    /**\n     * Overkill in almost every case, but if you need any optimisation available,\n     * you can inject a faster sign mechanism such as node's native createHmac:\n     */\n    customSignMessageFn: async (message, secret) => {\n      return createHmac('sha256', secret).update(message).digest('hex');\n    },\n  },\n  customLogger,\n);\n\nfunction setWsClientEventListeners(\n  websocketClient: WebsocketClient,\n  accountRef: string,\n): Promise<void> {\n  return new Promise((resolve) => {\n    websocketClient.on('update', (data) => {\n      console.log(new Date(), accountRef, 'data ', JSON.stringify(data));\n      // console.log('raw message received ', JSON.stringify(data, null, 2));\n    });\n\n    websocketClient.on('open', (data) => {\n      console.log(\n        new Date(),\n        accountRef,\n        'connection opened open:',\n        data.wsKey,\n      );\n    });\n    websocketClient.on('response', (data) => {\n      console.log(\n        new Date(),\n        accountRef,\n        'log response: ',\n        JSON.stringify(data, null, 2),\n      );\n\n      if (typeof data.req_id === 'string') {\n        const topics = data.req_id.split(',');\n        if (topics.length) {\n          console.log(new Date(), accountRef, 'Subscribed to topics: ', topics);\n          return resolve();\n        }\n      }\n    });\n    websocketClient.on('reconnect', ({ wsKey }) => {\n      console.log(\n        new Date(),\n        accountRef,\n        'ws automatically reconnecting.... ',\n        wsKey,\n      );\n    });\n    websocketClient.on('reconnected', (data) => {\n      console.log(new Date(), accountRef, 'ws has reconnected ', data?.wsKey);\n    });\n    websocketClient.on('exception', (data) => {\n      console.error(new Date(), accountRef, 'ws exception: ', data);\n    });\n  });\n}\n\n(async () => {\n  try {\n    const onSubscribed = setWsClientEventListeners(wsClient, 'testAccount1');\n\n    wsClient.subscribe(\n      [\n        '/market/match:BTC-USDT',\n        '/spotMarket/tradeOrders',\n        '/spotMarket/tradeOrdersV2',\n        '/account/balance',\n        '/spotMarket/advancedOrders',\n      ],\n      'spotPrivateV1',\n    );\n\n    // Simple promise to ensure we're subscribed before trying anything else\n    await onSubscribed;\n\n    // Start trading\n    const balResponse1 = await restClient.getBalances();\n    console.log('balResponse1: ', JSON.stringify(balResponse1, null, 2));\n  } catch (e) {\n    console.error('request failed: ', e);\n  }\n})();\n",
              "metadata": {}
            }
          ]
        },
        {
          "type": "folder",
          "name": "Rest",
          "path": "examples/Kucoin/Rest",
          "children": [
            {
              "type": "file",
              "name": "rest-futures-orders-guide.ts",
              "path": "examples/Kucoin/Rest/rest-futures-orders-guide.ts",
              "code": "import { FuturesClient } from 'kucoin-api';\n\nasync function start() {\n  const account = {\n    key: 'keyHere',\n    secret: 'secretHere',\n    passphrase: 'memoHere',\n  };\n  const client = new FuturesClient({\n    apiKey: account.key,\n    apiSecret: account.secret,\n    apiPassphrase: account.passphrase,\n  });\n\n  try {\n    /**\n     * =======\n     * Credits for this guide go to user: @DKTradingClient / Code Nerd from the Kucoin API Telegram group!\n     * =======\n\n    /**\n     * Futures are contracts, not currencies. In the futures symbols list you will see a \"multiplier\" field for each of the symbols. \n     * Each contract equals to  Multiplier x Size\n     * For example:  https://api-futures.kucoin.com/api/v1/contracts/XRPUSDTM  - see the \"multiplier\" value.\n     * */\n\n    const symbolInfo = await client.getSymbol({ symbol: 'XRPUSDTM' });\n    const multiplier = symbolInfo.data.multiplier;\n\n    /**\n     * E.g. if multiplier is 10(what you can see from the endpoint), that means each SIZE is 10 XRP. So if XRP is currently at $0.5,\n     * then each 1 contract (size 10) is going to cost $5.00\n     * size = (Funds x leverage) / (price x multiplier)\n     */\n\n    const XRPPriceExample = 0.5;\n    const leverage = 5;\n    const fundsToTradeUSDT = 100;\n\n    const costOfContract = XRPPriceExample * multiplier;\n\n    const size = (fundsToTradeUSDT * leverage) / costOfContract;\n    console.log(`Size: ${size}`);\n\n    /**\n     * The trade amount indicates the amount of contract to buy or sell, and contract uses the base currency or lot as the trading unit.\n     * The trade amount must be no less than 1 lot for the contract and no larger than the maxOrderQty.\n     * It should be a multiple number of the lot, or the system will report an error when you place the order.\n     * E.g. 1 lot of XBTUSDTM is 0.001 Bitcoin, while 1 lot of XBTUSDM is 1 USD.\n     * or check the XRPUSDTM example above.\n     *\n     * Here are function examples using the Futures Create Order endpoint:\n     */\n\n    // A MARKET SHORT of 2 contracts of XBT using leverage of 5:\n    const marketShort = client.submitOrder({\n      clientOid: '123456789',\n      leverage: 5,\n      side: 'sell',\n      size: 2,\n      symbol: 'XBTUSDTM',\n      timeInForce: 'GTC',\n      type: 'market',\n    });\n    console.log('Market short: ', marketShort);\n\n    // A MARKET LONG of 2 contracts of XBT using leverage of 5:\n    const marketLong = client.submitOrder({\n      clientOid: '123456789',\n      leverage: 5,\n      side: 'buy',\n      size: 2,\n      symbol: 'XBTUSDTM',\n      timeInForce: 'GTC',\n      type: 'market',\n    });\n    console.log('Market long: ', marketLong);\n\n    // A LIMIT SHORT of 2 contracts of XBT using leverage of 5:\n    const limitShort = client.submitOrder({\n      clientOid: '123456789',\n      leverage: 5,\n      price: '70300.31',\n      side: 'sell',\n      size: 2,\n      symbol: 'XBTUSDTM',\n      timeInForce: 'GTC',\n      type: 'limit',\n    });\n    console.log('Limit short: ', limitShort);\n\n    // A LIMIT LONG of 2 contracts of XBT using leverage of 5:\n    const limitLong = client.submitOrder({\n      clientOid: '123456789',\n      leverage: 5,\n      price: '40300.31',\n      side: 'buy',\n      size: 2,\n      symbol: 'XBTUSDTM',\n      timeInForce: 'GTC',\n      type: 'limit',\n    });\n    console.log('Limit long: ', limitLong);\n    // On any \"close position\" action, if you specify a SIZE=0 or leave off the SIZE parameter,\n    // then it will close the whole position, regardless of the size.\n    // If you specify a SIZE, it will close only the number of contracts you specify.\n\n    // If closeOrder is set to TRUE,\n    // the system will close the position and the position size will become 0.\n    // Side, Size and Leverage fields can be left empty and the system will determine the side and size automatically.\n\n    // A MARKET CLOSE POSITION example:\n    const marketClose = client.submitOrder({\n      clientOid: '123456789',\n      closeOrder: true,\n      symbol: 'XBTUSDTM',\n      timeInForce: 'GTC',\n      type: 'market',\n      side: 'sell',\n      size: 0,\n    });\n    console.log('Market close: ', marketClose);\n\n    // A LIMIT CLOSE of a LONG example:\n    const limitCloseLong = client.submitOrder({\n      clientOid: '123456789',\n      leverage: 5,\n      price: '70300.31',\n      closeOrder: true,\n      side: 'sell',\n      size: 2,\n      symbol: 'XBTUSDTM',\n      timeInForce: 'GTC',\n      type: 'limit',\n    });\n    console.log('Limit close long: ', limitCloseLong);\n\n    // A LIMIT CLOSE of a SHORT example:\n    const limitCloseShort = client.submitOrder({\n      clientOid: '123456789',\n      leverage: 5,\n      price: '40300.31',\n      closeOrder: true,\n      side: 'buy',\n      size: 2,\n      symbol: 'XBTUSDTM',\n      timeInForce: 'GTC',\n      type: 'limit',\n    });\n    console.log('Limit close short: ', limitCloseShort);\n\n    // A STOP LOSS example for a LONG position:\n    const stopLossLong = client.submitOrder({\n      clientOid: '123456789',\n      closeOrder: true,\n      stop: 'down',\n      side: 'buy',\n      stopPrice: '40200.31',\n      stopPriceType: 'TP',\n      symbol: 'XBTUSDTM',\n      timeInForce: 'GTC',\n      type: 'market',\n    });\n    console.log('Stoploss long: ', stopLossLong);\n\n    // A STOP LOSS example for a SHORT position:\n    const stopLossShort = client.submitOrder({\n      clientOid: '123456789',\n      closeOrder: true,\n      stop: 'up',\n      side: 'sell',\n      stopPrice: '40200.31',\n      stopPriceType: 'TP',\n      symbol: 'XBTUSDTM',\n      timeInForce: 'GTC',\n      type: 'market',\n    });\n\n    console.log('Stoploss short: ', stopLossShort);\n  } catch (e) {\n    console.error('Req error: ', e);\n  }\n}\n\nstart();\n",
              "metadata": {}
            },
            {
              "type": "file",
              "name": "rest-futures-private-trade.ts",
              "path": "examples/Kucoin/Rest/rest-futures-private-trade.ts",
              "code": "import { FuturesClient } from 'kucoin-api';\n\nasync function start() {\n  const account = {\n    key: 'keyHere',\n    secret: 'secretHere',\n    passphrase: 'memoHere',\n  };\n  const client = new FuturesClient({\n    apiKey: account.key,\n    apiSecret: account.secret,\n    apiPassphrase: account.passphrase,\n  });\n\n  try {\n    /**\n     * The trade amount indicates the amount of contract to buy or sell, and contract uses the base currency or lot as the trading unit.\n     * The trade amount must be no less than 1 lot for the contract and no larger than the maxOrderQty.\n     * It should be a multiple number of the lot, or the system will report an error when you place the order.\n     * E.g. 1 lot of XBTUSDTM is 0.001 Bitcoin, while 1 lot of XBTUSDM is 1 USD.\n     */\n\n    // Submit a futures entry order for 1 lot of XBTUSDTM (0.001 bitcoin)\n    const orderRes = await client.submitOrder({\n      clientOid: client.generateNewOrderID(),\n      side: 'buy',\n      type: 'market',\n      symbol: 'XBTUSDTM',\n      size: 1,\n      leverage: 2,\n    });\n\n    console.log('orderRes ', JSON.stringify(orderRes, null, 2));\n  } catch (e) {\n    console.error('Req error: ', e);\n  }\n}\n\nstart();\n",
              "metadata": {}
            },
            {
              "type": "file",
              "name": "rest-futures-public.ts",
              "path": "examples/Kucoin/Rest/rest-futures-public.ts",
              "code": "import { FuturesClient } from 'kucoin-api';\n\nasync function start() {\n  const client = new FuturesClient();\n\n  try {\n    // Fetch all symbols\n    const symbols = await client.getSymbols();\n    console.log('symbols:', JSON.stringify(symbols, null, 2));\n\n    // Fetch ticker for a specific symbol\n    const ticker = await client.getTicker({ symbol: 'XBTUSDM' });\n    console.log('ticker:', JSON.stringify(ticker, null, 2));\n\n    // Fetch klines for a specific symbol\n    const klines = await client.getKlines({\n      symbol: 'XBTUSDM',\n      granularity: 60,\n    });\n    console.log('klines:', JSON.stringify(klines, null, 2));\n  } catch (e) {\n    console.error('Req error: ', e);\n  }\n}\n\nstart();\n",
              "metadata": {}
            },
            {
              "type": "file",
              "name": "rest-spot-private-trade.ts",
              "path": "examples/Kucoin/Rest/rest-spot-private-trade.ts",
              "code": "import { SpotClient } from 'kucoin-api';\n\nasync function start() {\n  const account = {\n    key: 'keyHere',\n    secret: 'secretHere',\n    passphrase: 'memoHere',\n  };\n\n  const client = new SpotClient({\n    apiKey: account.key,\n    apiSecret: account.secret,\n    apiPassphrase: account.passphrase,\n  });\n\n  try {\n    const spotBuyResult = await client.submitHFOrder({\n      clientOid: client.generateNewOrderID(),\n      side: 'buy',\n      type: 'market',\n      symbol: 'BTC-USDT',\n      size: '0.00001',\n    });\n    console.log('spotBuy ', JSON.stringify(spotBuyResult, null, 2));\n\n    const spotSellResult = await client.submitHFOrder({\n      clientOid: client.generateNewOrderID(),\n      side: 'sell',\n      type: 'market',\n      symbol: 'BTC-USDT',\n      size: '0.00001',\n    });\n\n    console.log('spotSellResult ', JSON.stringify(spotSellResult, null, 2));\n  } catch (e) {\n    console.error('Req error: ', e);\n  }\n}\n\nstart();\n",
              "metadata": {}
            },
            {
              "type": "file",
              "name": "rest-spot-public.ts",
              "path": "examples/Kucoin/Rest/rest-spot-public.ts",
              "code": "import { SpotClient } from 'kucoin-api';\n\nasync function start() {\n  const client = new SpotClient();\n\n  try {\n    // Fetch all symbols\n    const symbols = await client.getSymbols();\n    console.log('symbols:', JSON.stringify(symbols, null, 2));\n\n    // Fetch ticker for a specific symbol\n    const ticker = await client.getTicker({ symbol: 'BTC-USDT' });\n    console.log('ticker:', JSON.stringify(ticker, null, 2));\n\n    // Fetch klines for a specific symbol\n    const klines = await client.getKlines({\n      symbol: 'BTC-USDT',\n      type: '1day',\n    });\n    console.log(klines);\n  } catch (e) {\n    console.error('Req error: ', e);\n  }\n}\n\nstart();\n",
              "metadata": {}
            }
          ]
        },
        {
          "type": "folder",
          "name": "WebSockets",
          "path": "examples/Kucoin/WebSockets",
          "children": [
            {
              "type": "folder",
              "name": "WS-API",
              "path": "examples/Kucoin/WebSockets/WS-API",
              "children": [
                {
                  "type": "file",
                  "name": "ws-api-client.ts",
                  "path": "examples/Kucoin/WebSockets/WS-API/ws-api-client.ts",
                  "code": "/**\n * KuCoin WebSocket API Client - Complete Example\n *\n * This example demonstrates all available WebSocket API operations:\n * - Spot trading: submit, modify, cancel, sync operations\n * - Margin trading: submit and cancel orders\n * - Futures trading: submit, cancel, batch operations\n *\n * Usage:\n * Make sure to set your API credentials in environment variables:\n *    - API_KEY\n *    - API_SECRET\n *    - API_PASSPHRASE\n *\n *  or pass them as arguments to the constructor\n */\n\nimport { DefaultLogger, WebsocketAPIClient } from 'kucoin-api';\n\nasync function main() {\n  const customLogger = {\n    ...DefaultLogger,\n    // For a more detailed view of the WebsocketClient, enable the `trace` level by uncommenting the below line:\n    // trace: (...params) => console.log(new Date(), 'trace', ...params),\n  };\n\n  const account = {\n    key: process.env.API_KEY || 'keyHere',\n    secret: process.env.API_SECRET || 'secretHere',\n    passphrase: process.env.API_PASSPHRASE || 'apiPassPhraseHere', // This is NOT your account password\n  };\n\n  const wsClient = new WebsocketAPIClient(\n    {\n      apiKey: account.key,\n      apiSecret: account.secret,\n      apiPassphrase: account.passphrase,\n\n      // If you want your own event handlers instead of the default ones with logs, disable this setting and see the `attachEventHandlers` example below:\n      // attachEventListeners: false\n    },\n    customLogger,\n  );\n\n  // Example usage for each WebSocket API operation\n  console.log('Starting WebSocket API examples...\\n');\n\n  // 1. Submit Spot Order\n  try {\n    console.log('\\n2. Testing submitNewSpotOrder...');\n    const spotOrderResponse = await wsClient.submitNewSpotOrder({\n      side: 'buy',\n      symbol: 'BTC-USDT',\n      type: 'limit',\n      price: '20000', // Very low price to avoid accidental execution\n      size: '0.0001',\n    });\n    console.log('Spot order response:', spotOrderResponse);\n  } catch (e) {\n    console.log('Spot order error:', e);\n  }\n\n  // 2. Submit Sync Spot Order\n  try {\n    console.log('\\n3. Testing submitSyncSpotOrder...');\n    const syncSpotOrderResponse = await wsClient.submitSyncSpotOrder({\n      side: 'buy',\n      symbol: 'BTC-USDT',\n      type: 'limit',\n      price: '1000', // Very high price to avoid accidental execution\n      size: '0.01',\n    });\n    console.log('Sync spot order response:', syncSpotOrderResponse);\n  } catch (e) {\n    console.log('Sync spot order error:', e);\n  }\n\n  // 3. Modify Spot Order (requires existing order ID)\n  try {\n    console.log('\\n4. Testing modifySpotOrder...');\n    const modifyResponse = await wsClient.modifySpotOrder({\n      symbol: 'BTC-USDT',\n      orderId: '68cc3476693c1c00072ef1d9', // Replace with actual order ID\n      newPrice: '2000',\n    });\n    console.log('Modify spot order response:', modifyResponse);\n  } catch (e) {\n    console.log('Modify spot order error:', e);\n  }\n\n  // 4. Cancel Spot Order\n  try {\n    console.log('\\n5. Testing cancelSpotOrder...');\n    const cancelSpotResponse = await wsClient.cancelSpotOrder({\n      symbol: 'BTC-USDT',\n      orderId: '68cc34c6693c1c0007301929', // Replace with actual order ID\n    });\n    console.log('Cancel spot order response:', cancelSpotResponse);\n  } catch (e) {\n    console.log('Cancel spot order error:', e);\n  }\n\n  // 5. Cancel Sync Spot Order\n  try {\n    console.log('\\n6. Testing cancelSyncSpotOrder...');\n    const cancelSyncResponse = await wsClient.cancelSyncSpotOrder({\n      symbol: 'BTC-USDT',\n      orderId: '68cc3530b9870a0007670294', // Replace with actual client order ID\n    });\n    console.log('Cancel sync spot order response:', cancelSyncResponse);\n  } catch (e) {\n    console.log('Cancel sync spot order error:', e);\n  }\n\n  // 6. Submit Margin Order\n  try {\n    console.log('\\n7. Testing submitMarginOrder...');\n    const marginOrderResponse = await wsClient.submitMarginOrder({\n      clientOid: 'margin-test-' + Date.now(),\n      side: 'buy',\n      symbol: 'BTC-USDT',\n      type: 'limit',\n      price: '19000', // Very low price to avoid accidental execution\n      size: '0.0001',\n      isIsolated: false, // false for cross margin, true for isolated\n    });\n    console.log('Margin order response:', marginOrderResponse);\n  } catch (e) {\n    console.log('Margin order error:', e);\n  }\n\n  // 7. Cancel Margin Order\n  try {\n    console.log('\\n8. Testing cancelMarginOrder...');\n    const cancelMarginResponse = await wsClient.cancelMarginOrder({\n      symbol: 'BTC-USDT',\n      orderId: 'your-margin-order-id-here', // Replace with actual order ID\n    });\n    console.log('Cancel margin order response:', cancelMarginResponse);\n  } catch (e) {\n    console.log('Cancel margin order error:', e);\n  }\n\n  // 8. Submit Futures Order\n  try {\n    console.log('\\n9. Testing submitFuturesOrder...');\n    const futuresOrderResponse = await wsClient.submitFuturesOrder({\n      clientOid: 'futures-test-' + Date.now(),\n      side: 'buy',\n      symbol: 'XBTUSDTM',\n      marginMode: 'CROSS',\n      type: 'limit',\n      price: '1000', // Very low price to avoid accidental execution\n      qty: '0.01',\n      leverage: 10,\n      positionSide: 'LONG', // needed if trading two-way (hedge) position mode\n    });\n    console.log('Futures order response:', futuresOrderResponse);\n  } catch (e) {\n    console.log('Futures order error:', e);\n  }\n\n  // 9. Cancel Futures Order\n  try {\n    console.log('\\n10. Testing cancelFuturesOrder...');\n    const cancelFuturesResponse = await wsClient.cancelFuturesOrder({\n      symbol: 'XBTUSDTM',\n      orderId: '358196976308797441', // Replace with actual order ID\n    });\n    console.log('Cancel futures order response:', cancelFuturesResponse);\n  } catch (e) {\n    console.log('Cancel futures order error:', e);\n  }\n\n  // 10. Submit Multiple Futures Orders\n  try {\n    console.log('\\n11. Testing submitMultipleFuturesOrders...');\n    const multiFuturesResponse = await wsClient.submitMultipleFuturesOrders([\n      {\n        clientOid: 'futures-test-1-' + Date.now(),\n        side: 'buy',\n        symbol: 'XBTUSDTM',\n        marginMode: 'CROSS',\n        type: 'limit',\n        price: '1000', // Very low price to avoid accidental execution\n        qty: '0.01',\n        leverage: 10,\n        positionSide: 'LONG', // Needed if trading hedge/two-way mode. Optional in one-way mode.\n      },\n      {\n        clientOid: 'futures-test-2-' + Date.now(),\n        side: 'buy',\n        symbol: 'XBTUSDTM',\n        marginMode: 'CROSS',\n        type: 'limit',\n        price: '1010', // Very low price to avoid accidental execution\n        qty: '0.01',\n        leverage: 10,\n        positionSide: 'LONG',\n      },\n    ]);\n    console.log('Multiple futures orders response:', multiFuturesResponse);\n  } catch (e) {\n    console.log('Multiple futures orders error:', e);\n  }\n\n  // 11. Cancel Multiple Futures Orders\n  try {\n    console.log('\\n12. Testing cancelMultipleFuturesOrders...');\n    const cancelMultiFuturesResponse =\n      await wsClient.cancelMultipleFuturesOrders({\n        orderIdsList: ['order-id-1', 'order-id-2'], // Replace with actual order IDs\n      });\n    console.log(\n      'Cancel multiple futures orders response:',\n      cancelMultiFuturesResponse,\n    );\n  } catch (e) {\n    console.log('Cancel multiple futures orders error:', e);\n  }\n\n  console.log('\\nCompleted all WebSocket API examples!');\n  process.exit(1);\n}\n\n// Start executing the example workflow\nmain();\n",
                  "metadata": {}
                },
                {
                  "type": "file",
                  "name": "ws-api-raw-promises.ts",
                  "path": "examples/Kucoin/WebSockets/WS-API/ws-api-raw-promises.ts",
                  "code": "/* eslint-disable @typescript-eslint/no-unused-vars */\nimport { DefaultLogger, WebsocketClient, WS_KEY_MAP } from 'kucoin-api';\n\nasync function start() {\n  // Optional: inject a custom logger to override internal logging behaviour\n  const logger: DefaultLogger = {\n    ...DefaultLogger,\n    // Uncomment the below callback to introduce filtered trace logging in the WebsocketClient.\n    // trace: (...params) => {\n    //   if (\n    //     [\n    //       'Sending ping',\n    //       // 'Sending upstream ws message: ',\n    //       'Received pong',\n    //     ].includes(params[0])\n    //   ) {\n    //     return;\n    //   }\n    //   console.log('trace', JSON.stringify(params, null, 2));\n    // },\n  };\n\n  const account = {\n    key: process.env.API_KEY || 'keyHere',\n    secret: process.env.API_SECRET || 'secretHere',\n    passphrase: process.env.API_PASSPHRASE || 'apiPassPhraseHere', // This is NOT your account password\n  };\n\n  // console.log('connecting with ', account);\n  const client = new WebsocketClient(\n    {\n      apiKey: account.key,\n      apiSecret: account.secret,\n      apiPassphrase: account.passphrase,\n    },\n    // logger,\n  );\n\n  client.on('open', (data) => {\n    console.log('open: ', data?.wsKey);\n  });\n\n  // Data received\n  client.on('update', (data) => {\n    console.info('data received: ', JSON.stringify(data));\n  });\n\n  // Something happened, attempting to reconenct\n  client.on('reconnect', (data) => {\n    console.log('reconnect: ', data);\n  });\n\n  // Reconnect successful\n  client.on('reconnected', (data) => {\n    console.log('reconnected: ', data);\n  });\n\n  // Connection closed. If unexpected, expect reconnect -> reconnected.\n  client.on('close', (data) => {\n    console.error('close: ', data);\n  });\n\n  // Reply to a request, e.g. \"subscribe\"/\"unsubscribe\"/\"authenticate\"\n  client.on('response', (data) => {\n    // console.info('response: ', data);\n  });\n\n  client.on('exception', (data) => {\n    console.error('exception: ', data);\n  });\n\n  /**\n   *\n   * Raw events can be routed via the sendWSAPIRequest in the WebsocketClient, as shown below.\n   * However, for a simpler integration, it is recommended to use the WebsocketAPIClient. The\n   * WebsocketAPIClient class is a wrapper around sendWSAPIRequest, with clear functions, typed\n   * requests and typed responses. The simpler WSAPIClient interface behaves much like a REST API\n   * wrapper, but all calls are routed via the WebSocket API.\n   *\n   * For a clearer example, refer to the \"ws-api-client.ts\" example found in this folder.\n   */\n  try {\n    const res = await client.sendWSAPIRequest(\n      WS_KEY_MAP.wsApiSpotV1,\n      'spot.order',\n      {\n        side: 'buy',\n        symbol: 'BTC-USDT',\n        type: 'limit',\n        price: '20000', // Very low price to avoid accidental execution\n        size: '0.0001',\n      },\n    );\n    console.log('ws api res: ', res);\n  } catch (e) {\n    console.error('ws api exception: ', e);\n  }\n}\n\nstart();\n",
                  "metadata": {}
                }
              ]
            },
            {
              "type": "file",
              "name": "ws-futures-private.ts",
              "path": "examples/Kucoin/WebSockets/ws-futures-private.ts",
              "code": "import { WebsocketClient } from 'kucoin-api';\n\nasync function start() {\n  // Optional: inject and customise a logger for more control over internal logging\n  // const logger: typeof DefaultLogger = {\n  //   ...DefaultLogger,\n  //   trace: (...params) => {\n  //     if (\n  //       [\n  //         'Sending ping',\n  //         // 'Sending upstream ws message: ',\n  //         'Received pong',\n  //       ].includes(params[0])\n  //     ) {\n  //       return;\n  //     }\n  //     console.log('trace', JSON.stringify(params, null, 2));\n  //   },\n  // };\n\n  const account = {\n    key: process.env.API_KEY || 'keyHere',\n    secret: process.env.API_SECRET || 'secretHere',\n    passphrase: process.env.API_PASSPHRASE || 'apiPassPhraseHere', // This is NOT your account password\n  };\n\n  console.log('connecting with ', account);\n  const client = new WebsocketClient(\n    {\n      apiKey: account.key,\n      apiSecret: account.secret,\n      apiPassphrase: account.passphrase,\n    },\n    // logger,\n  );\n\n  client.on('open', (data) => {\n    console.log('open: ', data?.wsKey);\n  });\n\n  // Data received\n  client.on('update', (data) => {\n    console.info('data received: ', JSON.stringify(data));\n  });\n\n  // Something happened, attempting to reconenct\n  client.on('reconnect', (data) => {\n    console.log('reconnect: ', data);\n  });\n\n  // Reconnect successful\n  client.on('reconnected', (data) => {\n    console.log('reconnected: ', data);\n  });\n\n  // Connection closed. If unexpected, expect reconnect -> reconnected.\n  client.on('close', (data) => {\n    console.error('close: ', data);\n  });\n\n  // Reply to a request, e.g. \"subscribe\"/\"unsubscribe\"/\"authenticate\"\n  client.on('response', (data) => {\n    console.info('response: ', data);\n    // throw new Error('res?');\n  });\n\n  client.on('exception', (data) => {\n    console.error('exception: ', {\n      msg: data.msg,\n      errno: data.errno,\n      code: data.code,\n      syscall: data.syscall,\n      hostname: data.hostname,\n    });\n  });\n\n  try {\n    // Optional: await a connection to be ready before subscribing (this is not necessary)\n    // await client.connect('futuresPrivateV1');\n    // console.log('connected');\n\n    /**\n     * For more detailed usage info, refer to the ws-spot-public.ts example.\n     *\n     * Below are some examples for subscribing to private futures websockets.\n     * Note: all \"private\" websocket topics should use the \"futuresPrivateV1\" wsKey.\n     */\n    client.subscribe(\n      [\n        '/contractMarket/tradeOrders:XBTUSDM',\n        '/contractMarket/tradeOrders',\n        '/contractMarket/advancedOrders',\n        '/contractAccount/wallet',\n        '/contract/position:XBTUSDM',\n        '/contract/positionAll',\n      ],\n      'futuresPrivateV1',\n    );\n  } catch (e) {\n    console.error('Subscribe exception: ', e);\n  }\n}\n\nstart();\n",
              "metadata": {}
            },
            {
              "type": "file",
              "name": "ws-futures-public.ts",
              "path": "examples/Kucoin/WebSockets/ws-futures-public.ts",
              "code": "/* eslint-disable @typescript-eslint/no-unused-vars */\nimport { WebsocketClient } from 'kucoin-api';\n\nasync function start() {\n  // Optional: fully customise the logging experience by injecting a custom logger\n  // const logger: typeof DefaultLogger = {\n  //   ...DefaultLogger,\n  //   trace: (...params) => {\n  //     if (\n  //       [\n  //         'Sending ping',\n  //         'Sending upstream ws message: ',\n  //         'Received pong',\n  //       ].includes(params[0])\n  //     ) {\n  //       return;\n  //     }\n  //     console.log('trace', params);\n  //   },\n  // };\n\n  // const client = new WebsocketClient({}, logger);\n  const client = new WebsocketClient();\n\n  client.on('open', (data) => {\n    console.log('open: ', data?.wsKey);\n  });\n\n  // Data received\n  client.on('update', (data) => {\n    console.info('data received: ', JSON.stringify(data));\n  });\n\n  // Something happened, attempting to reconenct\n  client.on('reconnect', (data) => {\n    console.log('reconnect: ', data);\n  });\n\n  // Reconnect successful\n  client.on('reconnected', (data) => {\n    console.log('reconnected: ', data);\n  });\n\n  // Connection closed. If unexpected, expect reconnect -> reconnected.\n  client.on('close', (data) => {\n    console.error('close: ', data);\n  });\n\n  // Reply to a request, e.g. \"subscribe\"/\"unsubscribe\"/\"authenticate\"\n  client.on('response', (data) => {\n    console.info('response: ', data);\n    // throw new Error('res?');\n  });\n\n  client.on('exception', (data) => {\n    console.error('exception: ', {\n      msg: data.msg,\n      errno: data.errno,\n      code: data.code,\n      syscall: data.syscall,\n      hostname: data.hostname,\n    });\n  });\n\n  try {\n    // Optional: await a connection to be ready before subscribing (this is not necessary)\n    // await client.connect('futuresPublicV1');\n\n    /**\n     * Examples for public futures websocket topics (that don't require authentication).\n     *\n     * These should all subscribe via the \"futuresPublicV1\" wsKey. For detailed usage, refer to the ws-spot-public.ts example.\n     */\n    client.subscribe(\n      [\n        '/contractMarket/tickerV2:XBTUSDM',\n        '/contractMarket/ticker:XBTUSDM',\n        '/contractMarket/level2:XBTUSDM',\n        '/contractMarket/execution:XBTUSDM',\n        '/contractMarket/level2Depth5:XBTUSDM',\n        '/contractMarket/level2Depth50:XBTUSDM',\n        '/contractMarket/limitCandle:XBTUSDTM_1hour',\n        '/contract/instrument:XBTUSDM',\n        '/contract/announcement',\n        '/contractMarket/snapshot:XBTUSDM',\n      ],\n      'futuresPublicV1',\n    );\n  } catch (e) {\n    console.error('Subscribe exception: ', e);\n  }\n}\n\nstart();\n",
              "metadata": {}
            },
            {
              "type": "file",
              "name": "ws-spot-private.ts",
              "path": "examples/Kucoin/WebSockets/ws-spot-private.ts",
              "code": "import { WebsocketClient } from 'kucoin-api';\n// import { DefaultLogger, WebsocketClient } from 'kucoin-api';\n\nasync function start() {\n  // Optional: inject a custom logger to override internal logging behaviour\n  // const logger: typeof DefaultLogger = {\n  //   ...DefaultLogger,\n  //   trace: (...params) => {\n  //     if (\n  //       [\n  //         'Sending ping',\n  //         // 'Sending upstream ws message: ',\n  //         'Received pong',\n  //       ].includes(params[0])\n  //     ) {\n  //       return;\n  //     }\n  //     console.log('trace', JSON.stringify(params, null, 2));\n  //   },\n  // };\n\n  const account = {\n    key: process.env.API_KEY || 'keyHere',\n    secret: process.env.API_SECRET || 'secretHere',\n    passphrase: process.env.API_PASSPHRASE || 'apiPassPhraseHere', // This is NOT your account password\n  };\n\n  console.log('connecting with ', account);\n  const client = new WebsocketClient(\n    {\n      apiKey: account.key,\n      apiSecret: account.secret,\n      apiPassphrase: account.passphrase,\n    },\n    // logger,\n  );\n\n  client.on('open', (data) => {\n    console.log('open: ', data?.wsKey);\n  });\n\n  // Data received\n  client.on('update', (data) => {\n    console.info('data received: ', JSON.stringify(data));\n  });\n\n  // Something happened, attempting to reconenct\n  client.on('reconnect', (data) => {\n    console.log('reconnect: ', data);\n  });\n\n  // Reconnect successful\n  client.on('reconnected', (data) => {\n    console.log('reconnected: ', data);\n  });\n\n  // Connection closed. If unexpected, expect reconnect -> reconnected.\n  client.on('close', (data) => {\n    console.error('close: ', data);\n  });\n\n  // Reply to a request, e.g. \"subscribe\"/\"unsubscribe\"/\"authenticate\"\n  client.on('response', (data) => {\n    console.info('response: ', data);\n    // throw new Error('res?');\n  });\n\n  client.on('exception', (data) => {\n    console.error('exception: ', {\n      msg: data.msg,\n      errno: data.errno,\n      code: data.code,\n      syscall: data.syscall,\n      hostname: data.hostname,\n    });\n  });\n\n  try {\n    // Optional: await a connection to be ready before subscribing (this is not necessary)\n    // await client.connect('spotPrivateV1');\n    // console.log('connected');\n\n    /**\n     * For more detailed usage info, refer to the ws-spot-public.ts example.\n     *\n     * Below are some examples for subscribing to private spot & margin websockets.\n     * Note: all \"private\" websocket topics should use the \"spotPrivateV1\" wsKey.\n     */\n    client.subscribe(\n      [\n        '/market/match:BTC-USDT',\n        '/spotMarket/tradeOrders',\n        '/spotMarket/tradeOrdersV2',\n        '/account/balance',\n        '/spotMarket/advancedOrders',\n      ],\n      'spotPrivateV1',\n    );\n\n    /**\n     * Other margin websocket topics, which also use the \"spotPrivateV1\" WsKey:\n     */\n    client.subscribe(\n      [\n        '/margin/position',\n        '/margin/isolatedPosition:BTC-USDT',\n        '/spotMarket/advancedOrders',\n      ],\n      'spotPrivateV1',\n    );\n  } catch (e) {\n    console.error('Subscribe exception: ', e);\n  }\n}\n\nstart();\n",
              "metadata": {}
            },
            {
              "type": "file",
              "name": "ws-spot-public.ts",
              "path": "examples/Kucoin/WebSockets/ws-spot-public.ts",
              "code": "/* eslint-disable @typescript-eslint/no-unused-vars */\nimport { WebsocketClient, WsTopicRequest } from 'kucoin-api';\n\nasync function start() {\n  // Optional: fully customise the logging experience by injecting a custom logger\n  // const logger: typeof DefaultLogger = {\n  //   ...DefaultLogger,\n  //   trace: (...params) => {\n  //     if (\n  //       [\n  //         'Sending ping',\n  //         'Sending upstream ws message: ',\n  //         'Received pong',\n  //       ].includes(params[0])\n  //     ) {\n  //       return;\n  //     }\n  //     console.log('trace', params);\n  //   },\n  // };\n\n  // const client = new WebsocketClient({}, logger);\n  const client = new WebsocketClient();\n\n  client.on('open', (data) => {\n    console.log('open: ', data?.wsKey);\n  });\n\n  // Data received\n  client.on('update', (data) => {\n    console.info('data received: ', JSON.stringify(data));\n  });\n\n  // Something happened, attempting to reconenct\n  client.on('reconnect', (data) => {\n    console.log('reconnect: ', data);\n  });\n\n  // Reconnect successful\n  client.on('reconnected', (data) => {\n    console.log('reconnected: ', data);\n  });\n\n  // Connection closed. If unexpected, expect reconnect -> reconnected.\n  client.on('close', (data) => {\n    console.error('close: ', data);\n  });\n\n  // Reply to a request, e.g. \"subscribe\"/\"unsubscribe\"/\"authenticate\"\n  client.on('response', (data) => {\n    console.info('response: ', data);\n    // throw new Error('res?');\n  });\n\n  client.on('exception', (data) => {\n    console.error('exception: ', {\n      msg: data.msg,\n      errno: data.errno,\n      code: data.code,\n      syscall: data.syscall,\n      hostname: data.hostname,\n    });\n  });\n\n  try {\n    // Optional: await a connection to be ready before subscribing (this is not necessary)\n    // await client.connect('spotPublicV1');\n\n    /**\n     * Use the client subscribe(topic, market) pattern to subscribe to any websocket topic.\n     *\n     * You can subscribe to topics one at a time or many one one request. Topics can be sent as simple strings:\n     *\n     */\n    client.subscribe('/market/ticker:BTC-USDT,ETH-USDT', 'spotPublicV1');\n    client.subscribe('/market/snapshot:KCS-BTC', 'spotPublicV1');\n\n    /**\n     * Or, as an array of simple strings\n     *\n     */\n    client.subscribe(\n      ['/market/ticker:BTC-USDT,ETH-USDT', '/market/snapshot:KCS-BTC'],\n      'spotPublicV1',\n    );\n\n    /**\n     * Or send a more structured object with parameters\n     *\n     */\n    const subRequest: WsTopicRequest = {\n      topic: '/market/ticker:BTC-USDT',\n      /** Anything in the payload will be merged into the subscribe \"request\", allowing you to send misc parameters supported by the exchange.\n       *    For more info on parameters, see: https://www.kucoin.com/docs/websocket/basic-info/subscribe/introduction\n       */\n      payload: {\n        id: 123456,\n        response: false,\n      },\n    };\n    client.subscribe(subRequest, 'spotPublicV1');\n\n    /**\n     * Or, send an array of structured objects with parameters, if you wanted to send multiple in one request\n     *\n     */\n    // client.subscribe([subRequest1, subRequest2, etc], 'spotPublicV1');\n\n    /**\n     * Other spot websocket topics:\n     */\n    client.subscribe(\n      [\n        '/market/ticker:BTC-USDT,ETH-USDT',\n        '/market/ticker:all',\n        '/market/snapshot:KCS-BTC',\n        '/market/snapshot:BTC',\n        '/spotMarket/level1:BTC-USDT,ETH-USDT',\n        '/market/level2:BTC-USDT,ETH-USDT',\n        '/spotMarket/level2Depth5:BTC-USDT,ETH-USDT',\n        '/spotMarket/level2Depth50:BTC-USDT,ETH-USDT',\n        '/market/candles:BTC-USDT_1hour',\n        '/market/match:BTC-USDT,ETH-USDT',\n      ],\n      'spotPublicV1',\n    );\n\n    /**\n     * Other margin websocket topics, which also use the \"spotPublicV1\" WsKey:\n     */\n    client.subscribe(\n      [\n        '/indicator/index:USDT-BTC,ETH-USDT',\n        '/indicator/markPrice:USDT-BTC,ETH-USDT',\n      ],\n      'spotPublicV1',\n    );\n  } catch (e) {\n    console.error('Subscribe exception: ', e);\n  }\n}\n\nstart();\n",
              "metadata": {}
            }
          ]
        }
      ]
    },
    {
      "type": "folder",
      "name": "OKX",
      "path": "examples/OKX",
      "children": [
        {
          "type": "folder",
          "name": "Auth",
          "path": "examples/OKX/Auth",
          "children": [
            {
              "type": "file",
              "name": "fasterHmacSign.ts",
              "path": "examples/OKX/Auth/fasterHmacSign.ts",
              "code": "import { createHmac } from 'crypto';\nimport { DefaultLogger, RestClient, WebsocketClient } from 'okx-api';\n\n/**\n * Injecting a custom signMessage function.\n *\n * As of version 3.0.0 of the okx-api Node.js/TypeScript/JavaScript\n * SDK for OKX, the SDK uses the Web Crypto API for signing requests.\n * While it is compatible with Node and Browser environments, it is\n * slightly slower than using Node's native crypto module (only\n * available in backend Node environments).\n *\n * For latency sensitive users, you can inject the previous node crypto sign\n * method (or your own even faster implementation), if this change affects you.\n *\n * This example demonstrates how to inject a custom sign function, to achieve\n * the same peformance as seen before the Web Crypto API was introduced.\n *\n * For context on standard usage, the \"signMessage\" function is used:\n * - During every single API call\n * - After opening a new private WebSocket connection\n */\n\nconst API_KEY = process.env.API_KEY_COM;\nconst API_SECRET = process.env.API_SECRET_COM;\nconst API_PASS = process.env.API_PASS_COM;\n\n// If running from CLI in unix, you can pass env vars as such:\n// API_KEY_COM='lkm12n3-2ba3-1mxf-fn13-lkm12n3a' API_SECRET_COM='035B2B9637E1BDFFEE2646BFBDDB8CE4' API_PASSPHRASE_COM='ComplexPa$$!23$5^' ts-node examples/rest-private-trade.ts\n\n// note the single quotes, preventing special characters such as $ from being incorrectly passed\n\nconst restClient = new RestClient({\n  apiKey: API_KEY,\n  // apiKey: 'apiKeyHere',\n  apiSecret: API_SECRET,\n  // apiSecret: 'apiSecretHere',\n  apiPass: API_PASS,\n  // apiPass: 'apiPassHere',\n  /**\n   * Overkill in almost every case, but if you need any optimisation available,\n   * you can inject a faster sign mechanism such as node's native createHmac:\n   */\n  customSignMessageFn: async (message, secret) => {\n    return createHmac('sha256', secret).update(message).digest('hex');\n  },\n});\n\n// Optional, uncomment the \"trace\" override to log a lot more info about what the WS client is doing\nconst customLogger = {\n  ...DefaultLogger,\n  // trace: (...params) => console.log('trace', ...params),\n};\n\nconst wsClient = new WebsocketClient(\n  {\n    accounts: [\n      // For private topics, include one or more accounts in an array. Otherwise only public topics will work\n      {\n        apiKey: API_KEY || '',\n        apiSecret: API_SECRET || '',\n        apiPass: API_PASS || '',\n      },\n    ],\n    /**\n     * Overkill in almost every case, but if you need any optimisation available,\n     * you can inject a faster sign mechanism such as node's native createHmac:\n     */\n    customSignMessageFn: async (message, secret) => {\n      return createHmac('sha256', secret).update(message).digest('hex');\n    },\n  },\n  customLogger,\n);\n\nfunction setWsClientEventListeners(\n  websocketClient: WebsocketClient,\n  accountRef: string,\n): Promise<void> {\n  return new Promise(() => {\n    websocketClient.on('update', (data) => {\n      console.log(new Date(), accountRef, 'data ', JSON.stringify(data));\n      // console.log('raw message received ', JSON.stringify(data, null, 2));\n    });\n\n    websocketClient.on('open', (data) => {\n      console.log(\n        new Date(),\n        accountRef,\n        'connection opened open:',\n        data.wsKey,\n      );\n    });\n    websocketClient.on('response', (data) => {\n      console.log(\n        new Date(),\n        accountRef,\n        'log response: ',\n        JSON.stringify(data, null, 2),\n      );\n    });\n    websocketClient.on('reconnect', ({ wsKey }) => {\n      console.log(\n        new Date(),\n        accountRef,\n        'ws automatically reconnecting.... ',\n        wsKey,\n      );\n    });\n    websocketClient.on('reconnected', (data) => {\n      console.log(new Date(), accountRef, 'ws has reconnected ', data?.wsKey);\n    });\n    websocketClient.on('exception', (data) => {\n      console.error(new Date(), accountRef, 'ws exception: ', data);\n    });\n  });\n}\n\n(async () => {\n  try {\n    const onSubscribed = setWsClientEventListeners(wsClient, 'demoAcc');\n\n    wsClient.subscribe({\n      channel: 'account',\n    });\n\n    // Simple promise to ensure we're subscribed before trying anything else\n    await onSubscribed;\n\n    // Start trading\n    const balResponse1 = await restClient.getBalances();\n    console.log('balResponse1: ', JSON.stringify(balResponse1, null, 2));\n  } catch (e) {\n    console.error('request failed: ', e);\n  }\n})();\n",
              "metadata": {}
            }
          ]
        },
        {
          "type": "folder",
          "name": "Rest",
          "path": "examples/OKX/Rest",
          "children": [
            {
              "type": "file",
              "name": "app.okx.com.ts",
              "path": "examples/OKX/Rest/app.okx.com.ts",
              "code": "import { RestClient, WebsocketClient } from 'okx-api';\n\nconst client = new RestClient({\n  /**\n   * To use \"app.okx.com\", set market to \"US\"\n   *\n   * Note: your available functionality may differ, refer to the corresponding API docs for more details:\n   * https://app.okx.com/docs-v5/en/#overview-production-trading-services\n   */\n  market: 'US',\n});\n\nconst wsClient = new WebsocketClient({\n  market: 'US',\n});\n\n/**\n * This is a simple script wrapped in a immediately invoked function expression, designed to make public API calls without credentials\n */\n(async () => {\n  try {\n    const results = await client.getInstruments({ instType: 'SPOT' });\n\n    console.log(\n      'result: ',\n      results.filter((row) => row.baseCcy === 'SUI'),\n    );\n  } catch (e) {\n    console.error('request failed: ', e);\n  }\n\n  // Raw data will arrive on the 'update' event\n  wsClient.on('update', (data) => {\n    // console.log(\n    //   new Date(),\n    //   'ws update (raw data received)',\n    //   JSON.stringify(data, null, 2),\n    // );\n    // console.log('ws update (raw data received)', JSON.stringify(data, null, 2));\n    console.log(\n      new Date(),\n      'ws update (raw data received)',\n      JSON.stringify(data),\n    );\n  });\n  wsClient.on('open', (data) => {\n    console.log('ws connection opened open:', data.wsKey);\n  });\n  wsClient.on('reconnected', (data) => {\n    console.log('ws has reconnected ', data?.wsKey);\n  });\n  wsClient.on('exception', (data) => {\n    console.error('ws exception: ', data);\n  });\n  wsClient.subscribe([\n    {\n      channel: 'instruments',\n      instType: 'SPOT',\n    },\n    {\n      channel: 'tickers',\n      instId: 'ETH-BTC',\n    },\n  ]);\n})();\n",
              "metadata": {}
            },
            {
              "type": "file",
              "name": "demo-trading.ts",
              "path": "examples/OKX/Rest/demo-trading.ts",
              "code": "import { RestClient, WebsocketClient } from 'okx-api';\n\n// read from environmental variables, your demo trading keys\nconst API_KEY = process.env.API_KEY_COM;\nconst API_SECRET = process.env.API_SECRET_COM;\nconst API_PASS = process.env.API_PASSPHRASE_COM;\n\nif (!API_KEY || !API_SECRET || !API_PASS) {\n  throw new Error(\n    'Missing api credentials. Use environmental variables or hard code in the script',\n  );\n}\n\nconst demoRestClient = new RestClient({\n  // okx api credentials\n  apiKey: API_KEY,\n  apiSecret: API_SECRET,\n  apiPass: API_PASS,\n  demoTrading: true,\n});\n\nconst demoWsClient = new WebsocketClient({\n  demoTrading: true,\n  accounts: [\n    {\n      apiKey: API_KEY,\n      apiSecret: API_SECRET,\n      apiPass: API_PASS,\n    },\n  ],\n});\n\n// Raw data will arrive on the 'update' event\ndemoWsClient.on('update', (data) => {\n  // console.log('ws update (raw data received)', JSON.stringify(data, null, 2));\n  console.log('ws update (raw data received)', JSON.stringify(data));\n});\n\ndemoWsClient.on('open', (data) => {\n  console.log('connection opened open:', data.wsKey);\n});\n\n// Replies (e.g. authenticating or subscribing to channels) will arrive on the 'response' event\ndemoWsClient.on('response', (data) => {\n  // console.log('ws response: ', JSON.stringify(data, null, 2));\n  console.log('ws response: ', JSON.stringify(data));\n});\n\ndemoWsClient.on('reconnect', ({ wsKey }) => {\n  console.log('ws automatically reconnecting.... ', wsKey);\n});\ndemoWsClient.on('reconnected', (data) => {\n  console.log('ws has reconnected ', data?.wsKey);\n});\ndemoWsClient.on('exception', (data) => {\n  console.error('ws exception: ', data);\n});\n\n// Subscribe to demo account events:\ndemoWsClient.subscribe([\n  {\n    channel: 'account',\n  },\n  {\n    channel: 'positions',\n    instType: 'ANY',\n  },\n]);\n\n(async () => {\n  try {\n    const balResponse1 = await demoRestClient.getBalance({\n      ccy: 'USDT',\n    });\n    console.log('balResponse1: ', JSON.stringify(balResponse1, null, 2));\n\n    /** Simple examples for private REST API calls with bybit's V5 REST APIs */\n    const response = await demoRestClient.getPositions({\n      instType: 'SPOT',\n    });\n\n    console.log('response:', response);\n\n    // Trade USDT linear perps\n    const buyOrderResult = await demoRestClient.submitOrder({\n      instId: 'BTC-USDT',\n      ordType: 'market',\n      side: 'buy',\n      sz: '0.002',\n      tdMode: 'cash',\n      tgtCcy: 'base_ccy',\n    });\n    console.log('buyOrderResult:', buyOrderResult);\n\n    const sellOrderResult = await demoRestClient.submitOrder({\n      instId: 'BTC-USDT',\n      ordType: 'market',\n      side: 'sell',\n      sz: '0.002',\n      tdMode: 'cash',\n      tgtCcy: 'base_ccy',\n    });\n    console.log('sellOrderResult:', sellOrderResult);\n\n    const balResponse2 = await demoRestClient.getBalance({\n      ccy: 'USDT',\n    });\n    console.log('balResponse2: ', JSON.stringify(balResponse2, null, 2));\n  } catch (e) {\n    console.error('request failed: ', e);\n  }\n})();\n",
              "metadata": {}
            },
            {
              "type": "file",
              "name": "my.okx.com.ts",
              "path": "examples/OKX/Rest/my.okx.com.ts",
              "code": "import { RestClient, WebsocketClient } from 'okx-api';\n\nconst client = new RestClient({\n  /**\n   * To use \"my.okx.com\", set market to \"EEA\"\n   *\n   * Note: your available functionality may differ, refer to the corresponding API docs for more details:\n   * https://my.okx.com/docs-v5/en/#overview-production-trading-services\n   */\n  market: 'EEA',\n});\n\nconst wsClient = new WebsocketClient({\n  market: 'EEA',\n});\n\nasync function start() {\n  try {\n    const results = await client.getInstruments({ instType: 'SPOT' });\n\n    console.log(\n      'result: ',\n      results.filter((row) => row.baseCcy === 'SUI'),\n    );\n  } catch (e) {\n    console.error('request failed: ', e);\n  }\n\n  // Raw data will arrive on the 'update' event\n  wsClient.on('update', (data) => {\n    // console.log(\n    //   new Date(),\n    //   'ws update (raw data received)',\n    //   JSON.stringify(data, null, 2),\n    // );\n    // console.log('ws update (raw data received)', JSON.stringify(data, null, 2));\n    console.log(\n      new Date(),\n      'ws update (raw data received)',\n      JSON.stringify(data),\n    );\n  });\n  wsClient.on('open', (data) => {\n    console.log('ws connection opened open:', data.wsKey);\n  });\n  wsClient.on('reconnected', (data) => {\n    console.log('ws has reconnected ', data?.wsKey);\n  });\n  wsClient.on('exception', (data) => {\n    console.error('ws exception: ', data);\n  });\n  wsClient.subscribe([\n    {\n      channel: 'instruments',\n      instType: 'SPOT',\n    },\n    {\n      channel: 'tickers',\n      instId: 'ETH-BTC',\n    },\n  ]);\n}\n\nstart();\n",
              "metadata": {}
            },
            {
              "type": "file",
              "name": "rest-private-trade-market.ts",
              "path": "examples/OKX/Rest/rest-private-trade-market.ts",
              "code": "import { OrderRequest, RestClient } from 'okx-api';\n\n// or\n// import { RestClient, OrderRequest } from 'okx-api';\n\n// read from environmental variables\nconst API_KEY = process.env.API_KEY_COM;\nconst API_SECRET = process.env.API_SECRET_COM;\nconst API_PASS = process.env.API_PASSPHRASE_COM;\n\n// If running from CLI in unix, you can pass env vars as such:\n// API_KEY_COM='lkm12n3-2ba3-1mxf-fn13-lkm12n3a' API_SECRET_COM='035B2B9637E1BDFFEE2646BFBDDB8CE4' API_PASSPHRASE_COM='ComplexPa$$!23$5^' ts-node examples/rest-private-trade-market.ts\n\n// note the single quotes, preventing special characters such as $ from being incorrectly passed\n\nif (!API_KEY || !API_SECRET || !API_PASS) {\n  throw new Error(\n    'Missing api credentials. Use environmental variables or hard code in the script',\n  );\n}\n\nconsole.log(new Date(), 'Using credentials: ', {\n  API_KEY,\n  API_SECRET,\n  API_PASS,\n});\n\nconst client = new RestClient({\n  apiKey: API_KEY,\n  // apiKey: 'apiKeyHere',\n  apiSecret: API_SECRET,\n  // apiSecret: 'apiSecretHere',\n  apiPass: API_PASS,\n  // apiPass: 'apiPassHere',\n});\n\n/** Get available balance for an asset */\nasync function getAssetBalance(\n  client: RestClient,\n  coin: string,\n): Promise<number | null> {\n  const allBalances = await client.getBalance();\n  const usdtBalanceResult = allBalances[0].details.find(\n    (bal) => bal.ccy === coin,\n  );\n\n  const usdtBalance = Number(usdtBalanceResult?.availBal);\n  if (!usdtBalanceResult || !usdtBalance || isNaN(usdtBalance)) {\n    return null;\n  }\n\n  return usdtBalance;\n}\n\n/**\n * This is a simple REST API demo script wrapped in a immediately invoked function expression. The logic below will immediately execute if you run this script.\n *\n * It is designed to:\n * - check for any available USDT balance\n * - immediately use half the balance to buy bitcoin (in spot)\n * - check the available BTC balance\n * - immediately sell all available BTC back to USDT\n */\n(async () => {\n  try {\n    const usdtBalance = await getAssetBalance(client, 'USDT');\n    if (!usdtBalance) {\n      console.error('No USDT to trade');\n      return;\n    }\n\n    console.log(`USDT available: ${usdtBalance}`);\n\n    const symbol = 'BTC-USDT';\n    const percentBalanceToUse = 50;\n\n    const quantity = usdtBalance * (percentBalanceToUse / 100);\n    const buyOrder: OrderRequest = {\n      instId: symbol,\n      ordType: 'market',\n      side: 'buy',\n      sz: String(quantity),\n      tdMode: 'cash',\n      tgtCcy: 'base_ccy',\n    };\n\n    console.log('submitting buy order:', buyOrder);\n    const buyResult = await client.submitOrder(buyOrder);\n\n    console.log('buy order result: ', buyResult, '\\n\\n');\n\n    const btcBalance = await getAssetBalance(client, 'BTC');\n    if (!btcBalance) {\n      console.error('No BTC to trade');\n      return;\n    }\n\n    console.log(`BTC available: ${btcBalance}`);\n    const sellOrder: OrderRequest = {\n      instId: symbol,\n      ordType: 'market',\n      side: 'sell',\n      sz: String(btcBalance),\n      tdMode: 'cash',\n      tgtCcy: 'base_ccy',\n    };\n\n    console.log('submitting sell order:', sellOrder);\n    const sellResult = await client.submitOrder(sellOrder);\n\n    console.log('sell order result: ', sellResult, '\\n\\n');\n    const usdtBalanceFinal = await getAssetBalance(client, 'USDT');\n\n    console.log('final balance: ', usdtBalanceFinal);\n  } catch (e) {\n    console.error('request failed: ', e);\n  }\n})();\n",
              "metadata": {}
            },
            {
              "type": "file",
              "name": "rest-private-trade.ts",
              "path": "examples/OKX/Rest/rest-private-trade.ts",
              "code": "import { OrderRequest, RestClient } from 'okx-api';\n\n// read from environmental variables\nconst API_KEY = process.env.API_KEY_COM;\nconst API_SECRET = process.env.API_SECRET_COM;\nconst API_PASS = process.env.API_PASS_COM;\n\n// If running from CLI in unix, you can pass env vars as such:\n// API_KEY_COM='lkm12n3-2ba3-1mxf-fn13-lkm12n3a' API_SECRET_COM='035B2B9637E1BDFFEE2646BFBDDB8CE4' API_PASSPHRASE_COM='ComplexPa$$!23$5^' ts-node examples/rest-private-trade.ts\n\n// note the single quotes, preventing special characters such as $ from being incorrectly passed\n\nif (!API_KEY || !API_SECRET || !API_PASS) {\n  throw new Error(\n    'Missing api credentials. Use environmental variables or hard code in the script',\n  );\n}\n\nconsole.log(new Date(), 'Using credentials: ', {\n  API_KEY,\n  API_SECRET,\n  API_PASS,\n});\n\nconst client = new RestClient({\n  apiKey: API_KEY,\n  // apiKey: 'apiKeyHere',\n  apiSecret: API_SECRET,\n  // apiSecret: 'apiSecretHere',\n  apiPass: API_PASS,\n  // apiPass: 'apiPassHere',\n});\n\n// const wsClient = new WebsocketClient({\n//   apiKey: API_KEY,\n//   apiSecret: API_SECRET,\n//   apiPass: API_PASS,\n// });\n\n/* eslint-disable @typescript-eslint/no-unused-vars */\nfunction logWSEvent(type: string, data: any) {\n  console.log(new Date(), `WS ${type} event: `, data);\n}\n\n// simple sleep function\nfunction promiseSleep(milliseconds: number) {\n  return new Promise((resolve) => setTimeout(resolve, milliseconds));\n}\n\n// WARNING: for sensitive math you should be using a library such as decimal.js!\n/* eslint-disable @typescript-eslint/no-unused-vars */\nfunction roundDown(value: string, decimals: number) {\n  return Number(\n    Math.floor(parseFloat(value + 'e' + decimals)) + 'e-' + decimals,\n  );\n}\n\n/** This is a simple script wrapped in a immediately invoked function expression, designed to check for any available BTC balance and immediately sell the full amount for USDT */\n(async () => {\n  try {\n    // // Add event listeners to log websocket events on account\n    // wsClient.on('update', (data) => logWSEvent('update', data));\n    // wsClient.on('open', (data) => logWSEvent('open', data));\n    // wsClient.on('response', (data) => logWSEvent('response', data));\n    // wsClient.on('reconnect', (data) => logWSEvent('reconnect', data));\n    // wsClient.on('reconnected', (data) => logWSEvent('reconnected', data));\n    // wsClient.on('authenticated', (data) => logWSEvent('authenticated', data));\n    // wsClient.on('exception', (data) => logWSEvent('exception', data));\n\n    // // Subscribe to private account topics\n    // wsClient.subscribeTopic('SPBL', 'account');\n    // wsClient.subscribeTopic('SPBL', 'orders');\n\n    // wait briefly for ws to be ready (could also use the response or authenticated events, to make sure topics are subscribed to before starting)\n    await promiseSleep(2.5 * 1000);\n\n    const allBalances = await client.getBalance();\n    // const balances = allBalances.filter((bal) => Number(bal.available) != 0);\n    const usdtBalanceResult = allBalances[0].details.find(\n      (bal) => bal.ccy === 'USDT',\n    );\n    console.log('BTC balance result: ', usdtBalanceResult);\n\n    const usdtBalance = Number(usdtBalanceResult?.availBal);\n    // console.log('balance: ', JSON.stringify(balances, null, 2));\n\n    if (!usdtBalanceResult || !usdtBalance) {\n      console.error('No USDT to trade');\n      return;\n    }\n\n    console.log(`USDT available: ${usdtBalance}`);\n\n    const symbol = 'BTC-USDT';\n    const quantity = 0.002;\n\n    const order: OrderRequest = {\n      instId: symbol,\n      ordType: 'market',\n      side: 'buy',\n      sz: String(usdtBalance * 0.5),\n      tdMode: 'cash',\n      tgtCcy: 'base_ccy',\n    };\n\n    const buyResult = await client.submitOrder(order);\n\n    console.log('result: ', buyResult);\n    return;\n    // example to find minimum allowed size for a symbol and place an order with it\n    /*  const symbol = 'BTC-USDT-SWAP';\n\n    const symbolsResult = await client.getInstruments({\n      instType: 'SWAP',\n    });\n    const btcRules = symbolsResult.find((rule) => rule.instId === symbol);\n    console.log('btc trading rules: ', btcRules);\n    if (!btcRules) {\n      return console.log('no rules found for trading ' + symbol);\n    }\n\n    const minSize = Number(btcRules.minSz);\n\n    const order = {\n      instId: symbol,\n      tdMode: 'cross',\n      ordType: 'market',\n      side: 'sell',\n      sz: String(minSize),\n    } as const;\n\n    console.log('submitting order: ', order);\n\n    const sellResult = await client.submitOrder(order);\n\n    console.log('sell result: ', sellResult); */\n  } catch (e) {\n    console.error('request failed: ', e);\n  }\n})();\n",
              "metadata": {}
            },
            {
              "type": "file",
              "name": "rest-public.ts",
              "path": "examples/OKX/Rest/rest-public.ts",
              "code": "import { RestClient } from 'okx-api';\n\nconst client = new RestClient();\n\n/**\n * This is a simple script wrapped in a immediately invoked function expression, designed to make public API calls without credentials\n */\n(async () => {\n  try {\n    const results = await client.getInstruments({ instType: 'SPOT' });\n\n    console.log(\n      'result: ',\n      results.filter((row) => row.baseCcy === 'SUI'),\n    );\n\n    return;\n  } catch (e) {\n    console.error('request failed: ', e);\n  }\n})();\n",
              "metadata": {}
            }
          ]
        },
        {
          "type": "folder",
          "name": "Websocket",
          "path": "examples/OKX/Websocket",
          "children": [
            {
              "type": "folder",
              "name": "WS-API",
              "path": "examples/OKX/Websocket/WS-API",
              "children": [
                {
                  "type": "file",
                  "name": "ws-api-client.ts",
                  "path": "examples/OKX/Websocket/WS-API/ws-api-client.ts",
                  "code": "import { DefaultLogger, WebsocketAPIClient } from 'okx-api';\n\n// function attachEventHandlers<TWSClient extends WebsocketClient>(\n//   wsClient: TWSClient,\n// ): void {\n//   wsClient.on('update', (data) => {\n//     console.log('raw message received ', JSON.stringify(data));\n//   });\n//   wsClient.on('open', (data) => {\n//     console.log('ws connected', data.wsKey);\n//   });\n//   wsClient.on('reconnect', ({ wsKey }) => {\n//     console.log('ws automatically reconnecting.... ', wsKey);\n//   });\n//   wsClient.on('reconnected', (data) => {\n//     console.log('ws has reconnected ', data?.wsKey);\n//   });\n//   wsClient.on('authenticated', (data) => {\n//     console.log('ws has authenticated ', data?.wsKey);\n//   });\n// }\n\n(async () => {\n  const logger = {\n    ...DefaultLogger,\n    trace: (...params: any) => console.log('trace', ...params),\n  };\n\n  // For private events, all 3 of the following are required (per account):\n  const API_KEY = process.env.API_KEY_COM;\n  const API_SECRET = process.env.API_SECRET_COM;\n  const API_PASSPHRASE = process.env.API_PASSPHRASE_COM;\n\n  // If running from CLI in unix, you can pass env vars as such:\n  // API_KEY_COM='lkm12n3-2ba3-1mxf-fn13-lkm12n3a' API_SECRET_COM='035B2B9637E1BDFFEE2646BFBDDB8CE4' API_PASSPHRASE_COM='ComplexPa$$!23$5^' ts-node examples/ws-private.ts\n\n  const wsClient = new WebsocketAPIClient(\n    {\n      // For Global users (www.okx.com), you don't need to set the market.\n      // It will use global by default.\n      // Not needed: market: 'GLOBAL',\n\n      // For EEA users (my.okx.com), set market to \"EEA\":\n      // market: 'EEA',\n\n      // For US users (app.okx.com), set market to \"US\":\n      // market: 'US',\n\n      accounts: [\n        // For private topics, include one or more accounts in an array. Otherwise only public topics will work\n        {\n          apiKey: API_KEY || '',\n          apiSecret: API_SECRET || '',\n          apiPass: API_PASSPHRASE || '',\n        },\n      ],\n    },\n    logger,\n  );\n\n  // Optional, see above \"attachEventListeners\". Attach basic event handlers, so nothing is left unhandled\n  // attachEventHandlers(wsClient.getWSClient());\n\n  // Optional: prepare the WebSocket API connection in advance.\n  // This happens automatically but you can do this early before making any API calls, to prevent delays from a cold start.\n  // await wsClient.connectWSAPI();\n\n  /**\n   * OKX's WebSocket API be used like a REST API, through this SDK's WebsocketAPIClient. The WebsocketAPIClient is a utility class wrapped around WebsocketClient's sendWSAPIRequest() capabilities.\n   *\n   * Each request sent via the WebsocketAPIClient will automatically:\n   * - route via the active WS API connection\n   * - return a Promise, which automatically resolves/rejects when a matching response is received\n   */\n\n  /**\n   * Place Order\n   * https://www.okx.com/docs-v5/en/#order-book-trading-trade-ws-place-order\n   */\n  try {\n    const res = await wsClient.submitNewOrder({\n      instId: 'BTC-USDT',\n      tdMode: 'cash',\n      side: 'buy',\n      ordType: 'market',\n      sz: '100',\n    });\n    /**\n      const res = {\n        id: '2',\n        op: 'order',\n        code: '1',\n        msg: '',\n        data: [\n          {\n            tag: '159881cb7207BCDE',\n            ts: '1753714603721',\n            ordId: '',\n            clOrdId: '',\n            sCode: '51008',\n            sMsg: 'Order failed. Insufficient USDT balance in account.'\n          }\n        ],\n        inTime: '1753714603720755',\n        outTime: '1753714603721942',\n        wsKey: 'prodPrivate',\n        isWSAPIResponse: false\n      }\n\n      const res =  {\n        id: '2',\n        op: 'order',\n        code: '1',\n        msg: '',\n        data: [\n          {\n            tag: '159881cb7207BCDE',\n            ts: '1753714567149',\n            ordId: '',\n            clOrdId: '',\n            sCode: '51010',\n            sMsg: \"You can't complete this request under your current account mode.\"\n          }\n        ],\n        inTime: '1753714567149196',\n        outTime: '1753714567149913',\n        wsKey: 'prodPrivate',\n        isWSAPIResponse: false\n      }\n     */\n\n    console.log(new Date(), 'WS API \"submitNewOrder()\" result: ', res);\n  } catch (e) {\n    console.error(new Date(), 'Exception with WS API \"submitNewOrder()\": ', e);\n  }\n\n  /**\n   * Submit multiple orders in a batch\n   * https://www.okx.com/docs-v5/en/#order-book-trading-trade-ws-place-multiple-orders\n   */\n  try {\n    const res = await wsClient.submitMultipleOrders([\n      {\n        instId: 'BTC-USDT',\n        tdMode: 'cash',\n        side: 'buy',\n        ordType: 'market',\n        sz: '100',\n      },\n      {\n        instId: 'BTC-USDT',\n        tdMode: 'cash',\n        side: 'buy',\n        ordType: 'market',\n        sz: '50',\n      },\n    ]);\n    console.log(new Date(), 'WS API \"submitMultipleOrders()\" result: ', res);\n  } catch (e) {\n    console.error(\n      new Date(),\n      'Exception with WS API \"submitMultipleOrders()\": ',\n      e,\n    );\n  }\n\n  console.log(new Date(), 'Reached end of example.');\n})();\n",
                  "metadata": {}
                },
                {
                  "type": "file",
                  "name": "ws-api-trade-raw.ts",
                  "path": "examples/OKX/Websocket/WS-API/ws-api-trade-raw.ts",
                  "code": "import { DefaultLogger, WebsocketClient, WS_KEY_MAP } from 'okx-api';\n\n(async () => {\n  const logger = {\n    ...DefaultLogger,\n    trace: (...params: any) => console.log('trace', ...params),\n  };\n\n  // For private events, all 3 of the following are required (per account):\n  const API_KEY = process.env.API_KEY_COM;\n  const API_SECRET = process.env.API_SECRET_COM;\n  const API_PASSPHRASE = process.env.API_PASSPHRASE_COM;\n\n  // If running from CLI in unix, you can pass env vars as such:\n  // API_KEY_COM='lkm12n3-2ba3-1mxf-fn13-lkm12n3a' API_SECRET_COM='035B2B9637E1BDFFEE2646BFBDDB8CE4' API_PASSPHRASE_COM='ComplexPa$$!23$5^' ts-node examples/ws-private.ts\n\n  const wsClient = new WebsocketClient(\n    {\n      accounts: [\n        // For private topics, include one or more accounts in an array. Otherwise only public topics will work\n        {\n          apiKey: API_KEY || '',\n          apiSecret: API_SECRET || '',\n          apiPass: API_PASSPHRASE || '',\n        },\n      ],\n    },\n    logger,\n  );\n\n  wsClient.on('update', (data) => {\n    console.log('WS raw message received ', data);\n    // console.log('WS raw message received ', JSON.stringify(data, null, 2));\n  });\n\n  wsClient.on('open', (data) => {\n    console.log('WS connection opened:', data.wsKey);\n  });\n  wsClient.on('response', (data) => {\n    console.log('WS response: ', JSON.stringify(data, null, 2));\n  });\n  wsClient.on('reconnect', ({ wsKey }) => {\n    console.log('WS automatically reconnecting.... ', wsKey);\n  });\n  wsClient.on('reconnected', (data) => {\n    console.log('WS reconnected ', data?.wsKey);\n  });\n  wsClient.on('exception', (data) => {\n    console.log('WS error', data);\n  });\n\n  // prodPrivate is for the www.okx.com /ws/v5/private channel\n  const OKX_GLOBAL_PRIVATE_CHANNEL = WS_KEY_MAP.prodPrivate;\n\n  // prodBusiness is for the www.okx.com /ws/v5/business channel\n  // const OKX_GLOBAL_BUSINESS_CHANNEL = WS_KEY_MAP.prodBusiness;\n\n  /**\n   * OKX's WebSocket API can be used via the sendWSAPIRequest() method.\n   *\n   * The correct WS Key depends on where you registered (www.okx.com vs app.okx.com vs my.okx.com), and whether you are using book trading (uses private connection) or spread trading (uses business connection) functionality.\n   *\n   * Note: for a better user experience, it is recommended to use the WebsocketAPIClient.\n   */\n\n  /**\n   * Place Order\n   * https://www.okx.com/docs-v5/en/#order-book-trading-trade-ws-place-order\n   */\n  try {\n    const res = await wsClient.sendWSAPIRequest(\n      OKX_GLOBAL_PRIVATE_CHANNEL,\n      'order',\n      {\n        instId: 'BTC-USDT',\n        tdMode: 'cash',\n        side: 'buy',\n        ordType: 'market',\n        sz: '100',\n      },\n    );\n\n    /**\n      const res = {\n        id: '2',\n        op: 'order',\n        code: '1',\n        msg: '',\n        data: [\n          {\n            tag: '159881cb7207BCDE',\n            ts: '1753714603721',\n            ordId: '',\n            clOrdId: '',\n            sCode: '51008',\n            sMsg: 'Order failed. Insufficient USDT balance in account.'\n          }\n        ],\n        inTime: '1753714603720755',\n        outTime: '1753714603721942',\n        wsKey: 'prodPrivate',\n        isWSAPIResponse: false\n      }\n\n      const res =  {\n        id: '2',\n        op: 'order',\n        code: '1',\n        msg: '',\n        data: [\n          {\n            tag: '159881cb7207BCDE',\n            ts: '1753714567149',\n            ordId: '',\n            clOrdId: '',\n            sCode: '51010',\n            sMsg: \"You can't complete this request under your current account mode.\"\n          }\n        ],\n        inTime: '1753714567149196',\n        outTime: '1753714567149913',\n        wsKey: 'prodPrivate',\n        isWSAPIResponse: false\n      }\n\n     */\n\n    console.log(new Date(), 'WS API \"order\" result: ', res);\n  } catch (e) {\n    console.error(new Date(), 'Exception with WS API \"place-order\": ', e);\n  }\n\n  /**\n   * Cancel Order\n   * https://www.okx.com/docs-v5/en/#order-book-trading-trade-ws-cancel-order\n   */\n  try {\n    const res = await wsClient.sendWSAPIRequest(\n      OKX_GLOBAL_PRIVATE_CHANNEL,\n      'cancel-order',\n      {\n        instId: 'BTC-USDT',\n        ordId: '2510789768709120',\n      },\n    );\n\n    /**\n      const res = {\n        id: '2',\n        op: 'cancel-order',\n        code: '1',\n        msg: '',\n        data: [\n          {\n            ts: '1753714393003',\n            ordId: '2510789768709120',\n            clOrdId: '',\n            sCode: '51400',\n            sMsg: 'Order cancellation failed as the order has been filled, canceled or does not exist.'\n          }\n        ],\n        inTime: '1753714393003190',\n        outTime: '1753714393004074',\n        wsKey: 'prodPrivate',\n        isWSAPIResponse: false\n      }\n     */\n\n    console.log(new Date(), 'WS API \"cancel-order\" result: ', res);\n  } catch (e) {\n    console.error(new Date(), 'Exception with WS API \"place-order\": ', e);\n  }\n\n  console.log(new Date(), 'Reached end of example.');\n})();\n",
                  "metadata": {}
                }
              ]
            },
            {
              "type": "file",
              "name": "ws-private-handle-auth-fail.ts",
              "path": "examples/OKX/Websocket/ws-private-handle-auth-fail.ts",
              "code": "import { WebsocketClient } from 'okx-api';\n\n/**\n *\n * This simple example demonstrates one way to handle failed authentication, stopping the\n * websocket client from running into a reconnect-loop when authentication fails (e.g. bad API keys).\n *\n * However, keep in mind it might be safer to make a test REST API call (e.g. fetch account balance) before\n * trying to make a private WS connection to the account.\n *\n */\n\nconst wsClient = new WebsocketClient({\n  accounts: [\n    // For private topics, include one or more accounts in an array. Otherwise only public topics will work\n    {\n      apiKey: 'INCORRECT_API_KEY',\n      apiSecret: 'INCORRECT_API_SECRET',\n      apiPass: 'INCORRECT_API_PASSPHRASE',\n    },\n  ],\n});\n\n// Raw data will arrive on the 'update' event\nwsClient.on('update', (data) => {\n  // console.log('ws update (raw data received)', JSON.stringify(data, null, 2));\n  console.log('ws update (raw data received)', JSON.stringify(data));\n});\n\nwsClient.on('open', (data) => {\n  console.log('connection opened open:', data.wsKey);\n});\n\n// Replies (e.g. authenticating or subscribing to channels) will arrive on the 'response' event\nwsClient.on('response', (data) => {\n  // console.log('ws response: ', JSON.stringify(data, null, 2));\n  console.log('ws response: ', JSON.stringify(data));\n});\n\nwsClient.on('reconnect', ({ wsKey }) => {\n  console.log('ws automatically reconnecting.... ', wsKey);\n});\nwsClient.on('reconnected', (data) => {\n  console.log('ws has reconnected ', data?.wsKey);\n});\n\nwsClient.on('exception', (data) => {\n  console.error('ws exception: ', data);\n\n  const INVALID_API_KEY_ERROR = '60005';\n  if (data.event === 'error' && data.code === INVALID_API_KEY_ERROR) {\n    console.error('Detected auth failure - closing websocket');\n    wsClient.close(data.wsKey);\n  }\n});\n\n// Optional, connect before subscribing:\nwsClient.connectPrivate();\n\n// This is optional though. The wsclient will automatically open and subscribe if the connection doesn't exist yet.\n\n// Subscribe one event at a time:\nwsClient.subscribe({\n  channel: 'account',\n});\n",
              "metadata": {}
            },
            {
              "type": "file",
              "name": "ws-private.ts",
              "path": "examples/OKX/Websocket/ws-private.ts",
              "code": "import { DefaultLogger, WebsocketClient } from 'okx-api';\n\n// Optional: Inject a custom logger.\n// This example overrides the default logger to also log \"trace\" (super verbose) messages, which are disabled by default\nconst logger = {\n  ...DefaultLogger,\n  // trace: (...params) => console.log('trace', ...params),\n};\n\n// For private events, all 3 of the following are required (per account):\nconst API_KEY = process.env.API_KEY_COM;\nconst API_SECRET = process.env.API_SECRET_COM;\nconst API_PASSPHRASE = process.env.API_PASSPHRASE_COM;\n\n// If running from CLI in unix, you can pass env vars as such:\n// API_KEY_COM='lkm12n3-2ba3-1mxf-fn13-lkm12n3a' API_SECRET_COM='035B2B9637E1BDFFEE2646BFBDDB8CE4' API_PASSPHRASE_COM='ComplexPa$$!23$5^' ts-node examples/ws-private.ts\n\n// note the single quotes, preventing special characters such as $ from being incorrectly passed\n\nif (!API_KEY) {\n  throw new Error('API_KEY is missing');\n}\n\nif (!API_SECRET) {\n  throw new Error('API_SECRET is missing');\n}\n\nif (!API_PASSPHRASE) {\n  throw new Error('API_PASSPHRASE is missing');\n}\n\nconst wsClient = new WebsocketClient(\n  {\n    // For Global users (www.okx.com), you don't need to set the market.\n    // It will use global by default.\n    // Not needed: market: 'GLOBAL',\n\n    // For EEA users (my.okx.com), set market to \"EEA\":\n    // market: 'EEA',\n\n    // For US users (app.okx.com), set market to \"US\":\n    // market: 'US',\n\n    accounts: [\n      // For private topics, include one or more accounts in an array. Otherwise only public topics will work\n      {\n        apiKey: API_KEY,\n        apiSecret: API_SECRET,\n        apiPass: API_PASSPHRASE,\n      },\n      // {\n      //   apiKey: 'yourApiKeyHere',\n      //   apiSecret: 'yourApiSecretHere',\n      //   apiPass: 'yourApiPassHere',\n      // },\n      // {\n      //   apiKey: 'anotherAccountKey',\n      //   apiSecret: 'anotherAccountSecret',\n      //   apiPass: 'anotherAccountPass',\n      // },\n    ],\n  },\n  logger,\n);\n\n// Raw data will arrive on the 'update' event\nwsClient.on('update', (data) => {\n  // console.log('ws update (raw data received)', JSON.stringify(data, null, 2));\n  console.log('ws update (raw data received)', JSON.stringify(data));\n});\n\nwsClient.on('open', (data) => {\n  console.log('connection opened open:', data.wsKey);\n});\n\n// Replies (e.g. authenticating or subscribing to channels) will arrive on the 'response' event\nwsClient.on('response', (data) => {\n  // console.log('ws response: ', JSON.stringify(data, null, 2));\n  console.log('ws response: ', JSON.stringify(data));\n});\n\nwsClient.on('reconnect', ({ wsKey }) => {\n  console.log('ws automatically reconnecting.... ', wsKey);\n});\nwsClient.on('reconnected', (data) => {\n  console.log('ws has reconnected ', data?.wsKey);\n});\nwsClient.on('exception', (data) => {\n  console.error('ws exception: ', data);\n});\n\n// Optional, connect before subscribing:\n// wsClient.connectPrivate();\n\n// This is optional though. The wsclient will automatically open and subscribe if the connection doesn't exist yet.\n\n/**\n   * # Subscribing to channels\n   *\n   * Subscribe to channels using the inner \"args\" part of the subscription request described in the OKX API docs.\n   *\n   * For example, if the docs state your request should look as such:\n   {\n     op: \"subscribe\",\n     args: [\n       {\n         channel: \"account\"\n       }\n     ]\n   }\n   *\n   * You should call the wsClient.subscribe function using only the \"args\".\n   *\n   * Either of these examples is correct (one channel vs one or more channels in an array):\n   wsClient.subscribe({\n     channel: 'account'\n   });\n\n   wsClient.subscribe([\n     {\n       channel: \"account\"\n     }\n   ])\n   */\n\n// Subscribe one event at a time:\nwsClient.subscribe({\n  channel: 'account',\n});\n\n// OR, combine multiple subscription events into one request using an array instead of an object:\nwsClient.subscribe([\n  {\n    channel: 'account',\n  },\n  {\n    channel: 'positions',\n    instType: 'ANY',\n  },\n]);\n\n/**\n * Examples for each private channel listed in the API docs:\n * https://www.okx.com/docs-v5/en/#websocket-api-private-channel\n */\n\n// Account events for all symbols\nwsClient.subscribe({\n  channel: 'account',\n});\n\n// Account events for specific symbol only\nwsClient.subscribe({\n  channel: 'account',\n  ccy: 'BTC',\n});\n\n// Withdrawal events for specific symbol only\nwsClient.subscribe({\n  channel: 'withdrawal-info',\n  ccy: 'BTC',\n});\n\n// Position events on any instrument type\nwsClient.subscribe({\n  channel: 'positions',\n  instType: 'ANY',\n});\n\n// Position events on specific instruments\nwsClient.subscribe({\n  channel: 'positions',\n  instType: 'SWAP',\n  instFamily: 'ETH-USD',\n  instId: 'ETH-USD-SWAP',\n});\n\n// Balance & position channel\nwsClient.subscribe({\n  channel: 'balance_and_position',\n});\n\n// Order channel\nwsClient.subscribe({\n  channel: 'orders',\n  instType: 'ANY',\n});\n\n// Order channel with extra args\nwsClient.subscribe({\n  channel: 'orders',\n  instType: 'FUTURES',\n  instFamily: 'BTC-USD',\n});\n\n// Algo orders channel\nwsClient.subscribe({\n  channel: 'orders-algo',\n  instType: 'ANY',\n});\n\n// Advance algo orders channel\nwsClient.subscribe({\n  channel: 'algo-advance',\n  instType: 'ANY',\n});\n\n// Position risk warning channel\nwsClient.subscribe({\n  channel: 'liquidation-warning',\n  instType: 'ANY',\n});\n\n// Account greeks channel\nwsClient.subscribe({\n  channel: 'account-greeks',\n});\n\n// Spot grid algo orders channel\nwsClient.subscribe({\n  channel: 'grid-orders-spot',\n  instType: 'SPOT',\n});\n\n// Contract grid orders channel\nwsClient.subscribe({\n  channel: 'grid-orders-contract',\n  instType: 'ANY',\n});\n\n// Moon grid orders channel\nwsClient.subscribe({\n  channel: 'grid-orders-moon',\n  instType: 'ANY',\n});\n\n// Moon grid orders channel\nwsClient.subscribe({\n  channel: 'grid-orders-moon',\n  instType: 'ANY',\n});\n\n// Grid positions channel\nwsClient.subscribe({\n  channel: 'grid-positions',\n  algoId: '449327675342323712',\n});\n\n// Grid sub orders channel\nwsClient.subscribe({\n  channel: 'grid-sub-orders',\n  algoId: '449327675342323712',\n});\n",
              "metadata": {}
            },
            {
              "type": "file",
              "name": "ws-public.ts",
              "path": "examples/OKX/Websocket/ws-public.ts",
              "code": "import { DefaultLogger, WebsocketClient } from 'okx-api';\n\n// Optional: Inject a custom logger.\n// This example overrides the default logger to also log \"trace\" (super verbose) messages, which are disabled by default\nconst logger = {\n  ...DefaultLogger,\n  // trace: (...params) => console.log('trace', ...params),\n};\n\nconst wsClient = new WebsocketClient(\n  {\n    // For Global users (www.okx.com), you don't need to set the market.\n    // It will use global by default.\n    // Not needed: market: 'GLOBAL',\n    // For EEA users (my.okx.com), set market to \"EEA\":\n    // market: 'EEA',\n    // For US users (app.okx.com), set market to \"US\":\n    // market: 'US',\n  },\n  logger, // Optional: inject the custom logger here\n);\n\n// Raw data will arrive on the 'update' event\nwsClient.on('update', (data) => {\n  // console.log(\n  //   new Date(),\n  //   'ws update (raw data received)',\n  //   JSON.stringify(data, null, 2),\n  // );\n  // console.log('ws update (raw data received)', JSON.stringify(data, null, 2));\n  console.log(\n    new Date(),\n    'ws update (raw data received)',\n    JSON.stringify(data),\n  );\n});\n\nwsClient.on('open', (data) => {\n  console.log('ws connection opened open:', data.wsKey);\n});\n\n// Replies (e.g. authenticating or subscribing to channels) will arrive on the 'response' event\nwsClient.on('response', (data) => {\n  console.log('ws response received: ', JSON.stringify(data, null, 2));\n});\n\nwsClient.on('reconnect', ({ wsKey }) => {\n  console.log('ws automatically reconnecting.... ', wsKey);\n});\nwsClient.on('reconnected', (data) => {\n  console.log('ws has reconnected ', data?.wsKey);\n});\nwsClient.on('exception', (data) => {\n  console.error('ws exception: ', data);\n});\n\n// Send one topic at a time\nwsClient.subscribe({\n  channel: 'instruments',\n  instType: 'FUTURES',\n});\n\n// Or an array of requests\nwsClient.subscribe([\n  {\n    channel: 'instruments',\n    instType: 'SPOT',\n  },\n  {\n    channel: 'tickers',\n    instId: 'LTC-BTC',\n  },\n]);\n\n/**\n *\n * Examples for each channel: https://www.okx.com/docs-v5/en/#websocket-api-public-channel\n *\n */\n\n// Instruments channel\nwsClient.subscribe({\n  channel: 'instruments',\n  instType: 'SPOT',\n});\n\n// Tickers channel\nwsClient.subscribe({\n  channel: 'tickers',\n  instId: 'BTC-USDT',\n});\n\n// Open interest channel\nwsClient.subscribe({\n  channel: 'open-interest',\n  instId: 'BTC-USD-SWAP',\n});\n\n// Candlesticks channel\nwsClient.subscribe({\n  channel: 'candle1m',\n  instId: 'BTC-USDT',\n});\n\n// Trades channel\nwsClient.subscribe({\n  channel: 'trades',\n  instId: 'BTC-USDT',\n});\n\n// Estimated delivery/exercise price channel\nwsClient.subscribe({\n  channel: 'estimated-price',\n  instType: 'FUTURES',\n  instFamily: 'BTC-USD',\n});\n\n// Mark price channel\nwsClient.subscribe({\n  channel: 'mark-price',\n  instId: 'BTC-USDT',\n});\n\n// Mark price candlesticks channel\nwsClient.subscribe({\n  channel: 'mark-price-candle1m',\n  instId: 'BTC-USDT',\n});\n\n// Price limit channel\nwsClient.subscribe({\n  channel: 'price-limit',\n  instId: 'BTC-USDT-SWAP',\n});\n\n// Order book channel\nwsClient.subscribe({\n  channel: 'books',\n  instId: 'BTC-USDT',\n});\n\n// OPTION summary channel\nwsClient.subscribe({\n  channel: 'opt-summary',\n  instFamily: 'BTC-USD',\n});\n\n// Funding rate channel\nwsClient.subscribe({\n  channel: 'funding-rate',\n  instId: 'BTC-USD-SWAP',\n});\n\n// Index candlesticks channel\nwsClient.subscribe({\n  channel: 'index-candle1m',\n  instId: 'BTC-USD',\n});\n\n// Index tickers channel\nwsClient.subscribe({\n  channel: 'index-tickers',\n  instId: 'BTC-USDT',\n});\n\n// Status channel\nwsClient.subscribe({\n  channel: 'status',\n});\n\n// Liquidation orders channel\nwsClient.subscribe({\n  channel: 'liquidation-orders',\n  instType: 'FUTURES',\n});\n\nwsClient.subscribe({\n  channel: 'liquidation-orders',\n  instType: 'SWAP',\n});\n",
              "metadata": {}
            }
          ]
        }
      ]
    }
  ]
}